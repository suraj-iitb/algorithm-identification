0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include <cstdio> #include <vector> #include <algorithm> #include <queue> #include <utility> using namespace std ; template < class T > using lp_queue = priority_queue < T , deque < T > , greater < T > > ; using Weight = long long ; static const Weight INF = 1LL << 57 ; struct Edge { size_t src , dst ; Weight weight ; Edge ( ) { } Edge ( size_t src , size_t dst , Weight weight = 1 ) : src ( src ) , dst ( dst ) , weight ( weight ) { } } ; bool operator < ( const Edge & e , const Edge & f ) { if ( e . weight ! = f . weight ) { return e . weight > f . weight ; } else { return e . src ! = f . src ? e . src < f . src : e . dst < f . dst ; } } using Edges = vector < Edge > ; using Vertex = vector < Edge > ; using Graph = vector < Vertex > ; void join ( Graph & g , size_t s , size_t d , Weight w = 1 ) { g [ s ] . push_back ( Edge ( s , d , w ) ) ; g [ d ] . push_back ( Edge ( d , s , w ) ) ; } void connect ( Graph & g , size_t s , size_t d , Weight w = 1 ) { g [ s ] . push_back ( Edge ( s , d , w ) ) ; } vector < vector < Weight > > shortest_distance ( Graph & g ) { size_t V = g . size ( ) ; vector < Weight > h ( V ) ; for ( size_t k = 0 ; k < V ; ++ k ) for ( size_t i = 0 ; i < V ; ++ i ) for ( const Edge & e : g [ i ] ) if ( h [ e . dst ] > h [ e . src ] + e . weight ) { h [ e . dst ] = h [ e . src ] + e . weight ; if ( k == V - 1 ) return vector < vector < Weight > > ( ) ; } for ( size_t i = 0 ; i < V ; ++ i ) for ( Edge & e : g [ i ] ) e . weight += h [ e . src ] - h [ e . dst ] ; vector < vector < Weight > > d ( V , vector < Weight > ( V , INF ) ) ; for ( size_t s = 0 ; s < V ; ++ s ) { d [ s ] [ s ] = 0 ; lp_queue < pair < Weight , size_t > > q ; q . push ( make_pair ( 0 , s ) ) ; while ( ! q . empty ( ) ) { pair < Weight , size_t > p = q . top ( ) ; q . pop ( ) ; size_t v = p . second ; if ( d [ s ] [ v ] < p . first ) continue ; for ( const Edge & e : g [ v ] ) if ( d [ s ] [ e . dst ] > d [ s ] [ v ] + e . weight ) { d [ s ] [ e . dst ] = d [ s ] [ v ] + e . weight ; q . push ( make_pair ( d [ s ] [ e . dst ] , e . dst ) ) ; } } for ( size_t u = 0 ; u < V ; ++ u ) if ( d [ s ] [ u ] < INF ) d [ s ] [ u ] += h [ u ] - h [ s ] ; } return d ; } int main ( ) { size_t V , E ; scanf ( "%zu %zu" , & V , & E ) ; Graph g ( V ) ; for ( size_t i = 0 ; i < E ; ++ i ) { size_t s , t ; Weight d ; scanf ( "%zu %zu %lld" , & s , & t , & d ) ; connect ( g , s , t , d ) ; } vector < vector < Weight > > d = shortest_distance ( g ) ; if ( d . empty ( ) ) return ! printf ( "NEGATIVE CYCLE\n" ) ; for ( vector < Weight > & w : d ) for ( size_t i = 0 ; i < V ; ++ i ) if ( w [ i ] < INF ) { printf ( "%lld%c" , w [ i ] , i < V - 1 ? ' ' : '\n' ) ; } else { printf ( "INF%c" , i < V - 1 ? ' ' : '\n' ) ; } return 0 ; }<CODESPLIT>5.653750896453857<CODESPLIT>-0.8980472087860107<CODESPLIT>-1.018385887145996<CODESPLIT>-1.1753864288330078<CODESPLIT>-1.2624783515930176<CODESPLIT>-1.2821797132492065
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> using namespace std ; typedef long long ll ; #define rep(i, n) for(ll i = 0, i##_len = (n); i < i##_len; i++) #define reps(i, s, n) for(ll i = (s), i##_len = (n); i < i##_len; i++) #define rrep(i, n) for(ll i = (n) - 1; i >= 0; i--) #define rreps(i, e, n) for(ll i = (n) - 1; i >= (e); i--) #define all(x) (x).begin(), (x).end() #define sz(x) ((ll)(x).size()) #define len(x) ((ll)(x).length()) int main ( ) { cin . tie ( 0 ) ; ios :: sync_with_stdio ( false ) ; const ll inf = LONG_LONG_MAX / 2 - 1 ; ll v , e ; cin > > v > > e ; vector < vector < ll > > g ( v , vector < ll > ( v , inf ) ) ; rep ( i , v ) g [ i ] [ i ] = 0 ; rep ( i , e ) { ll s , t , d ; cin > > s > > t > > d ; g [ s ] [ t ] = d ; } rep ( i , v ) { rep ( j , v ) { rep ( k , v ) { if ( ( g [ j ] [ i ] == inf ) || ( g [ i ] [ k ] == inf ) ) continue ; g [ j ] [ k ] = min ( g [ j ] [ k ] , g [ j ] [ i ] + g [ i ] [ k ] ) ; } } } rep ( i , v ) { rep ( j , v ) { rep ( k , v ) { if ( ( g [ j ] [ i ] == inf ) || ( g [ i ] [ k ] == inf ) ) continue ; if ( g [ j ] [ k ] > g [ j ] [ i ] + g [ i ] [ k ] ) { cout << "NEGATIVE CYCLE" << endl ; return 0 ; } } } } rep ( i , v ) { rep ( j , v ) { string val = ( g [ i ] [ j ] == inf ) ? "INF" : to_string ( g [ i ] [ j ] ) ; printf ( "%s%s" , val . c_str ( ) , ( j == ( v - 1 ) ) ? "\n" : " " ) ; } } return 0 ; }<CODESPLIT>5.680083751678467<CODESPLIT>-1.1626629829406738<CODESPLIT>-1.0227776765823364<CODESPLIT>-1.1671569347381592<CODESPLIT>-1.2205287218093872<CODESPLIT>-1.229399561882019
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> #define fi first #define se second #define pb push_back #define mp make_pair using namespace std ; typedef pair < int , int > pii ; typedef pair < pii , int > ppiii ; const int INF = 2147483647 ; int n , m , t1 , t2 , t3 , d [ 105 ] [ 105 ] ; int main ( ) { cin > > n > > m ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) d [ i ] [ j ] = INF ; for ( int i = 0 ; i < m ; i ++ ) { cin > > t1 > > t2 > > t3 ; d [ t1 ] [ t2 ] = t3 ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { for ( int k = 0 ; k < n ; k ++ ) { if ( j == k ) d [ j ] [ k ] = 0 ; if ( d [ j ] [ i ] == INF || d [ i ] [ k ] == INF ) continue ; if ( d [ j ] [ i ] + d [ i ] [ k ] < d [ j ] [ k ] ) { d [ j ] [ k ] = d [ j ] [ i ] + d [ i ] [ k ] ; } } } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { for ( int k = 0 ; k < n ; k ++ ) { if ( j == k ) d [ j ] [ k ] = 0 ; if ( d [ j ] [ i ] == INF || d [ i ] [ k ] == INF ) continue ; if ( d [ j ] [ i ] + d [ i ] [ k ] < d [ j ] [ k ] ) { cout << "NEGATIVE CYCLE" << endl ; return 0 ; } } } } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( d [ i ] [ j ] == INF ) cout << "INF" ; else cout << d [ i ] [ j ] ; if ( j < n - 1 ) cout << ' ' ; } cout << endl ; } }<CODESPLIT>5.697109699249268<CODESPLIT>-1.2051457166671753<CODESPLIT>-1.0314438343048096<CODESPLIT>-1.1334784030914307<CODESPLIT>-1.1961146593093872<CODESPLIT>-1.2412065267562866
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include <cstdio> #include <algorithm> #include <queue> #include <vector> #define NIL -1 #define MAXN 10000 using namespace std ; typedef long long llong ; llong INFINITY = 1LL << 32 ; llong graph [ MAXN ] [ MAXN ] ; int n , e ; void init ( ) { for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) { graph [ i ] [ j ] = ( i == j ? 0 : INFINITY ) ; } } } void floyd ( ) { for ( int k = 0 ; k < n ; ++ k ) { for ( int i = 0 ; i < n ; ++ i ) { if ( graph [ i ] [ k ] == INFINITY ) continue ; for ( int j = 0 ; j < n ; ++ j ) { if ( graph [ k ] [ j ] == INFINITY ) continue ; graph [ i ] [ j ] = min ( graph [ i ] [ j ] , graph [ i ] [ k ] + graph [ k ] [ j ] ) ; } } } } int main ( ) { scanf ( "%lld %d" , & n , & e ) ; init ( ) ; llong u , v , w ; for ( int i = 0 ; i < e ; ++ i ) { scanf ( "%lld %lld %lld" , & u , & v , & w ) ; graph [ u ] [ v ] = w ; } floyd ( ) ; for ( int j = 0 ; j < n ; ++ j ) { if ( graph [ j ] [ j ] < 0 ) { printf ( "NEGATIVE CYCLE\n" ) ; return 0 ; } } for ( int k = 0 ; k < n ; ++ k ) { for ( int i = 0 ; i < n ; ++ i ) { if ( i ) printf ( " " ) ; if ( graph [ k ] [ i ] == INFINITY ) printf ( "INF" ) ; else printf ( "%lld" , graph [ k ] [ i ] ) ; } printf ( "\n" ) ; } }<CODESPLIT>5.6706719398498535<CODESPLIT>-1.1466127634048462<CODESPLIT>-1.0168179273605347<CODESPLIT>-1.11920964717865<CODESPLIT>-1.2243174314498901<CODESPLIT>-1.2631107568740845
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> using namespace std ; struct edge { int to , cost ; } ; typedef long long ll ; typedef pair < int , int > P ; typedef vector < int > VI ; typedef vector < edge > VE ; static const long long INF = 9223372000000000000 / 2 ; static const int NIL = - 1 ; static const int MOD = 1000000007 ; #define pb push_back #define mp make_pair #define all(x) (x).begin(),(x).end() #define fi first #define se second #define np next_permutation #define pq priority_queue #define itn int #define scnaf scanf #define reutnr return #define scamf scanf #define int ll const int NMAX = 100 ; int n , m ; int d [ NMAX + 10 ] [ NMAX + 10 ] ; void intialize ( ) { for ( int i = 0 ; i < NMAX ; i ++ ) { for ( int j = 0 ; j < NMAX ; j ++ ) d [ i ] [ j ] = INF ; } for ( int i = 0 ; i < NMAX ; i ++ ) d [ i ] [ i ] = 0 ; } void WF ( ) { for ( int k = 0 ; k < n ; k ++ ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) if ( d [ i ] [ k ] ! = INF && d [ k ] [ j ] ! = INF ) d [ i ] [ j ] = min ( d [ i ] [ j ] , d [ i ] [ k ] + d [ k ] [ j ] ) ; } } } void output ( ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( d [ i ] [ j ] == INF ) printf ( "INF" ) ; else printf ( "%d" , d [ i ] [ j ] ) ; if ( j ! = n - 1 ) printf ( " " ) ; } printf ( "\n" ) ; } } void input ( ) { for ( int i = 0 ; i < m ; i ++ ) { int tmp1 , tmp2 , tmp3 ; scanf ( "%lld %lld %lld" , & tmp1 , & tmp2 , & tmp3 ) ; d [ tmp1 ] [ tmp2 ] = tmp3 ; } } void solve ( ) { for ( int i = 0 ; i < n ; i ++ ) { if ( d [ i ] [ i ] < 0 ) { printf ( "NEGATIVE CYCLE\n" ) ; return ; } } output ( ) ; return ; } signed main ( ) { scanf ( "%lld %lld" , & n , & m ) ; intialize ( ) ; input ( ) ; WF ( ) ; solve ( ) ; return 0 ; }<CODESPLIT>5.643783092498779<CODESPLIT>-1.0710344314575195<CODESPLIT>-0.9352084994316101<CODESPLIT>-1.2201111316680908<CODESPLIT>-1.2318388223648071<CODESPLIT>-1.1856378316879272
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#define _CRT_SECURE_NO_WARNINGS #define _USE_MATH_DEFINES #include <iostream> #include <cstdio> #include <algorithm> using namespace std ; const int INF = 2000000000 ; int d [ 100 ] [ 100 ] ; int main ( ) { int n , e ; cin > > n > > e ; fill ( d [ 0 ] , d [ 100 ] , INF ) ; for ( int i = 0 ; i < n ; i ++ ) d [ i ] [ i ] = 0 ; for ( int i = 0 ; i < e ; i ++ ) { int s , t , dis ; cin > > s > > t > > dis ; d [ s ] [ t ] = dis ; } for ( int k = 0 ; k < n ; k ++ ) for ( int i = 0 ; i < n ; i ++ ) { if ( d [ i ] [ k ] == INF ) continue ; for ( int j = 0 ; j < n ; j ++ ) { if ( d [ k ] [ j ] == INF ) continue ; d [ i ] [ j ] = min ( d [ i ] [ j ] , d [ i ] [ k ] + d [ k ] [ j ] ) ; } } for ( int i = 0 ; i < n ; i ++ ) if ( d [ i ] [ i ] < 0 ) { puts ( "NEGATIVE CYCLE" ) ; return 0 ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( j ! = 0 ) cout << " " ; if ( d [ i ] [ j ] < INF ) cout << d [ i ] [ j ] ; else cout << "INF" ; } cout << endl ; } return 0 ; }<CODESPLIT>5.685981273651123<CODESPLIT>-1.0627912282943726<CODESPLIT>-1.0714420080184937<CODESPLIT>-1.1310149431228638<CODESPLIT>-1.2483021020889282<CODESPLIT>-1.3197046518325806
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> using namespace std ; using ll = long long ; const long long INF = ( 1LL << 32 ) ; class FloydWarshall { private : int size ; vector < vector < long long > > d ; public : FloydWarshall ( int n ) { size = n ; d . resize ( n ) ; for ( int i = 0 ; i < n ; ++ i ) { d [ i ] . resize ( n ) ; for ( int j = 0 ; j < n ; ++ j ) { d [ i ] [ j ] = i == j ? 0 : INF ; } } } void add_edge ( int u , int v , int w ) { d [ u ] [ v ] = w ; } long long get_distance ( int src , int dest ) { return d [ src ] [ dest ] ; } void set_distances ( ) { for ( int k = 0 ; k < size ; ++ k ) for ( int i = 0 ; i < size ; ++ i ) for ( int j = 0 ; j < size ; ++ j ) if ( d [ i ] [ k ] < INF && d [ k ] [ j ] < INF ) d [ i ] [ j ] = min ( d [ i ] [ j ] , d [ i ] [ k ] + d [ k ] [ j ] ) ; } bool has_negative_cycle ( ) { for ( int i = 0 ; i < size ; ++ i ) { if ( d [ i ] [ i ] ) return true ; } return false ; } } ; int main ( ) { ios :: sync_with_stdio ( false ) ; cin . tie ( 0 ) ; int V , E ; cin > > V > > E ; FloydWarshall fw ( V ) ; for ( int i = 0 ; i < E ; ++ i ) { int s , t , w ; cin > > s > > t > > w ; fw . add_edge ( s , t , w ) ; } fw . set_distances ( ) ; if ( fw . has_negative_cycle ( ) ) { cout << "NEGATIVE CYCLE" << endl ; } else { for ( int i = 0 ; i < V ; ++ i ) { for ( int j = 0 ; j < V ; ++ j ) { ll d = fw . get_distance ( i , j ) ; if ( d < INF ) cout << d ; else cout << "INF" ; if ( j < V - 1 ) cout << ' ' ; } cout << endl ; } } return 0 ; }<CODESPLIT>5.637314319610596<CODESPLIT>-0.9021920561790466<CODESPLIT>-1.0959312915802002<CODESPLIT>-1.1839935779571533<CODESPLIT>-1.2945679426193237<CODESPLIT>-1.303877592086792
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> #define FOR(i,a,b) for(int i=(a);i<(b);i++) #define REP(i,n) for(int i=0;i < (n);i++) #define ALL(obj) (obj).begin(),(obj).end() using namespace std ; using P = pair < int , int > ; const long long INF = 1LL << 60 ; const int IINF = 100000000 ; const int MOD = ( int ) 1e9 + 7 ; typedef long long ll ; vector < long long > divisor ( long long n ) { vector < long long > ret ; for ( long long i = 1 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { ret . push_back ( i ) ; if ( i * i ! = n ) ret . push_back ( n / i ) ; } } return ret ; } vector < int > dx = { 1 , 0 , - 1 , 0 } ; vector < int > dy = { 0 , - 1 , 0 , 1 } ; int n , m ; vector < vector < ll > > dp ; signed main ( ) { scanf ( "%d %d" , & n , & m ) ; dp . assign ( n , vector < ll > ( n , INF ) ) ; for ( int i = 0 ; i < n ; i ++ ) dp [ i ] [ i ] = 0 ; REP ( i , m ) { ll a , b , c ; scanf ( "%lld %lld %lld" , & a , & b , & c ) ; dp [ a ] [ b ] = c ; } REP ( k , n ) { REP ( i , n ) { REP ( j , n ) { if ( dp [ i ] [ k ] ! = INF && dp [ k ] [ j ] ! = INF ) { dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k ] [ j ] ) ; } } } } REP ( i , n ) { if ( dp [ i ] [ i ] < 0 ) { printf ( "NEGATIVE CYCLE\n" ) ; return 0 ; } } REP ( i , n ) { REP ( j , n ) { if ( dp [ i ] [ j ] == INF ) { printf ( "INF" ) ; } else { printf ( "%lld" , dp [ i ] [ j ] ) ; } if ( j ! = n - 1 ) { printf ( " " ) ; } else { printf ( "\n" ) ; } } } }<CODESPLIT>5.679056644439697<CODESPLIT>-0.9646635055541992<CODESPLIT>-1.0505084991455078<CODESPLIT>-1.1885864734649658<CODESPLIT>-1.2842859029769897<CODESPLIT>-1.2800486087799072
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include  <bits/stdc++.h> #define rep(i,n) for(int (i)=0;(i)<(n);(i)++) using namespace std ; typedef long long int ll ; const int vmax = 110 ; const ll inf = 1LL << 60 ; int N , M ; ll dist [ vmax ] [ vmax ] ; bool warshall_floyd ( ) { rep ( k , N ) rep ( i , N ) rep ( j , N ) { if ( dist [ i ] [ k ] == inf || dist [ k ] [ j ] == inf ) continue ; dist [ i ] [ j ] = min ( dist [ i ] [ j ] , dist [ i ] [ k ] + dist [ k ] [ j ] ) ; } rep ( i , N ) if ( dist [ i ] [ i ] < 0 ) return true ; return false ; } int main ( void ) { cin > > N > > M ; rep ( i , N ) rep ( j , N ) dist [ i ] [ j ] = ( i == j ) ? 0 : inf ; rep ( i , M ) { int a , b , c ; cin > > a > > b > > c ; dist [ a ] [ b ] = c ; } if ( warshall_floyd ( ) ) cout << "NEGATIVE CYCLE" << endl ; else { rep ( i , N ) { rep ( j , N ) { cout << ( j == 0 ? "" : " " ) ; if ( dist [ i ] [ j ] == inf ) cout << "INF" ; else cout << dist [ i ] [ j ] ; } cout << endl ; } } return 0 ; }<CODESPLIT>5.673323631286621<CODESPLIT>-1.1757475137710571<CODESPLIT>-1.0401356220245361<CODESPLIT>-1.119075894355774<CODESPLIT>-1.224436640739441<CODESPLIT>-1.2711020708084106
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include<iostream> #include<algorithm> #include<vector> #include<climits> using namespace std ; static const int MAX = 100 ; static const long long INFTY = ( 1LL << 32 ) ; int n ; long long d [ MAX ] [ MAX ] ; void floyd ( ) { for ( int k = 0 ; k < n ; k ++ ) { for ( int i = 0 ; i < n ; i ++ ) { if ( d [ i ] [ k ] == INFTY ) continue ; for ( int j = 0 ; j < n ; j ++ ) { if ( d [ k ] [ j ] == INFTY ) continue ; d [ i ] [ j ] = min ( d [ i ] [ j ] , d [ i ] [ k ] + d [ k ] [ j ] ) ; } } } } int main ( ) { int e , u , v , c ; cin > > n > > e ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { d [ i ] [ j ] = ( ( i == j ) ? 0 : INFTY ) ; } } for ( int i = 0 ; i < e ; i ++ ) { cin > > u > > v > > c ; d [ u ] [ v ] = c ; } floyd ( ) ; bool negative = false ; for ( int i = 0 ; i < n ; i ++ ) if ( d [ i ] [ i ] < 0 ) negative = true ; if ( negative ) { cout << "NEGATIVE CYCLE" << endl ; } else { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( j ) cout << " " ; if ( d [ i ] [ j ] == INFTY ) cout << "INF" ; else cout << d [ i ] [ j ] ; } cout << endl ; } } return 0 ; }<CODESPLIT>5.674125671386719<CODESPLIT>-1.2544190883636475<CODESPLIT>-1.0167077779769897<CODESPLIT>-1.1025099754333496<CODESPLIT>-1.2099982500076294<CODESPLIT>-1.253574013710022
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include<iostream> #include<bits/stdc++.h> using namespace std ; const int MAX = 1e2+9 ; const long long int inf = INT_MAX ; int dis [ MAX ] [ MAX ] ; void init ( int n ) { for ( int i = 0 ; i < n ; i ++ ) { dis [ i ] [ i ] = 0 ; for ( int j = 0 ; j < n ; j ++ ) { dis [ i ] [ j ] = inf ; } } } int main ( ) { int i , j , k , n , m ; cin > > n > > m ; init ( n ) ; for ( i = 0 ; i < m ; i ++ ) { int x , y , z ; cin > > x > > y > > z ; dis [ x ] [ y ] = z ; } for ( i = 0 ; i < n ; i ++ ) dis [ i ] [ i ] = 0 ; for ( k = 0 ; k < n ; k ++ ) { for ( i = 0 ; i < n ; i ++ ) { for ( j = 0 ; j < n ; j ++ ) { if ( dis [ i ] [ k ] == inf || dis [ k ] [ j ] == inf ) continue ; if ( dis [ i ] [ j ] > dis [ i ] [ k ] + dis [ k ] [ j ] ) { dis [ i ] [ j ] = dis [ i ] [ k ] + dis [ k ] [ j ] ; } } } } int f = 0 ; for ( k = 0 ; k < n ; k ++ ) { if ( dis [ k ] [ k ] < 0 ) f = 1 ; } if ( f ) { cout << "NEGATIVE CYCLE" << "\n" ; } else { for ( i = 0 ; i < n ; i ++ ) { if ( dis [ i ] [ 0 ] == inf ) cout << "INF" ; else cout << dis [ i ] [ 0 ] ; for ( j = 1 ; j < n ; j ++ ) { if ( dis [ i ] [ j ] == inf ) cout << " INF" ; else cout << " " << dis [ i ] [ j ] ; } cout << "\n" ; } } }<CODESPLIT>5.6689534187316895<CODESPLIT>-1.181208610534668<CODESPLIT>-1.0495259761810303<CODESPLIT>-1.1343207359313965<CODESPLIT>-1.2230225801467896<CODESPLIT>-1.265801191329956
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include<bits/stdc++.h> using namespace std ; #define rep(i,n) for(int i=0;i<n;i++) #define REP(i,s,n) for(int i=(s);i<=(n);i++) #define repr(i,n) for(int i=n-1;i>=0;i--) #define REPR(i,s,n) for(int i=(s);i>=(n);i--) #define all(a) (a).begin(),(a).end() #define rall(a) (a).rbegin(),(a).rend() #define Eunique(v) v.erase(unique(all(v)),v.end()) #define Eback(s) s.erase(s.end()-1,s.end()) #define rev(v) reverse(all(v)) #define minvec(v) *min_element(all(v)) #define maxvec(v) *max_element(all(v)) #define sumvec(v) accumulate(all(v),0LL) #define mapmin(v) v.rbegin()->first #define mapmax(v) v.begin()->first #define pb push_back #define pf push_front #define m_p make_pair #define DOUBLE fixed << setprecision(15) #define OK cerr<<"OK\n" #define OK1 cerr<<"OK1\n" #define OK2 cerr<<"OK2\n" #define SIZE(s) (int)s.size() #define INF ((1LL<<62)-(1LL<<31)) #define zero(x,n) setw(x) << setfill('0') << n #define endl '\n' typedef long long ll ; typedef vector < int > vi ; typedef vector < vi > vvi ; typedef vector < long long > vll ; typedef vector < vll > vvll ; typedef vector < double > vd ; typedef vector < vd > vvd ; typedef vector < char > vc ; typedef vector < vc > vvc ; typedef vector < bool > vb ; typedef vector < vb > vvb ; typedef vector < string > vs ; typedef pair < ll , ll > pll ; typedef pair < int , int > pii ; typedef vector < pair < int , int > > vpii ; typedef vector < pair < ll , ll > > vpll ; const double pi = acos ( - 1.0 ) ; const ll mod = 1000000007 ; const ll mod2 = 998244353 ; template < class A , class B > ostream & operator << ( ostream & ost , const pair < A , B > & p ) { ost << "{" << p . first << ", " << p . second << "} " ; return ost ; } template < class T > ostream & operator << ( ostream & ost , const vector < T > & v ) { ost << "{" ; for ( int i = 0 ; i < ( int ) v . size ( ) ; i ++ ) { if ( i ) ost << " " ; ost << v [ i ] ; } ost << "} \n" ; return ost ; } template < class A , class B > ostream & operator << ( ostream & ost , const map < A , B > & v ) { ost << "{" ; for ( auto p : v ) { ost << "{" << p . first << ", " << p . second << "} " ; } ost << "} " ; return ost ; } template < class T > inline bool chmax ( T & a , T b ) { if ( a < b ) { a = b ; return true ; } return false ; } template < class T > inline bool chmin ( T & a , T b ) { if ( a > b ) { a = b ; return true ; } return false ; } void YES ( bool b ) { cout << ( ( b ) ? "YES\n" : "NO\n" ) ; } void Yes ( bool b ) { cout << ( ( b ) ? "Yes\n" : "No\n" ) ; } void yes ( bool b ) { cout << ( ( b ) ? "yes\n" : "no\n" ) ; } void Yay ( bool b ) { cout << ( ( b ) ? "Yay!\n" : ":(\n" ) ; } ll powmod ( ll a , ll b ) { ll c = 1 ; while ( b > 0 ) { if ( b & 1 ) { c = a * c % mod ; } a = a * a % mod ; b > >= 1 ; } return c ; } ll nCrmod ( ll n , ll r ) { ll x = 1 , y = 1 ; rep ( i , r ) { x = x * ( n - i ) % mod ; y = y * ( i + 1 ) % mod ; } return x * powmod ( y , mod - 2 ) % mod ; } ll gcd ( ll x , ll y ) { return __gcd ( x , y ) ; } ll lcm ( ll x , ll y ) { return x / __gcd ( x , y ) * y ; } template < typename T > struct edge { long long src ; long long to ; T cost ; } ; template < typename T > using Edges = vector < edge < T > > ; template < typename T > vector < T > bellman_ford ( Edges < T > & edges , int V , int s ) { vector < T > dist ( V , INF ) ; dist [ s ] = 0 ; for ( int i = 0 ; i < V - 1 ; i ++ ) { for ( auto & e : edges ) { if ( dist [ e . src ] == INF ) continue ; dist [ e . to ] = min ( dist [ e . to ] , dist [ e . src ] + e . cost ) ; } } for ( auto & e : edges ) { if ( dist [ e . src ] == INF ) continue ; if ( dist [ e . src ] + e . cost < dist [ e . to ] ) return vector < T > ( ) ; } return dist ; } int main ( ) { ll n , m ; cin > > n > > m ; vvll v ( n , vll ( n , INF ) ) ; rep ( i , n ) v [ i ] [ i ] = 0 ; Edges < ll > g ; g . resize ( n ) ; rep ( i , m ) { ll s , t , d ; cin > > s > > t > > d ; g . push_back ( { s , t , d } ) ; v [ s ] [ t ] = d ; } auto dist = bellman_ford ( g , n , 0 ) ; if ( dist . empty ( ) ) cout << "NEGATIVE CYCLE\n" ; else { rep ( k , n ) rep ( i , n ) rep ( j , n ) { if ( v [ i ] [ k ] ! = INF && v [ k ] [ j ] ! = INF ) { chmin ( v [ i ] [ j ] , v [ i ] [ k ] + v [ k ] [ j ] ) ; } } rep ( i , n ) { rep ( j , n ) { if ( v [ i ] [ j ] == INF ) cout << "INF" ; else cout << v [ i ] [ j ] ; cout << ( j == n - 1 ? "\n" : " " ) ; } } } return 0 ; }<CODESPLIT>5.683276653289795<CODESPLIT>-1.1043026447296143<CODESPLIT>-1.0346217155456543<CODESPLIT>-1.1637797355651855<CODESPLIT>-1.243613600730896<CODESPLIT>-1.248034119606018
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> using namespace std ; typedef long long ll ; #define INF 10010010010 int main ( ) { ll v , e ; cin > > v > > e ; ll a [ v ] [ v ] ; for ( ll i = 0 ; i < v ; i ++ ) { for ( ll j = 0 ; j < v ; j ++ ) { if ( i == j ) { a [ i ] [ j ] = 0 ; } else { a [ i ] [ j ] = INF ; } } } for ( ll i = 0 ; i < e ; i ++ ) { ll s , t , d ; cin > > s > > t > > d ; a [ s ] [ t ] = d ; } for ( ll k = 0 ; k < v ; k ++ ) { for ( ll i = 0 ; i < v ; i ++ ) { if ( a [ i ] [ k ] == INF ) continue ; for ( ll j = 0 ; j < v ; j ++ ) { if ( a [ k ] [ j ] == INF ) continue ; a [ i ] [ j ] = min ( a [ i ] [ j ] , a [ i ] [ k ] + a [ k ] [ j ] ) ; } } } for ( ll i = 0 ; i < v ; i ++ ) { if ( a [ i ] [ i ] < 0 ) { cout << "NEGATIVE CYCLE" << endl ; return 0 ; } } for ( ll i = 0 ; i < v ; i ++ ) { for ( ll j = 0 ; j < v ; j ++ ) { if ( j ! = 0 ) cout << " " ; if ( a [ i ] [ j ] == INF ) cout << "INF" ; else cout << a [ i ] [ j ] ; } cout << endl ; } return 0 ; }<CODESPLIT>5.661849498748779<CODESPLIT>-1.1438044309616089<CODESPLIT>-1.0652002096176147<CODESPLIT>-1.1284501552581787<CODESPLIT>-1.2298237085342407<CODESPLIT>-1.2791062593460083
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include<iostream> #include<algorithm> using namespace std ; #define INFTY 2000000000 #define N 9900 #define MAX 9900 int v , e , D [ N ] [ N ] , s [ N ] , t [ N ] , d [ MAX ] , minv = INFTY , r [ N ] [ N ] ; int main ( ) { cin > > v > > e ; for ( int i = 0 ; i < v ; i ++ ) { for ( int j = 0 ; j < v ; j ++ ) { if ( i ! = j ) D [ i ] [ j ] = INFTY ; else D [ i ] [ j ] = 0 ; } } for ( int i = 0 ; i < e ; i ++ ) { cin > > s [ i ] > > t [ i ] > > d [ i ] ; D [ s [ i ] ] [ t [ i ] ] = d [ i ] ; } for ( int k = 0 ; k < v ; k ++ ) { for ( int i = 0 ; i < v ; i ++ ) { if ( D [ i ] [ k ] == INFTY ) continue ; for ( int j = 0 ; j < v ; j ++ ) { if ( D [ k ] [ j ] == INFTY ) continue ; D [ i ] [ j ] = min ( D [ i ] [ j ] , D [ i ] [ k ] + D [ k ] [ j ] ) ; } } } bool a = true ; for ( int i = 0 ; i < v ; i ++ ) { if ( D [ i ] [ i ] < 0 ) { a = false ; break ; } } if ( ! a ) cout << "NEGATIVE CYCLE" << endl ; else { for ( int i = 0 ; i < v ; i ++ ) { if ( D [ i ] [ 0 ] == INFTY ) cout << "INF" ; else cout << D [ i ] [ 0 ] ; for ( int j = 1 ; j < v ; j ++ ) { if ( D [ i ] [ j ] == INFTY ) cout << " " << "INF" ; else cout << " " << D [ i ] [ j ] ; } cout << endl ; } } }<CODESPLIT>5.684102535247803<CODESPLIT>-1.1785222291946411<CODESPLIT>-1.0481574535369873<CODESPLIT>-1.1351685523986816<CODESPLIT>-1.2043873071670532<CODESPLIT>-1.2732244729995728
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include <algorithm> #include <iostream> #include <math.h> #include <stdio.h> #include <string> #include <sstream> #include <vector> #include <stack> #include <queue> #include <set> #include <map> #include <cmath> using namespace std ; typedef long long int ll ; ll d [ 100 ] [ 100 ] ; const ll INF = 1000000000000000 ; void init ( ) { for ( int i = 0 ; i < 100 ; i ++ ) { for ( int j = 0 ; j < 100 ; j ++ ) { d [ i ] [ j ] = INF ; } d [ i ] [ i ] = 0 ; } } int main ( ) { init ( ) ; int v , e ; cin > > v > > e ; for ( int i = 0 ; i < e ; i ++ ) { ll s , t , w ; cin > > s > > t > > w ; d [ s ] [ t ] = w ; } for ( int k = 0 ; k < v ; k ++ ) { for ( int i = 0 ; i < v ; i ++ ) { for ( int j = 0 ; j < v ; j ++ ) { d [ i ] [ j ] = min ( d [ i ] [ j ] , d [ i ] [ k ] + d [ k ] [ j ] ) ; } } } for ( int i = 0 ; i < v ; i ++ ) { if ( d [ i ] [ i ] < 0 ) { cout << "NEGATIVE CYCLE" << endl ; return 0 ; } } for ( int i = 0 ; i < v ; i ++ ) { for ( int j = 0 ; j < v ; j ++ ) { if ( j ! = 0 ) cout << " " ; if ( d [ i ] [ j ] > 1000000000000 ) { cout << "INF" ; } else { cout << d [ i ] [ j ] ; } } cout << endl ; } return 0 ; }<CODESPLIT>5.674278736114502<CODESPLIT>-1.1292098760604858<CODESPLIT>-1.0364160537719727<CODESPLIT>-1.162034034729004<CODESPLIT>-1.2203506231307983<CODESPLIT>-1.2727686166763306
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include<iostream> #include<vector> #include<string> #include<array> #include<algorithm> #include<list> #include<cmath> #include<iomanip> #include<queue> #include<functional> #include<climits> #include<iterator> using namespace std ; const double pi = 4 * atan ( 1.0 ) ; using cMatrixRepEdges = std :: vector < std :: vector < int > > ; using cShortestPathMatrix = std :: vector < std :: vector < int > > ; using cPredecessorMatrix = std :: vector < std :: vector < int > > ; pair < cShortestPathMatrix , cPredecessorMatrix > solve_by_FloydWarshall ( const cMatrixRepEdges & Edges ) { if ( Edges . empty ( ) ) return make_pair ( cShortestPathMatrix ( ) , cPredecessorMatrix ( ) ) ; const int VertexNum = Edges . size ( ) ; cShortestPathMatrix AnsDist = Edges ; cPredecessorMatrix AnsPath = Edges ; for ( int i = 0 ; i < VertexNum ; ++ i ) { for ( int j = 0 ; j < VertexNum ; ++ j ) { if ( i == j ) { AnsPath [ i ] [ j ] = - 1 ; AnsDist [ i ] [ j ] = 0 ; } else if ( AnsPath [ i ] [ j ] == INT_MAX ) { AnsPath [ i ] [ j ] = - 1 ; } else { AnsPath [ i ] [ j ] = i ; } } } for ( int i = 0 ; i < VertexNum ; ++ i ) { for ( int j = 0 ; j < VertexNum ; ++ j ) { for ( int k = 0 ; k < VertexNum ; ++ k ) { if ( AnsDist [ j ] [ i ] ! = INT_MAX && AnsDist [ i ] [ k ] ! = INT_MAX ) { if ( AnsDist [ j ] [ k ] > AnsDist [ j ] [ i ] + AnsDist [ i ] [ k ] ) { AnsDist [ j ] [ k ] = AnsDist [ j ] [ i ] + AnsDist [ i ] [ k ] ; AnsPath [ j ] [ k ] = AnsPath [ i ] [ k ] ; } } } } } for ( int i = 0 ; i < VertexNum ; ++ i ) { for ( int j = 0 ; j < VertexNum ; ++ j ) { for ( int k = 0 ; k < VertexNum ; ++ k ) { if ( Edges [ j ] [ k ] ! = INT_MAX && AnsDist [ i ] [ j ] ! = INT_MAX ) { if ( AnsDist [ i ] [ k ] > AnsDist [ i ] [ j ] + Edges [ j ] [ k ] ) { return make_pair ( cShortestPathMatrix ( ) , cPredecessorMatrix ( ) ) ; } } } } } return make_pair ( AnsDist , AnsPath ) ; } int main ( ) { int N , M ; cin > > N > > M ; cMatrixRepEdges Edges ( N , vector < int > ( N , INT_MAX ) ) ; for ( int i = 0 ; i < M ; ++ i ) { int u , v , w ; cin > > u > > v > > w ; Edges [ u ] [ v ] = w ; } auto ans = solve_by_FloydWarshall ( Edges ) ; if ( ans . first . size ( ) ! = Edges . size ( ) ) { cout << "NEGATIVE CYCLE" << endl ; } else { for ( const auto & dists : ans . first ) { string str ; for ( const auto & val : dists ) { if ( val ! = INT_MAX ) { str += to_string ( val ) ; } else { str += "INF" ; } str += " " ; } str . pop_back ( ) ; cout << str << "\n" ; } } return 0 ; }<CODESPLIT>5.6200666427612305<CODESPLIT>-0.7796919345855713<CODESPLIT>-0.9800578951835632<CODESPLIT>-1.2482638359069824<CODESPLIT>-1.270944595336914<CODESPLIT>-1.2792805433273315
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> #define r(i,n) for(int i=0;i<n;i++) #define INF 2000000000 using namespace std ; int main ( ) { int v , n ; cin > > v > > n ; long long a [ v ] [ v ] ; r ( i , v ) r ( j , v ) a [ i ] [ j ] = i == j ? 0 : INF ; r ( i , n ) { int x , y , w ; cin > > x > > y > > w ; a [ x ] [ y ] = w ; } r ( k , v ) r ( i , v ) r ( j , v ) if ( a [ i ] [ k ] ! = INF && a [ k ] [ j ] ! = INF ) a [ i ] [ j ] = min ( a [ i ] [ j ] , a [ i ] [ k ] + a [ k ] [ j ] ) ; r ( i , v ) if ( a [ i ] [ i ] < 0 ) { cout << "NEGATIVE CYCLE" << endl ; return 0 ; } r ( i , v ) { r ( j , v ) { if ( j ) cout << ' ' ; if ( a [ i ] [ j ] >= INF ) cout << "INF" ; else cout << a [ i ] [ j ] ; } cout << endl ; } }<CODESPLIT>5.677657127380371<CODESPLIT>-1.2195522785186768<CODESPLIT>-1.033972144126892<CODESPLIT>-1.116894006729126<CODESPLIT>-1.183440923690796<CODESPLIT>-1.256130576133728
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include<iostream> #include<cstdio> #include<cmath> #include<vector> #include<algorithm> #include<climits> using namespace std ; static const int MAX = 100 ; static const long long INFTY = ( 1LL << 32 ) ; int n ; long long d [ MAX ] [ MAX ] ; void floyd ( ) { for ( int k = 0 ; k < n ; k ++ ) { for ( int i = 0 ; i < n ; i ++ ) { if ( d [ i ] [ k ] == INFTY ) continue ; for ( int j = 0 ; j < n ; j ++ ) { if ( d [ k ] [ j ] == INFTY ) continue ; d [ i ] [ j ] = min ( d [ i ] [ j ] , d [ i ] [ k ] + d [ k ] [ j ] ) ; } } } } int main ( ) { int e , u , v , c ; cin > > n > > e ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { d [ i ] [ j ] = ( ( i == j ) ? 0 : INFTY ) ; } } for ( int i = 0 ; i < e ; i ++ ) { cin > > u > > v > > c ; d [ u ] [ v ] = c ; } floyd ( ) ; bool negative = false ; for ( int i = 0 ; i < n ; i ++ ) if ( d [ i ] [ i ] < 0 ) negative = true ; if ( negative ) { cout << "NEGATIVE CYCLE" << endl ; } else { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( j ) cout << " " ; if ( d [ i ] [ j ] == INFTY ) cout << "INF" ; else cout << d [ i ] [ j ] ; } cout << endl ; } } return 0 ; }<CODESPLIT>5.666773319244385<CODESPLIT>-1.1309560537338257<CODESPLIT>-1.0492879152297974<CODESPLIT>-1.1238987445831299<CODESPLIT>-1.2486308813095093<CODESPLIT>-1.3107653856277466
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include<bits/stdc++.h> using namespace std ; static const int MAX = 100 ; static const long long INF = ( 1LL << 32 ) ; int main ( ) { int e , u , v , c ; int n ; long long d [ MAX ] [ MAX ] ; scanf ( "%d %d" , & n , & e ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { d [ i ] [ j ] = ( ( i == j ) ? 0 : INF ) ; } } for ( int i = 0 ; i < e ; i ++ ) { scanf ( "%d %d %d" , & u , & v , & c ) ; d [ u ] [ v ] = c ; } for ( int k = 0 ; k < n ; k ++ ) { for ( int i = 0 ; i < n ; i ++ ) { if ( d [ i ] [ k ] == INF ) continue ; for ( int j = 0 ; j < n ; j ++ ) { if ( d [ k ] [ j ] == INF ) continue ; d [ i ] [ j ] = min ( d [ i ] [ j ] , d [ i ] [ k ] + d [ k ] [ j ] ) ; } } } int judge = 0 ; for ( int i = 0 ; i < n ; i ++ ) if ( d [ i ] [ i ] < 0 ) judge = 1 ; if ( judge ) printf ( "NEGATIVE CYCLE\n" ) ; else { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( j ) printf ( " " ) ; if ( d [ i ] [ j ] == INF ) printf ( "INF" ) ; else printf ( "%d" , d [ i ] [ j ] ) ; } printf ( "\n" ) ; } } return 0 ; }<CODESPLIT>5.67235803604126<CODESPLIT>-1.1390273571014404<CODESPLIT>-1.0583072900772095<CODESPLIT>-1.121626853942871<CODESPLIT>-1.2483960390090942<CODESPLIT>-1.2667133808135986
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> #define rep(i, n) for (int i = 0; i < (n); ++i) #define repr(i, n) for (int i = (n); i >= 0; --i) #define FOR(i, m, n) for (int i = (m); i < (n); ++i) #define FORR(i, m, n) for (int i = (m); i >= (n); --i) using namespace std ; typedef long long ll ; const ll mod = 1000000007 ; const ll mod2 = 998244353 ; const int MAX = 105 ; const ll INF = 10000000005 ; int n ; ll d [ MAX ] [ MAX ] ; void floyd ( ) { rep ( k , n ) { rep ( i , n ) { if ( d [ i ] [ k ] == INF ) continue ; rep ( j , n ) { if ( d [ k ] [ j ] == INF ) continue ; d [ i ] [ j ] = min ( d [ i ] [ j ] , d [ i ] [ k ] + d [ k ] [ j ] ) ; } } } } int main ( ) { int e , u , v , c ; cin > > n > > e ; rep ( i , n ) { rep ( j , n ) { d [ i ] [ j ] = INF ; if ( i == j ) d [ i ] [ i ] = 0 ; } } rep ( i , e ) { cin > > u > > v > > c ; d [ u ] [ v ] = c ; } floyd ( ) ; rep ( i , n ) { if ( d [ i ] [ i ] < 0 ) { cout << "NEGATIVE CYCLE" << endl ; return 0 ; } } rep ( i , n ) { rep ( j , n ) { if ( j ) cout << " " ; if ( d [ i ] [ j ] == INF ) cout << "INF" ; else cout << d [ i ] [ j ] ; } cout << endl ; } return 0 ; }<CODESPLIT>5.670162677764893<CODESPLIT>-1.0824544429779053<CODESPLIT>-1.0414814949035645<CODESPLIT>-1.142920970916748<CODESPLIT>-1.2507809400558472<CODESPLIT>-1.3029319047927856
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> using namespace std ; using ll = long long ; constexpr ll MOD = 1e9 + 7 ; constexpr ll INF = 1e18 ; int main ( ) { ll V , E ; cin > > V > > E ; vector < vector < ll > > G ( V , vector < ll > ( V , INF ) ) ; for ( ll i = 0 ; i < E ; i ++ ) { ll x , y , cost ; cin > > x > > y > > cost ; G [ x ] [ y ] = cost ; } for ( ll i = 0 ; i < V ; i ++ ) G [ i ] [ i ] = 0 ; for ( ll k = 0 ; k < V ; k ++ ) { for ( ll i = 0 ; i < V ; i ++ ) { for ( ll j = 0 ; j < V ; j ++ ) { if ( G [ i ] [ k ] ! = INF && G [ k ] [ j ] ! = INF ) G [ i ] [ j ] = min ( G [ i ] [ j ] , G [ i ] [ k ] + G [ k ] [ j ] ) ; } } } for ( ll i = 0 ; i < V ; i ++ ) { if ( G [ i ] [ i ] < 0 ) { cout << "NEGATIVE CYCLE" << endl ; return 0 ; } } for ( ll i = 0 ; i < V ; i ++ ) { for ( ll j = 0 ; j < V ; j ++ ) { if ( G [ i ] [ j ] == INF ) { cout << "INF" ; } else { cout << G [ i ] [ j ] ; } cout << ( j == V - 1 ? '\n' : ' ' ) ; } } }<CODESPLIT>5.689796447753906<CODESPLIT>-1.151328206062317<CODESPLIT>-1.0283584594726562<CODESPLIT>-1.1362615823745728<CODESPLIT>-1.223389744758606<CODESPLIT>-1.2574323415756226
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> #define rep(i, n) for(int i = 0; i < (n); i++) using namespace std ; using ll = long long ; using pii = pair < int , int > ; const ll INF = 1e18 ; int main ( ) { int v , e ; cin > > v > > e ; vector < vector < ll > > dp ( v , vector < ll > ( v , INF ) ) ; rep ( i , v ) dp [ i ] [ i ] = 0 ; rep ( i , e ) { int s , t , d ; cin > > s > > t > > d ; dp [ s ] [ t ] = d ; } rep ( i , v ) rep ( j , v ) rep ( k , v ) { if ( dp [ j ] [ i ] == INF || dp [ i ] [ k ] == INF ) continue ; dp [ j ] [ k ] = min ( dp [ j ] [ k ] , dp [ j ] [ i ] + dp [ i ] [ k ] ) ; } rep ( i , v ) { if ( dp [ i ] [ i ] < 0 ) { cout << "NEGATIVE CYCLE" << endl ; return 0 ; } } rep ( i , v ) rep ( j , v ) { if ( dp [ i ] [ j ] ! = INF ) cout << dp [ i ] [ j ] ; else cout << "INF" ; if ( j == v - 1 ) cout << endl ; else cout << " " ; } return 0 ; }<CODESPLIT>5.699904918670654<CODESPLIT>-1.1483542919158936<CODESPLIT>-1.0425128936767578<CODESPLIT>-1.1399122476577759<CODESPLIT>-1.2226186990737915<CODESPLIT>-1.2735949754714966
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> using namespace std ; using dou = long double ; string yes = "yes" ; string Yes = "Yes" ; string YES = "YES" ; string no = "no" ; string No = "No" ; string NO = "NO" ; template < class T > inline bool chmax ( T & a , T b ) { if ( a < b ) { a = b ; return true ; } return false ; } template < class T > inline bool chmin ( T & a , T b ) { if ( a > b ) { a = b ; return true ; } return false ; } #define rep(i, n)         for(int i = 0; i < (int)(n); i++) #define brep(n)           for(int bit=0;bit<(1<<n);bit++) #define erep(i,container) for (auto i : container) #define irep(i, n)        for(int i = n-1; i >= (int)0; i--) #define rrep(i,m,n) for(ll i = m; i < (ll)(n); i++) #define reprep(i,j,h,w) rep(i,h)rep(j,w) #define all(x) (x).begin(),(x).end() #define VEC(type,name,n) std::vector<type> name(n);rep(i,n)std::cin >> name[i]; #define pb push_back #define pf push_front #define query int qq;std::cin >> qq;rep(qqq,qq) #define lb lower_bound #define ub upper_bound #define fi first #define se second #define itn int #define mp make_pair #define sum(a) accumulate(all(a),0ll) #define keta fixed<<setprecision #define vvector(name,typ,m,n,a)vector<vector<typ> > name(m,vector<typ> (n,a)) #define vvvector(name,t,l,m,n,a) vector<vector<vector<t> > > name(l, vector<vector<t> >(m, vector<t>(n,a))); #define vvvvector(name,t,k,l,m,n,a) vector<vector<vector<vector<t> > > > name(k,vector<vector<vector<t> > >(l, vector<vector<t> >(m, vector<t>(n,a)) )); #define case std::cout <<"Case #" <<qqq+1<<": " #define res resize #define as assign #define ffor for(;;) #define ppri(a,b) std::cout << a<<" "<<b << std::endl #define pppri(a,b,c) std::cout << a<<" "<<b <<" "<< c<<std::endl #define aall(x,n) (x).begin(),(x).begin()+(n) #define ssum(a) accumulate(a,0ll)  #define gre(n) greater<n>() typedef long long ll ; typedef pair < int , int > P ; typedef pair < ll , ll > PL ; const int INF = 1000000000 ; const ll INF64 = 922337203685477580ll ; const ll MOD = 1000000007ll ; const dou pi = 3.141592653589793 ; std :: vector < vector < ll > > d ; void warshall_floyd ( int n ) { for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) for ( int k = 0 ; k < n ; k ++ ) d [ j ] [ k ] = min ( d [ j ] [ k ] , d [ j ] [ i ] + d [ i ] [ k ] ) ; } int main ( ) { int v , e ; std :: cin > > v > > e ; d . resize ( v ) ; rep ( i , v ) { d [ i ] . resize ( v ) ; } reprep ( i , j , v , v ) d [ i ] [ j ] = INF64 ; rep ( i , v ) d [ i ] [ i ] = 0 ; rep ( i , e ) { int a , b , c ; std :: cin > > a > > b > > c ; d [ a ] [ b ] = c ; } warshall_floyd ( v ) ; reprep ( i , j , v , v ) { if ( d [ i ] [ j ] + d [ j ] [ i ] < 0 ) { std :: cout << "NEGATIVE CYCLE" << std :: endl ; exit ( 0 ) ; } } rep ( i , v ) { rep ( j , v ) { if ( d [ i ] [ j ] <= INF64 / 10 ) std :: cout << d [ i ] [ j ] << ( ( j == v - 1 ) ? "" : " " ) ; else std :: cout << "INF" << ( ( j == v - 1 ) ? "" : " " ) ; } std :: cout << std :: endl ; } }<CODESPLIT>5.669846534729004<CODESPLIT>-0.9049574732780457<CODESPLIT>-1.0814576148986816<CODESPLIT>-1.2375375032424927<CODESPLIT>-1.2709217071533203<CODESPLIT>-1.2973145246505737
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include <iostream> #include <vector> #include <queue> using namespace std ; const long long INF = 1LL << 60 ; const int MAX_N = 310 ; int N , M ; vector < vector < long long > > dp ( MAX_N , vector < long long > ( MAX_N , INF ) ) ; void Warshall_Floyd_init ( ) { for ( int v = 0 ; v < MAX_N ; ++ v ) dp [ v ] [ v ] = 0 ; for ( int k = 0 ; k < N ; ++ k ) { for ( int i = 0 ; i < N ; ++ i ) { for ( int j = 0 ; j < N ; ++ j ) { dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k ] [ j ] ) ; } } } } int main ( ) { cin > > N > > M ; for ( int e = 0 ; e < M ; ++ e ) { int a , b ; long long w ; cin > > a > > b > > w ; dp [ a ] [ b ] = w ; } Warshall_Floyd_init ( ) ; bool exist_negative_cycle = false ; for ( int v = 0 ; v < N ; ++ v ) if ( dp [ v ] [ v ] < 0 ) exist_negative_cycle = true ; if ( exist_negative_cycle ) { cout << "NEGATIVE CYCLE" << endl ; } else { for ( int i = 0 ; i < N ; ++ i ) { for ( int j = 0 ; j < N ; ++ j ) { if ( j ) cout << " " ; if ( dp [ i ] [ j ] < INF / 2 ) cout << dp [ i ] [ j ] ; else cout << "INF" ; } cout << endl ; } } }<CODESPLIT>5.687487602233887<CODESPLIT>-1.1267218589782715<CODESPLIT>-1.0070865154266357<CODESPLIT>-1.141769528388977<CODESPLIT>-1.2221813201904297<CODESPLIT>-1.2598015069961548
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include <iostream> #include <algorithm> #include <vector> #include <climits> using namespace std ; static const int MAX = 100 ; static const long long INFTY = ( 1LL << 32 ) ; int n ; long long d [ MAX ] [ MAX ] ; void floyd ( ) { for ( int k = 0 ; k < n ; k ++ ) { for ( int i = 0 ; i < n ; i ++ ) { if ( d [ i ] [ k ] == INFTY ) { continue ; } for ( int j = 0 ; j < n ; j ++ ) { if ( d [ k ] [ j ] == INFTY ) { continue ; } d [ i ] [ j ] = min ( d [ i ] [ j ] , d [ i ] [ k ] + d [ k ] [ j ] ) ; } } } } int main ( void ) { int e , u , v , c ; cin > > n > > e ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { d [ i ] [ j ] = ( ( i == j ) ? 0 : INFTY ) ; } } for ( int i = 0 ; i < e ; i ++ ) { cin > > u > > v > > c ; d [ u ] [ v ] = c ; } bool negative = false ; floyd ( ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( d [ i ] [ i ] < 0 ) { negative = true ; } } if ( negative ) { cout << "NEGATIVE CYCLE" << endl ; } else { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( j > 0 ) { cout << " " ; } if ( d [ i ] [ j ] == INFTY ) { cout << "INF" ; } else { cout << d [ i ] [ j ] ; } } cout << endl ; } } return 0 ; }<CODESPLIT>5.670416355133057<CODESPLIT>-1.260269045829773<CODESPLIT>-1.0169148445129395<CODESPLIT>-1.098591923713684<CODESPLIT>-1.2068586349487305<CODESPLIT>-1.2537099123001099
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include <iostream> #include <list> #include <vector> #include <map> #include <set> #include <queue> #include <stack> #include <numeric> #include <algorithm> #include <cmath> #include <string> using namespace std ; typedef long long lli ; typedef vector < lli > vll ; typedef vector < bool > vbl ; typedef vector < vector < lli > > mat ; typedef vector < vector < bool > > matb ; typedef vector < string > vst ; typedef pair < lli , lli > pll ; typedef pair < double , double > pdd ; lli v , e ; mat m ; lli x , y , c ; const lli INF = 1000000000000 ; int main ( ) { cin > > v > > e ; m = mat ( v , vll ( v , INF ) ) ; for ( lli i = 0 ; i < v ; i ++ ) m [ i ] [ i ] = 0 ; for ( lli i = 0 ; i < e ; i ++ ) { cin > > x > > y > > c ; m [ x ] [ y ] = c ; } for ( lli i = 0 ; i < v ; i ++ ) for ( lli j = 0 ; j < v ; j ++ ) for ( lli k = 0 ; k < v ; k ++ ) { if ( m [ j ] [ i ] == INF || m [ i ] [ k ] == INF ) continue ; m [ j ] [ k ] = min ( m [ j ] [ k ] , m [ j ] [ i ] + m [ i ] [ k ] ) ; } for ( lli i = 0 ; i < v ; i ++ ) if ( m [ i ] [ i ] < 0 ) { cout << "NEGATIVE CYCLE" << endl ; return 0 ; } for ( lli i = 0 ; i < v ; i ++ ) { for ( lli j = 0 ; j < v ; ) { if ( m [ i ] [ j ] == INF ) cout << "INF" ; else cout << m [ i ] [ j ] ; if ( ++ j < v ) cout << " " ; else cout << endl ; } } return 0 ; }<CODESPLIT>5.65386438369751<CODESPLIT>-1.050944447517395<CODESPLIT>-0.961958110332489<CODESPLIT>-1.2126901149749756<CODESPLIT>-1.2021929025650024<CODESPLIT>-1.2122156620025635
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include <iostream> #include <vector> #include <algorithm> using namespace std ; const int INF = ( 2e9 ) ; int main ( ) { int V , E ; cin > > V > > E ; vector < vector < int > > D ( V , vector < int > ( V , INF ) ) ; for ( int i = 0 ; i < E ; ++ i ) { int s , t , d ; cin > > s > > t > > d ; D [ s ] [ t ] = d ; } for ( int i = 0 ; i < V ; ++ i ) D [ i ] [ i ] = 0 ; for ( int k = 0 ; k < V ; ++ k ) for ( int i = 0 ; i < V ; ++ i ) for ( int j = 0 ; j < V ; ++ j ) if ( D [ i ] [ k ] ! = INF && D [ k ] [ j ] ! = INF ) D [ i ] [ j ] = min ( D [ i ] [ j ] , D [ i ] [ k ] + D [ k ] [ j ] ) ; for ( int i = 0 ; i < V ; ++ i ) { if ( D [ i ] [ i ] < 0 ) { cout << "NEGATIVE CYCLE" << endl ; return 0 ; } } for ( int i = 0 ; i < V ; ++ i ) { for ( int j = 0 ; j < V ; ++ j ) { if ( D [ i ] [ j ] < INF ) cout << D [ i ] [ j ] ; else cout << "INF" ; if ( j < V - 1 ) cout << " " ; else cout << endl ; } } return 0 ; }<CODESPLIT>5.701704978942871<CODESPLIT>-1.110425353050232<CODESPLIT>-1.0399256944656372<CODESPLIT>-1.1359822750091553<CODESPLIT>-1.2070380449295044<CODESPLIT>-1.2678889036178589
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include<iostream> #include<algorithm> using namespace std ; #define MAX 100 #define INF 2e+11 int V , E ; long long M [ MAX ] [ MAX ] ; void search ( ) { for ( int k = 0 ; k < V ; k ++ ) { for ( int i = 0 ; i < V ; i ++ ) { if ( M [ i ] [ k ] == INF ) continue ; for ( int j = 0 ; j < V ; j ++ ) { if ( M [ k ] [ j ] == INF ) continue ; M [ i ] [ j ] = min ( M [ i ] [ j ] , M [ i ] [ k ] + M [ k ] [ j ] ) ; } } } } int negative ( int x ) { if ( M [ x ] [ x ] < 0 ) return 1 ; else return 0 ; } int main ( ) { int s , t , d , count = 0 ; ; cin > > V > > E ; for ( int i = 0 ; i < V ; i ++ ) { for ( int j = 0 ; j < V ; j ++ ) { if ( i == j ) M [ i ] [ j ] == 0 ; else M [ i ] [ j ] = INF ; } } for ( int i = 0 ; i < E ; i ++ ) { cin > > s > > t > > d ; M [ s ] [ t ] = d ; } search ( ) ; for ( int i = 0 ; i < V ; i ++ ) { negative ( i ) ; if ( negative ( i ) ! = 0 ) count += 1 ; } if ( count == 0 ) { for ( int i = 0 ; i < V ; i ++ ) { for ( int j = 0 ; j < V ; j ++ ) { if ( j > 0 ) cout << " " ; if ( M [ i ] [ j ] == INF ) cout << "INF" ; else cout << M [ i ] [ j ] ; } cout << endl ; } } else cout << "NEGATIVE CYCLE" << endl ; }<CODESPLIT>5.688313007354736<CODESPLIT>-1.1517305374145508<CODESPLIT>-1.0343222618103027<CODESPLIT>-1.1470646858215332<CODESPLIT>-1.2256728410720825<CODESPLIT>-1.2584582567214966
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> #define REP(i, n) for (int i = 0; i < n; i++) #define LL long long #define endl '\n' using namespace std ; static const int MAX = 100 ; static const int long long INFTY = ( 1LL << 32 ) ; int n ; LL d [ MAX ] [ MAX ] ; void floyd ( ) { for ( int k = 0 ; k < n ; k ++ ) { for ( int i = 0 ; i < n ; i ++ ) { if ( d [ i ] [ k ] == INFTY ) { continue ; } for ( int j = 0 ; j < n ; j ++ ) { if ( d [ k ] [ j ] == INFTY ) { continue ; } d [ i ] [ j ] = min ( d [ i ] [ j ] , d [ i ] [ k ] + d [ k ] [ j ] ) ; } } } } int main ( ) { cin . tie ( 0 ) ; ios :: sync_with_stdio ( false ) ; int e , u , v , c ; cin > > n > > e ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { d [ i ] [ j ] = ( ( i == j ) ? 0 : INFTY ) ; } } for ( int i = 0 ; i < e ; i ++ ) { cin > > u > > v > > c ; d [ u ] [ v ] = c ; } floyd ( ) ; bool negative = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( d [ i ] [ i ] < 0 ) { negative = true ; } } if ( negative ) { cout << "NEGATIVE CYCLE" << endl ; } else { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( j ) cout << " " ; if ( d [ i ] [ j ] == INFTY ) { cout << "INF" ; } else { cout << d [ i ] [ j ] ; } } cout << endl ; } } return 0 ; }<CODESPLIT>5.664635181427002<CODESPLIT>-1.2667268514633179<CODESPLIT>-1.0291869640350342<CODESPLIT>-1.0917495489120483<CODESPLIT>-1.2114355564117432<CODESPLIT>-1.2462478876113892
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include<iostream> #include<climits> using namespace std ; const long long MAX = LLONG_MAX > > 1 ; int main ( ) { int v = 0 , e = 0 ; long long dist [ 100 ] [ 100 ] = { 0 } ; cin > > v > > e ; for ( int i = 0 ; i < v ; i ++ ) { for ( int j = 0 ; j < v ; j ++ ) { dist [ i ] [ j ] = MAX ; } } for ( int i = 0 ; i < v ; i ++ ) { dist [ i ] [ i ] = 0 ; } for ( int i = 0 ; i < e ; i ++ ) { int s = 0 , t = 0 , d = 0 ; cin > > s > > t > > d ; dist [ s ] [ t ] = d ; } for ( int i = 0 ; i < v ; i ++ ) { for ( int j = 0 ; j < v ; j ++ ) { for ( int k = 0 ; k < v ; k ++ ) { if ( dist [ j ] [ k ] > dist [ j ] [ i ] + dist [ i ] [ k ] && dist [ j ] [ i ] ! = MAX && dist [ i ] [ k ] ! = MAX ) { dist [ j ] [ k ] = dist [ j ] [ i ] + dist [ i ] [ k ] ; } } } } for ( int i = 0 ; i < v ; i ++ ) { if ( dist [ i ] [ i ] < 0 ) { cout << "NEGATIVE CYCLE" << endl ; return 0 ; } } for ( int i = 0 ; i < v ; i ++ ) { for ( int j = 0 ; j < v ; j ++ ) { if ( dist [ i ] [ j ] == MAX ) { cout << "INF" ; } else { cout << dist [ i ] [ j ] ; } cout << ( j == v - 1 ? "\n" : " " ) ; } } return 0 ; }<CODESPLIT>5.658403396606445<CODESPLIT>-1.154653549194336<CODESPLIT>-1.0976649522781372<CODESPLIT>-1.153079628944397<CODESPLIT>-1.230021357536316<CODESPLIT>-1.257497787475586
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include<bits/stdc++.h> #define REP(i,n) for(long long i=0;i<n;++i) #define FOR(i,a,b) for(long long i=a;i<b;++i) using namespace std ; int n ; long long d [ 100 ] [ 100 ] ; const long long INF = 1LL << 32 ; void floyd ( ) { REP ( k , n ) { REP ( i , n ) { if ( d [ i ] [ k ] == INF ) continue ; REP ( j , n ) { if ( d [ k ] [ j ] == INF ) continue ; d [ i ] [ j ] = min ( d [ i ] [ j ] , d [ i ] [ k ] + d [ k ] [ j ] ) ; } } } } int main ( ) { int e , u , v , c ; scanf ( "%d%d" , & n , & e ) ; REP ( i , n ) { REP ( j , n ) { d [ i ] [ j ] = ( i == j ? 0 : INF ) ; } } REP ( i , e ) { scanf ( "%d%d%d" , & u , & v , & c ) ; d [ u ] [ v ] = c ; } floyd ( ) ; bool flag = false ; REP ( i , n ) if ( d [ i ] [ i ] < 0 ) flag = true ; if ( flag ) { printf ( "NEGATIVE CYCLE\n" ) ; } else { REP ( i , n ) { REP ( j , n ) { if ( j ) printf ( " " ) ; if ( d [ i ] [ j ] == INF ) printf ( "INF" ) ; else printf ( "%d" , d [ i ] [ j ] ) ; } puts ( "" ) ; } } return 0 ; }<CODESPLIT>5.668547630310059<CODESPLIT>-1.1904690265655518<CODESPLIT>-1.029067873954773<CODESPLIT>-1.1184334754943848<CODESPLIT>-1.2078815698623657<CODESPLIT>-1.2694345712661743
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include <algorithm> #include <iostream> #include <vector> using namespace std ; template < typename T > struct WarshallFloyd { const T INF = numeric_limits < T > :: max ( ) ; int n ; vector < vector < T > > dp ; WarshallFloyd ( int n ) : n ( n ) , dp ( n , vector < T > ( n , INF ) ) { for ( int i = 0 ; i < n ; i ++ ) dp [ i ] [ i ] = 0 ; } void relax ( int k ) { for ( int i = 0 ; i < n ; i ++ ) if ( dp [ i ] [ k ] ! = INF ) for ( int j = 0 ; j < n ; j ++ ) if ( dp [ k ] [ j ] ! = INF ) dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k ] [ j ] ) ; } bool build ( ) { for ( int k = 0 ; k < n ; k ++ ) relax ( k ) ; return ! has_negative_cycle ( ) ; } void add_edge ( int u , int v , T cost ) { dp [ u ] [ v ] = min ( dp [ u ] [ v ] , cost ) ; for ( int k : { u , v } ) relax ( k ) ; } bool has_negative_cycle ( ) { for ( int i = 0 ; i < n ; i ++ ) if ( dp [ i ] [ i ] < 0 ) return true ; return false ; } friend ostream & operator << ( ostream & os , WarshallFloyd < T > & wf ) { for ( int i = 0 ; i < wf . n ; i ++ ) for ( int j = 0 ; j < wf . n ; j ++ ) { if ( wf . dp [ i ] [ j ] == wf . INF ) os << "INF" ; else os << wf . dp [ i ] [ j ] ; os << " \n" [ j == wf . n - 1 ] ; } return os ; } } ; int main ( ) { int n , m ; cin > > n > > m ; WarshallFloyd < long long > wf ( n ) ; while ( m -- ) { int a , b , c ; cin > > a > > b > > c ; wf . add_edge ( a , b , c ) ; } if ( wf . has_negative_cycle ( ) ) return ! ( cout << "NEGATIVE CYCLE" << endl ) ; cout << wf ; return 0 ; }<CODESPLIT>5.6760077476501465<CODESPLIT>-1.1848652362823486<CODESPLIT>-1.011178731918335<CODESPLIT>-1.1024608612060547<CODESPLIT>-1.250191569328308<CODESPLIT>-1.2730004787445068
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include <iostream> #include <vector> #include <queue> #include <climits> #include <algorithm> int min ( int x , int y ) { return x > y ? y : x ; } int main ( ) { int n , m , r ; std :: cin > > n > > m ; int ** D = new int * [ n ] ; for ( int i = 0 ; i < n ; i ++ ) D [ i ] = new int [ n ] ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) D [ i ] [ j ] = ( i == j ) ? 0 : INT_MAX ; } for ( int k = 0 ; k < m ; k ++ ) { int i , j , w ; std :: cin > > i > > j > > w ; D [ i ] [ j ] = min ( D [ i ] [ j ] , w ) ; } for ( int k = 0 ; k < n ; k ++ ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( D [ i ] [ k ] == INT_MAX || D [ k ] [ j ] == INT_MAX ) continue ; if ( D [ i ] [ j ] > D [ i ] [ k ] + D [ k ] [ j ] ) D [ i ] [ j ] = D [ i ] [ k ] + D [ k ] [ j ] ; } } } bool negative_cycle = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( D [ i ] [ i ] < 0 ) { negative_cycle = true ; break ; } } if ( negative_cycle ) { std :: cout << "NEGATIVE CYCLE" << std :: endl ; } else { for ( int i = 0 ; i < n ; i ++ ) { if ( D [ i ] [ 0 ] < INT_MAX ) std :: cout << D [ i ] [ 0 ] ; else std :: cout << "INF" ; for ( int j = 1 ; j < n ; j ++ ) { if ( D [ i ] [ j ] < INT_MAX ) std :: cout << " " << D [ i ] [ j ] ; else std :: cout << " INF" ; } std :: cout << std :: endl ; } } return 0 ; }<CODESPLIT>5.693892002105713<CODESPLIT>-1.042455792427063<CODESPLIT>-1.0552490949630737<CODESPLIT>-1.1636780500411987<CODESPLIT>-1.237849235534668<CODESPLIT>-1.2803547382354736
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include <cstdio> #include <cstring> #include <algorithm> using namespace std ; typedef pair < int , int > pii ; const int MAX_V = 100 , MAX_E = 9900 ; const long long INF = 0x3f3f3f3f3f3f3f3fLL ; long long G [ MAX_V ] [ MAX_V ] ; void init_G ( int V ) { for ( int u = 0 ; u < V ; ++ u ) for ( int v = 0 ; v < V ; ++ v ) { if ( u ! = v ) G [ u ] [ v ] = INF ; } } void add_edge ( int u , int v , int c ) { G [ u ] [ v ] = min ( G [ u ] [ v ] , ( long long ) c ) ; } bool floyd_warshall ( int V ) { for ( int w = 0 ; w < V ; ++ w ) { for ( int u = 0 ; u < V ; ++ u ) for ( int v = 0 ; v < V ; ++ v ) { if ( G [ u ] [ w ] == INF || G [ w ] [ v ] == INF ) continue ; G [ u ] [ v ] = min ( G [ u ] [ v ] , G [ u ] [ w ] + G [ w ] [ v ] ) ; } } for ( int v = 0 ; v < V ; ++ v ) if ( G [ v ] [ v ] < 0 ) return true ; return false ; } const char NEG_CYCLE [ ] = "NEGATIVE CYCLE" ; int main ( ) { int V , E ; scanf ( "%d%d" , & V , & E ) ; init_G ( V ) ; for ( int i = 0 ; i < E ; ++ i ) { int s , t , d ; scanf ( "%d%d%d" , & s , & t , & d ) ; add_edge ( s , t , d ) ; } if ( floyd_warshall ( V ) ) puts ( NEG_CYCLE ) ; else { for ( int u = 0 ; u < V ; ++ u ) { for ( int v = 0 ; v < V ; ++ v ) { if ( G [ u ] [ v ] == INF ) printf ( "INF%c" , " \n" [ v == V - 1 ] ) ; else printf ( "%lld%c" , G [ u ] [ v ] , " \n" [ v == V - 1 ] ) ; } } } }<CODESPLIT>5.578817844390869<CODESPLIT>-0.737285315990448<CODESPLIT>-1.083361268043518<CODESPLIT>-1.2570269107818604<CODESPLIT>-1.277804970741272<CODESPLIT>-1.2868068218231201
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> using namespace std ; typedef long long ll ; typedef pair < int , int > pii ; const ll LINF = 1LL << 50 ; const int NIL = - 1 ; const int MAX = 10000 ; const int mod = 1000000007 ; const double pi = 3.141592653589 ; int main ( ) { int V , E ; cin > > V > > E ; vector < vector < ll > > G ( V , vector < ll > ( V , LINF ) ) ; for ( int i = 0 ; i < E ; i ++ ) { ll u , v , w ; cin > > u > > v > > w ; G [ u ] [ v ] = w ; } for ( int i = 0 ; i < V ; i ++ ) G [ i ] [ i ] = 0 ; for ( int k = 0 ; k < V ; k ++ ) { for ( int i = 0 ; i < V ; i ++ ) { if ( G [ i ] [ k ] == LINF ) continue ; for ( int j = 0 ; j < V ; j ++ ) { if ( G [ k ] [ j ] == LINF ) continue ; G [ i ] [ j ] = min ( G [ i ] [ j ] , G [ i ] [ k ] + G [ k ] [ j ] ) ; } } } bool negative = false ; for ( int i = 0 ; i < V ; i ++ ) if ( G [ i ] [ i ] < 0 ) negative = true ; if ( negative ) cout << "NEGATIVE CYCLE" << '\n' ; else { for ( int i = 0 ; i < V ; i ++ ) { for ( int j = 0 ; j < V ; j ++ ) { if ( j ) cout << ' ' ; if ( G [ i ] [ j ] == LINF ) cout << "INF" ; else cout << G [ i ] [ j ] ; } cout << '\n' ; } } }<CODESPLIT>5.697317123413086<CODESPLIT>-1.0747061967849731<CODESPLIT>-1.0351547002792358<CODESPLIT>-1.1586227416992188<CODESPLIT>-1.2520745992660522<CODESPLIT>-1.2870932817459106
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include<bits/stdc++.h> #define mm 1e18 using namespace std ; long long minn ( long long a , long long b ) { if ( a < b ) return a ; else return b ; } int main ( ) { int n , m , x , y , z ; long long f [ 105 ] [ 105 ] ; cin > > n > > m ; for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) f [ i ] [ j ] = mm ; while ( m -- ) { cin > > x > > y > > z ; f [ x ] [ y ] = z ; } for ( int i = 0 ; i < n ; i ++ ) f [ i ] [ i ] = 0 ; for ( int k = 0 ; k < n ; k ++ ) for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( f [ i ] [ k ] ! = mm && f [ k ] [ j ] ! = mm ) f [ i ] [ j ] = minn ( f [ i ] [ j ] , f [ i ] [ k ] + f [ k ] [ j ] ) ; int ok = 1 ; for ( int i = 0 ; i < n ; i ++ ) if ( f [ i ] [ i ] < 0 ) { ok = 0 ; break ; } if ( ok ) { for ( int i = 0 ; i < n ; i ++ ) { if ( f [ i ] [ 0 ] == mm ) cout << "INF" ; else cout << f [ i ] [ 0 ] ; for ( int j = 1 ; j < n ; j ++ ) if ( f [ i ] [ j ] == mm ) cout << " INF" ; else cout << ' ' << f [ i ] [ j ] ; cout << '\n' ; } } else cout << "NEGATIVE CYCLE" << '\n' ; return 0 ; }<CODESPLIT>5.682196617126465<CODESPLIT>-1.1599632501602173<CODESPLIT>-1.0629383325576782<CODESPLIT>-1.1180000305175781<CODESPLIT>-1.2272640466690063<CODESPLIT>-1.2755030393600464
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include <stdio.h> #include <vector> #include <algorithm> #include <stack> #define INFINITY 2000000000 using namespace std ; int main ( ) { int V , E , from , to , dist ; scanf ( "%d %d" , & V , & E ) ; long long int table [ V ] [ V ] ; for ( int i = 0 ; i < V ; i ++ ) { for ( int k = 0 ; k < V ; k ++ ) { if ( i ! = k ) { table [ i ] [ k ] = INFINITY ; } else { table [ i ] [ k ] = 0 ; } } } for ( int i = 0 ; i < E ; i ++ ) { scanf ( "%d %d %d" , & from , & to , & dist ) ; table [ from ] [ to ] = dist ; } for ( int k = 0 ; k < V ; k ++ ) { for ( int i = 0 ; i < V ; i ++ ) { if ( table [ i ] [ k ] == INFINITY ) continue ; for ( int j = 0 ; j < V ; j ++ ) { if ( table [ k ] [ j ] == INFINITY ) continue ; table [ i ] [ j ] = min ( table [ i ] [ j ] , table [ i ] [ k ] + table [ k ] [ j ] ) ; } } } bool FLG = true ; for ( int i = 0 ; i < V ; i ++ ) { if ( table [ i ] [ i ] < 0 ) { FLG = false ; break ; } } if ( ! FLG ) printf ( "NEGATIVE CYCLE\n" ) ; else { for ( int i = 0 ; i < V ; i ++ ) { if ( table [ i ] [ 0 ] == INFINITY ) printf ( "INF" ) ; else { printf ( "%lld" , table [ i ] [ 0 ] ) ; } for ( int k = 1 ; k < V ; k ++ ) { if ( table [ i ] [ k ] == INFINITY ) printf ( " INF" ) ; else { printf ( " %lld" , table [ i ] [ k ] ) ; } } printf ( "\n" ) ; } } return 0 ; }<CODESPLIT>5.658968448638916<CODESPLIT>-1.046523928642273<CODESPLIT>-1.0500915050506592<CODESPLIT>-1.1240825653076172<CODESPLIT>-1.2606302499771118<CODESPLIT>-1.3042434453964233
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include<bits/stdc++.h> using namespace std ; typedef long long int lli ; int main ( int argc , char * argv [ ] ) { int n , m ; cin > > n > > m ; vector < vector < lli > > g ( n , vector < lli > ( n , 1LL << 40 ) ) ; int from , to , cost ; for ( int i = 0 ; i < n ; i ++ ) { g [ i ] [ i ] = 0 ; } for ( int i = 0 ; i < m ; i ++ ) { cin > > from > > to > > cost ; g [ from ] [ to ] = cost ; } bool neg_cycle = false ; for ( int k = 0 ; k < n ; k ++ ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( g [ i ] [ j ] == 1LL << 40 && ( g [ i ] [ k ] == 1LL << 40 || g [ k ] [ j ] == 1LL << 40 ) ) continue ; g [ i ] [ j ] = min ( g [ i ] [ j ] , g [ i ] [ k ] + g [ k ] [ j ] ) ; } } } for ( int i = 0 ; i < n ; i ++ ) { if ( g [ i ] [ i ] < 0 ) neg_cycle = true ; } if ( neg_cycle ) { std :: cout << "NEGATIVE CYCLE" << std :: endl ; return 0 ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n - 1 ; j ++ ) { if ( g [ i ] [ j ] >= 1LL << 40 ) std :: cout << "INF " ; else std :: cout << g [ i ] [ j ] << " " ; } if ( g [ i ] [ n - 1 ] >= 1LL << 40 ) std :: cout << "INF" << std :: endl ; else std :: cout << g [ i ] [ n - 1 ] << std :: endl ; } return 0 ; }<CODESPLIT>5.696919918060303<CODESPLIT>-1.1568320989608765<CODESPLIT>-1.0284438133239746<CODESPLIT>-1.1372601985931396<CODESPLIT>-1.2285367250442505<CODESPLIT>-1.267591118812561
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include<iostream> #include<sstream> #include<algorithm> #include<climits> #include<cmath> #include<cstdio> #include<cstdlib> #include<ctime> #include<cfloat> #include<functional> #include<map> #include<string> #include<cstring> #include<vector> #include<queue> #include<stack> #include<deque> #include<set> #include<bitset> #include<list> #include<numeric> #include<complex> using namespace std ; typedef long long ll ; typedef unsigned long long ull ; typedef pair < int , int > i_i ; typedef pair < long long , int > ll_i ; typedef pair < double , int > d_i ; typedef pair < long long , long long > ll_ll ; typedef pair < double , double > d_d ; typedef vector < int > vint ; typedef vector < char > vchar ; #define PI 3.141592653589793238462643383279 #define intinf 2000000014 #define longinf 2000000000000000014LL #define mod 1000000007LL #define rep(i, n) for(i = 0;i < n;++i) #define rep1(i, n) for(i = 1;i < n;++i) #define rep2d(i, j, n) for(i = 0;i < n;++i)for(j = i + 1;j < n;++j) #define per(i, n) for(i = n - 1;i > -1;--i) #define int(x) int x; scanf("%d",&x) #define int2(x, y) int x, y; scanf("%d%d",&x, &y) #define int3(x, y, z) int x, y, z; scanf("%d%d%d",&x, &y, &z) #define sc(x) cin >> x #define sc2(x, y) cin >> x >> y #define sc3(x, y, z) cin >> x >> y >> z #define scn(n, a) rep(i, n)cin >> a[i] #define sc2n(n, a, b) rep(i, n)cin >> a[i] >> b[i] #define pri(x) cout << x << "\n" #define pri2(x, y) cout << x << " " << y << "\n" #define pri3(x, y, z) cout << x << " " << y << " " << z << "\n" #define pb push_back #define mp make_pair #define all(a) (a).begin(),(a).end() #define kabe puts("---------------------------") #define kara puts("") #define debug(x) cout << " --- " << x << "\n" #define debug2(x, y) cout << " --- " << x << " " << y << "\n" #define debug3(x, y, z) cout << " --- " << x << " " << y << " " << z << "\n" #define debugn(i, n, a) rep(i, n)cout << " --- " << a[i] << "\n"; #define debugin(i, n, a) rep(i, n)printf(" --- %10d\n", a[i]) #define debugi2n(i, n, a, b) rep(i, n)printf(" --- %10d %10d\n", a[i], b[i]) #define debugiin(i, n, a) rep(i, n)printf(" --- %10d %10d\n", a[i].first, a[i].second) #define X first #define Y second #define eps 0.0001 #define prid(x) printf("%.15lf\n", x) ll d [ 100 ] [ 100 ] ; bool warshallfloyd ( int v ) { int i , j , k ; rep ( k , v ) rep ( i , v ) rep ( j , v ) if ( d [ i ] [ k ] ! = longinf && d [ k ] [ j ] ! = longinf && d [ i ] [ j ] > d [ i ] [ k ] + d [ k ] [ j ] ) d [ i ] [ j ] = d [ i ] [ k ] + d [ k ] [ j ] ; rep ( i , v ) if ( d [ i ] [ i ] < 0 ) return false ; return true ; } signed main ( void ) { int i , j , tmp , tmp2 ; for ( int testcase = 0 ; ; testcase ++ ) { int2 ( v , e ) ; rep ( i , v ) rep ( j , v ) ( i == j ) ? d [ i ] [ j ] = 0LL : d [ i ] [ j ] = longinf ; rep ( i , e ) { int3 ( s , t , dd ) ; d [ s ] [ t ] = dd ; } if ( warshallfloyd ( v ) ) { rep ( i , v ) { if ( d [ i ] [ 0 ] >= longinf ) cout << "INF" ; else cout << d [ i ] [ 0 ] ; rep1 ( j , v ) { if ( d [ i ] [ j ] >= longinf ) cout << " INF" ; else cout << " " << d [ i ] [ j ] ; } kara ; } } else pri ( "NEGATIVE CYCLE" ) ; } return 0 ; }<CODESPLIT>5.632606029510498<CODESPLIT>-0.9272056818008423<CODESPLIT>-0.9985862374305725<CODESPLIT>-1.2409368753433228<CODESPLIT>-1.2416419982910156<CODESPLIT>-1.2792751789093018
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include<iostream> #include<algorithm> #include<vector> #include<climits> using namespace std ; static const int MAX = 100 ; static const long long INFTY = ( 1LL << 32 ) ; int n ; long long d [ MAX ] [ MAX ] ; void floyd ( ) { for ( int k = 0 ; k < n ; k ++ ) { for ( int i = 0 ; i < n ; i ++ ) { if ( d [ i ] [ k ] == INFTY ) { continue ; } for ( int j = 0 ; j < n ; j ++ ) { if ( d [ k ] [ j ] == INFTY ) { continue ; } d [ i ] [ j ] = min ( d [ i ] [ j ] , d [ i ] [ k ] + d [ k ] [ j ] ) ; } } } } int main ( ) { int e , u , v , c ; cin > > n > > e ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { d [ i ] [ j ] = ( ( i == j ) ? 0 : INFTY ) ; } } for ( int i = 0 ; i < e ; i ++ ) { cin > > u > > v > > c ; d [ u ] [ v ] = c ; } floyd ( ) ; bool negative = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( d [ i ] [ i ] < 0 ) { negative = true ; } } if ( negative ) { cout << "NEGATIVE CYCLE" << endl ; } else { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( j ) cout << ' ' ; if ( d [ i ] [ j ] == INFTY ) { cout << "INF" ; } else { cout << d [ i ] [ j ] ; } } cout << endl ; } } return 0 ; }<CODESPLIT>5.673098564147949<CODESPLIT>-1.2533305883407593<CODESPLIT>-1.0195438861846924<CODESPLIT>-1.0990172624588013<CODESPLIT>-1.2077434062957764<CODESPLIT>-1.257354497909546
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> using namespace std ; #define FOR(i,a,b) for(int i=(int)(a);i<(int)(b);i++) #define RFOR(i,a,b) for(int i=(int)(b)-1;i>=(int)(a);i--) #define REP(i,n) FOR(i,0,n) #define RREP(i,n) RFOR(i,0,n) #define LL long long #define INF INT_MAX/3 const double EPS = 1e-14 ; const double PI = acos ( - 1.0 ) ; class AllPairsGraph { private : int vertex ; public : std :: vector < std :: vector < int > > prev ; std :: vector < std :: vector < long long > > dist ; long long inf = LLONG_MAX / 3 ; AllPairsGraph ( int v ) ; virtual void push ( int from , int to , int cost ) = 0 ; bool warshall_floyed ( ) ; std :: vector < std :: vector < long long > > get_dist ( ) ; std :: vector < int > get_path ( int s , int d ) ; } ; AllPairsGraph :: AllPairsGraph ( int v ) { vertex = v ; dist . resize ( vertex ) ; prev . resize ( vertex ) ; for ( int i = 0 ; i < vertex ; ++ i ) { dist [ i ] . resize ( vertex ) ; prev [ i ] . resize ( vertex ) ; for ( int j = 0 ; j < vertex ; ++ j ) { dist [ i ] [ j ] = inf ; if ( i == j ) dist [ i ] [ j ] = 0 ; prev [ i ] [ j ] = - 1 ; } } } bool AllPairsGraph :: warshall_floyed ( ) { bool has_neg_cycle = false ; for ( int j = 0 ; j < vertex ; ++ j ) { for ( int i = 0 ; i < vertex ; ++ i ) { for ( int k = 0 ; k < vertex ; ++ k ) { if ( dist [ i ] [ j ] ! = inf && dist [ j ] [ k ] ! = inf && dist [ i ] [ j ] + dist [ j ] [ k ] < dist [ i ] [ k ] ) { dist [ i ] [ k ] = dist [ i ] [ j ] + dist [ j ] [ k ] ; prev [ i ] [ k ] = prev [ j ] [ k ] ; } } } } for ( int i = 0 ; i < vertex ; ++ i ) { if ( dist [ i ] [ i ] < 0 ) has_neg_cycle = true ; } return has_neg_cycle ; } std :: vector < std :: vector < long long > > AllPairsGraph :: get_dist ( ) { return dist ; } std :: vector < int > AllPairsGraph :: get_path ( int s , int d ) { std :: vector < int > path ; int v = d ; while ( v ! = s ) { path . push_back ( v ) ; v = prev [ s ] [ v ] ; if ( v == - 1 ) { path . clear ( ) ; return path ; } } path . push_back ( v ) ; std :: reverse ( path . begin ( ) , path . end ( ) ) ; return path ; } class AllPairsDirectedGraph : public AllPairsGraph { using AllPairsGraph :: AllPairsGraph ; public : void push ( int from , int to , int cost ) { dist [ from ] [ to ] = cost ; prev [ from ] [ to ] = from ; } } ; class AllPairsUndirectedGraph : public AllPairsGraph { using AllPairsGraph :: AllPairsGraph ; public : void push ( int from , int to , int cost ) { dist [ from ] [ to ] = cost ; prev [ from ] [ to ] = from ; dist [ to ] [ from ] = cost ; prev [ to ] [ from ] = to ; } } ; int main ( ) { int v ; int e ; scanf ( "%d %d" , & v , & e ) ; AllPairsDirectedGraph g = AllPairsDirectedGraph ( v ) ; int from , to , cost ; for ( int i = 0 ; i < e ; i ++ ) { scanf ( "%d %d %d" , & from , & to , & cost ) ; g . push ( from , to , cost ) ; } bool flag = g . warshall_floyed ( ) ; if ( flag ) printf ( "NEGATIVE CYCLE\n" ) ; else { std :: vector < std :: vector < long long > > dist = g . get_dist ( ) ; for ( int i = 0 ; i < v ; ++ i ) { for ( int j = 0 ; j < v ; ++ j ) { if ( dist [ i ] [ j ] ! = g . inf ) printf ( "%lld" , dist [ i ] [ j ] ) ; else printf ( "INF" ) ; printf ( "%s" , j == v - 1 ? "\n" : " " ) ; } } } }<CODESPLIT>5.684286594390869<CODESPLIT>-0.963492214679718<CODESPLIT>-1.0438148975372314<CODESPLIT>-1.2109694480895996<CODESPLIT>-1.2951130867004395<CODESPLIT>-1.2682849168777466
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> using namespace std ; typedef long long ll ; ll dp [ 101 ] [ 101 ] ; ll n , m ; ll g [ 101 ] [ 101 ] ; int main ( ) { for ( ll i = 0 ; i < 101 ; i ++ ) for ( ll j = 0 ; j < 101 ; j ++ ) if ( i ! = j ) dp [ i ] [ j ] = 1e15 ; cin > > n > > m ; for ( ll i = 0 ; i < m ; i ++ ) { ll x , y , w ; cin > > x > > y > > w ; g [ x ] [ y ] = w ; dp [ x ] [ y ] = w ; } for ( int k = 0 ; k < n ; k ++ ) for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k ] [ j ] ) ; bool nc = 0 ; for ( int k = 0 ; k < n ; k ++ ) for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) if ( dp [ i ] [ k ] + dp [ k ] [ j ] < dp [ i ] [ j ] ) { nc = 1 ; break ; } if ( nc ) cout << "NEGATIVE CYCLE\n" ; else for ( int i = 0 ; i < n ; i ++ ) for ( int j = 0 ; j < n ; j ++ ) { if ( dp [ i ] [ j ] >= 1e13 ) cout << "INF" ; else cout << dp [ i ] [ j ] ; if ( j == n - 1 ) cout << endl ; else cout << " " ; } }<CODESPLIT>5.676233768463135<CODESPLIT>-1.2640348672866821<CODESPLIT>-1.0251203775405884<CODESPLIT>-1.1049444675445557<CODESPLIT>-1.2079941034317017<CODESPLIT>-1.2340489625930786
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include<bits/stdc++.h> using namespace std ; const long long INF = 1LL << 60 ; int main ( ) { int V , E ; cin > > V > > E ; vector < vector < long long > > dist ( V , vector < long long > ( V , INF ) ) ; for ( int i = 0 ; i < E ; i ++ ) { long long s , t , d ; cin > > s > > t > > d ; dist [ s ] [ t ] = d ; } for ( int i = 0 ; i < V ; i ++ ) { dist [ i ] [ i ] = 0 ; } bool mc = false ; for ( int k = 0 ; k < V ; k ++ ) { for ( int i = 0 ; i < V ; i ++ ) { for ( int j = 0 ; j < V ; j ++ ) { if ( dist [ i ] [ k ] ! = INF && dist [ k ] [ j ] ! = INF ) dist [ i ] [ j ] = min ( dist [ i ] [ j ] , dist [ i ] [ k ] + dist [ k ] [ j ] ) ; } } } for ( int i = 0 ; i < V ; i ++ ) { if ( dist [ i ] [ i ] < 0 ) mc = true ; } if ( mc ) cout << "NEGATIVE CYCLE" << endl ; else { for ( int i = 0 ; i < V ; i ++ ) { for ( int j = 0 ; j < V ; j ++ ) { if ( dist [ i ] [ j ] == INF ) cout << "INF" ; else cout << dist [ i ] [ j ] ; if ( j == V - 1 ) cout << endl ; else cout << " " ; } } } }<CODESPLIT>5.6866936683654785<CODESPLIT>-1.120751976966858<CODESPLIT>-1.0483382940292358<CODESPLIT>-1.1461751461029053<CODESPLIT>-1.2358390092849731<CODESPLIT>-1.2712372541427612
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> #define INF 10e15 #define rep(i, a) for (int i = 0; i < (a); i++) using namespace std ; int main ( ) { long long int dist [ 100 ] [ 100 ] ; long long int V , E ; cin > > V > > E ; long long int s , t , d ; long long int i , j , k ; for ( i = 0 ; i < V ; i ++ ) { for ( j = 0 ; j < V ; j ++ ) { if ( i == j ) { dist [ i ] [ j ] = 0 ; } else { dist [ i ] [ j ] = INF ; } } } for ( i = 0 ; i < E ; i ++ ) { cin > > s > > t > > d ; dist [ s ] [ t ] = d ; } for ( k = 0 ; k < V ; k ++ ) { for ( i = 0 ; i < V ; i ++ ) { for ( j = 0 ; j < V ; j ++ ) { if ( dist [ i ] [ k ] ! = INF && dist [ k ] [ j ] ! = INF ) { dist [ i ] [ j ] = min ( dist [ i ] [ j ] , dist [ i ] [ k ] + dist [ k ] [ j ] ) ; } if ( i == j && dist [ i ] [ j ] < 0 ) { cout << "NEGATIVE CYCLE" << endl ; return 0 ; } } } } for ( i = 0 ; i < V ; i ++ ) { for ( j = 0 ; j < V ; j ++ ) { if ( j ) cout << " " ; if ( dist [ i ] [ j ] == INF ) cout << "INF" ; else cout << dist [ i ] [ j ] ; } cout << endl ; } }<CODESPLIT>5.687820911407471<CODESPLIT>-1.1741007566452026<CODESPLIT>-1.0569851398468018<CODESPLIT>-1.1428112983703613<CODESPLIT>-1.208667516708374<CODESPLIT>-1.2594720125198364
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> #define endl "\n" #define rep(i,n) for(int i=0;i<int(n);i++) #define e_b emplace_back #define sz(x) ((int)(x).size()) #define all(x) (x).begin(),(x).end() using namespace std ; typedef long long ll ; typedef long double ld ; typedef pair < int , int > ipair ; typedef pair < ll , ll > lpair ; template < class T > ostream & operator << ( ostream & o , const vector < T > & v ) { o << "{" ; for ( int i = 0 ; i < ( int ) v . size ( ) ; i ++ ) o << ( i > 0 ? ", " : "" ) << v [ i ] ; o << "}" ; return o ; } void map_p ( map < int , int > & d ) { cout << "map: " ; for ( auto a : d ) { cout << "{" << a . first << ":" << a . second << "}" ; } cout << endl ; } void set_p ( set < int > & d ) { cout << "set: " ; for ( int a : d ) { cout << a << " " ; } cout << endl ; } ll inf = pow ( 10 , 18 ) ; vector < vector < ll > > dp ( 110 , vector < ll > ( 110 , inf ) ) ; int main ( ) { cin . tie ( 0 ) ; ios :: sync_with_stdio ( false ) ; cout << fixed << setprecision ( 12 ) ; int v , e ; cin > > v > > e ; rep ( i , v ) { dp [ i ] [ i ] = 0 ; } rep ( i , e ) { ll s , t , d ; cin > > s > > t > > d ; dp [ s ] [ t ] = d ; } for ( int k = 0 ; k < v ; k ++ ) { for ( int i = 0 ; i < v ; i ++ ) { for ( int j = 0 ; j < v ; j ++ ) { if ( dp [ i ] [ k ] < inf && dp [ k ] [ j ] < inf ) dp [ i ] [ j ] = min ( dp [ i ] [ j ] , dp [ i ] [ k ] + dp [ k ] [ j ] ) ; } } } bool flag = true ; rep ( i , v ) { if ( dp [ i ] [ i ] < 0 ) { flag = false ; break ; } } if ( flag ) { rep ( i , v ) { rep ( j , v - 1 ) { if ( dp [ i ] [ j ] == inf ) cout << "INF" << " " ; else cout << dp [ i ] [ j ] << " " ; } if ( dp [ i ] [ v - 1 ] == inf ) cout << "INF" << endl ; else cout << dp [ i ] [ v - 1 ] << endl ; } } else cout << "NEGATIVE CYCLE" << endl ; return 0 ; }<CODESPLIT>5.689564228057861<CODESPLIT>-1.0608329772949219<CODESPLIT>-1.0231640338897705<CODESPLIT>-1.1461822986602783<CODESPLIT>-1.2609347105026245<CODESPLIT>-1.2435710430145264
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> using namespace std ; typedef long long ll ; #define INF (2147483647) #define rep(i,a,b) for (int64_t i = (a); i < (b); i++) #define REP(i,n) rep(i,0,n) #define MAXV 110 int V , E ; vector < vector < ll > > G ( MAXV , vector < ll > ( MAXV , INF ) ) ; ll r ( ) { ll x ; cin > > x ; return x ; } void solve ( ) { cin > > V > > E ; REP ( i , V ) G [ i ] [ i ] = 0 ; REP ( i , E ) G [ r ( ) ] [ r ( ) ] = r ( ) ; REP ( k , V ) REP ( i , V ) REP ( j , V ) G [ i ] [ j ] = ( G [ i ] [ k ] == INF || G [ k ] [ j ] == INF ? G [ i ] [ j ] : min ( G [ i ] [ j ] , G [ i ] [ k ] + G [ k ] [ j ] ) ) ; REP ( i , V ) REP ( j , V ) if ( G [ i ] [ j ] < 0 ) REP ( k , V ) if ( G [ i ] [ j ] ! = min ( G [ i ] [ j ] , G [ i ] [ k ] + G [ k ] [ j ] ) ) { cout << "NEGATIVE CYCLE" << endl ; return ; } REP ( i , V ) REP ( j , V ) cout << ( G [ j ] [ i ] == INF ? "INF" : to_string ( G [ j ] [ i ] ) ) << ( j == V - 1 ? "\n" : " " ) ; } int main ( ) { cin . tie ( 0 ) ; ios :: sync_with_stdio ( false ) ; solve ( ) ; return 0 ; }<CODESPLIT>5.688310623168945<CODESPLIT>-1.1146752834320068<CODESPLIT>-0.9944615364074707<CODESPLIT>-1.1777794361114502<CODESPLIT>-1.2504470348358154<CODESPLIT>-1.2349387407302856
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include <iostream> #include <vector> using namespace std ; const long INFTY = ( long ( 1 ) << 40 ) ; class Node { public : int v , cost ; Node ( int n = 0 , int c = 0 ) : v ( n ) , cost ( c ) { } } ; bool operator < ( const Node & n1 , const Node & n2 ) { return n1 . cost < n2 . cost ; } class WF { public : vector < vector < long > > pairs ; WF ( int N = 0 , int Q = 0 ) { pairs . resize ( N ) ; for ( int i = 0 ; i < N ; i ++ ) { pairs [ i ] . resize ( N , INFTY ) ; pairs [ i ] [ i ] = 0 ; } load_cost ( Q ) ; } void load_cost ( int Q ) { int u , v , c ; for ( int i = 0 ; i < Q ; i ++ ) { cin > > u > > v > > c ; pairs [ u ] [ v ] = c ; } } void wf ( ) { int N = pairs . size ( ) ; for ( int k = 0 ; k < N ; k ++ ) { for ( int i = 0 ; i < N ; i ++ ) { if ( pairs [ i ] [ k ] == INFTY ) continue ; for ( int j = 0 ; j < N ; j ++ ) { if ( pairs [ k ] [ j ] == INFTY ) continue ; if ( pairs [ i ] [ j ] > pairs [ i ] [ k ] + pairs [ k ] [ j ] ) { pairs [ i ] [ j ] = pairs [ i ] [ k ] + pairs [ k ] [ j ] ; } } } } } bool negative ( ) { for ( int i = 0 ; i < pairs . size ( ) ; i ++ ) if ( pairs [ i ] [ i ] < 0 ) return true ; return false ; } } ; int main ( ) { int N , Q ; cin > > N > > Q ; WF wf ( N , Q ) ; wf . wf ( ) ; if ( wf . negative ( ) ) { cout << "NEGATIVE CYCLE" << endl ; } else { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( j ) cout << " " ; if ( wf . pairs [ i ] [ j ] == INFTY ) { cout << "INF" ; } else { cout << wf . pairs [ i ] [ j ] ; } } cout << endl ; } } }<CODESPLIT>5.672728061676025<CODESPLIT>-1.0225424766540527<CODESPLIT>-1.025437831878662<CODESPLIT>-1.1785070896148682<CODESPLIT>-1.294065237045288<CODESPLIT>-1.2740933895111084
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include <iostream> #include <vector> #include <queue> #include <cmath> #define INF 100000000000000000 using namespace std ; int main ( ) { int V , E , r ; cin > > V > > E ; long long int d [ V ] [ V ] = { } ; for ( int i = 0 ; i < V ; i ++ ) { for ( int j = 0 ; j < V ; j ++ ) d [ i ] [ j ] = INF ; d [ i ] [ i ] = 0 ; } for ( int i = 0 ; i < E ; i ++ ) { int a , b , c ; cin > > a > > b > > c ; d [ a ] [ b ] = c ; } for ( int k = 0 ; k < V ; k ++ ) { for ( int i = 0 ; i < V ; i ++ ) { for ( int j = 0 ; j < V ; j ++ ) { if ( d [ i ] [ k ] ! = INF && d [ k ] [ j ] ! = INF ) d [ i ] [ j ] = min ( d [ i ] [ j ] , d [ i ] [ k ] + d [ k ] [ j ] ) ; } } } for ( int i = 0 ; i < V ; i ++ ) { if ( d [ i ] [ i ] < 0 ) { cout << "NEGATIVE CYCLE" << endl ; return 0 ; } } for ( int i = 0 ; i < V ; i ++ ) { if ( d [ i ] [ 0 ] == INF ) cout << "INF" ; else cout << d [ i ] [ 0 ] ; for ( int j = 1 ; j < V ; j ++ ) { if ( d [ i ] [ j ] == INF ) cout << " INF" ; else cout << " " << d [ i ] [ j ] ; } cout << endl ; } return 0 ; }<CODESPLIT>5.679511070251465<CODESPLIT>-1.1003453731536865<CODESPLIT>-1.0715417861938477<CODESPLIT>-1.1394293308258057<CODESPLIT>-1.2263563871383667<CODESPLIT>-1.2840815782546997
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include <iostream> #include <cstdio> #include <string> #include <cstring> #include <deque> #include <list> #include <queue> #include <stack> #include <vector> #include <utility> #include <algorithm> #include <map> #include <set> #include <complex> #include <cmath> #include <limits> #include <climits> #include <ctime> using namespace std ; #define rep(i,a,n) for(int i=a; i<n; i++) #define repr(i,a,n) for(int i=a; i>=n; i--) #define pb(a) push_back(a) #define fr first #define sc second #define INF INT_MAX #define X real() #define Y imag() #define EPS (1e-10) #define EQ(a,b) (abs((a) - (b)) < EPS) #define EQV(a,b) ( EQ((a).X, (b).X) && EQ((a).Y, (b).Y) ) #define LE(n, m) ((n) < (m) + EPS) #define GE(n, m) ((n) + EPS > (m)) typedef vector < int > VI ; typedef vector < VI > MAT ; typedef pair < int , int > pii ; typedef long long int ll ; typedef complex < double > P ; typedef pair < P , P > L ; typedef pair < P , double > C ; int dy [ ] = { 0 , 0 , 1 , - 1 } ; int dx [ ] = { 1 , - 1 , 0 , 0 } ; int const MOD = 1000000007 ; struct Edge { int to , cost ; Edge ( int s , int d ) : to ( s ) , cost ( d ) { } } ; typedef vector < Edge > Edges ; typedef vector < Edges > Graph ; vector < vector < int > > warshall ( Graph & G ) { int V = G . size ( ) ; vector < vector < int > > d ( V ) ; rep ( i , 0 , V ) rep ( j , 0 , V ) { if ( i == j ) d [ i ] . push_back ( 0 ) ; else d [ i ] . push_back ( INF ) ; } rep ( i , 0 , V ) rep ( j , 0 , G [ i ] . size ( ) ) { Edge e = G [ i ] [ j ] ; d [ i ] [ e . to ] = e . cost ; } rep ( k , 0 , V ) rep ( i , 0 , V ) rep ( j , 0 , V ) if ( d [ i ] [ k ] ! = INF && d [ k ] [ j ] ! = INF ) d [ i ] [ j ] = min ( d [ i ] [ j ] , d [ i ] [ k ] + d [ k ] [ j ] ) ; return d ; } namespace std { bool operator < ( const P a , const P b ) { return a . X ! = b . X ? a . X < b . X : a . Y < b . Y ; } } int main ( ) { int V , E ; cin > > V > > E ; Graph G ( V ) ; int s , t , d ; rep ( i , 0 , E ) { cin > > s > > t > > d ; G [ s ] . push_back ( Edge ( t , d ) ) ; } vector < vector < int > > ans = warshall ( G ) ; bool minus = false ; rep ( i , 0 , V ) if ( ans [ i ] [ i ] < 0 ) minus = true ; if ( minus ) cout << "NEGATIVE CYCLE" << endl ; else { rep ( i , 0 , V ) { rep ( j , 0 , V ) { if ( j == 0 ) { ( ans [ i ] [ j ] >= INF ) ? cout << "INF" : cout << ans [ i ] [ j ] ; } else { ( ans [ i ] [ j ] >= INF ) ? cout << " INF" : cout << " " << ans [ i ] [ j ] ; } } cout << endl ; } } return 0 ; }<CODESPLIT>5.657734394073486<CODESPLIT>-0.929167628288269<CODESPLIT>-1.0549185276031494<CODESPLIT>-1.2020519971847534<CODESPLIT>-1.2710025310516357<CODESPLIT>-1.3116180896759033
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> using namespace std ; #define rep(i,n) for(ll i=0; i<n; i++) typedef long long ll ; typedef long long unsigned int llu ; ll MOD = 1000000007 ; ll INF = 1000000009 ; ll IINF = INF * INF ; ll adj [ 110 ] [ 110 ] ; ll adjtmp [ 110 ] [ 110 ] ; void solve ( ) { ll v , e ; cin > > v > > e ; rep ( i , v ) { rep ( j , v ) { adj [ i ] [ j ] = IINF ; } } rep ( i , e ) { ll x , y , z ; cin > > x > > y > > z ; adj [ x ] [ y ] = z ; } rep ( i , v ) { adj [ i ] [ i ] = 0 ; } for ( ll k = 0 ; k < v ; k ++ ) { for ( ll i = 0 ; i < v ; i ++ ) { for ( ll j = 0 ; j < v ; j ++ ) { adj [ i ] [ j ] = min ( adj [ i ] [ j ] , adj [ i ] [ k ] + adj [ k ] [ j ] ) ; } } } rep ( i , v ) { rep ( j , v ) { adjtmp [ i ] [ j ] = adj [ i ] [ j ] ; } } for ( ll k = 0 ; k < v ; k ++ ) { for ( ll i = 0 ; i < v ; i ++ ) { for ( ll j = 0 ; j < v ; j ++ ) { adj [ i ] [ j ] = min ( adj [ i ] [ j ] , adj [ i ] [ k ] + adj [ k ] [ j ] ) ; } } } bool notnegativecycle = true ; rep ( i , v ) { rep ( j , v ) { if ( adjtmp [ i ] [ j ] ! = adj [ i ] [ j ] ) notnegativecycle = false ; } } if ( ! notnegativecycle ) { cout << "NEGATIVE CYCLE" << endl ; return ; } rep ( i , v ) { rep ( j , v ) { if ( j == v - 1 ) { if ( adj [ i ] [ j ] < INF * 100000 ) cout << adj [ i ] [ j ] ; else cout << "INF" ; } else { if ( adj [ i ] [ j ] < INF * 100000 ) cout << adj [ i ] [ j ] << " " ; else cout << "INF" << " " ; } } cout << endl ; } } int main ( ) { cin . tie ( 0 ) ; ios :: sync_with_stdio ( false ) ; solve ( ) ; return 0 ; }<CODESPLIT>5.683889865875244<CODESPLIT>-1.2166695594787598<CODESPLIT>-1.0284916162490845<CODESPLIT>-1.1528184413909912<CODESPLIT>-1.223934292793274<CODESPLIT>-1.2452441453933716
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#pragma GCC optimize("O3") #include <bits/stdc++.h> #define ll long long #define rep2(i,a,b) for(ll i=a;i<=b;++i) #define rep(i,n) for(ll i=0;i<n;i++) #define rep3(i,a,b) for(ll i=a;i>=b;i--) #define pii pair<int,int> #define pll pair<ll,ll> #define pq priority_queue #define pb push_back #define eb emplace_back #define veci vector<int> #define vecll vector<ll> #define vecpii vector<pii> #define vec2(a,b) vector<vec>(a,vec(b)) #define vec2ll(a,b) vector<vec>(a,vecll(b)) #define vec3(a,b,c) vector<vector<vec>>(a,vec2(b,c)) #define vec3ll(a,b,c) vector<vector<vecll>>(a,vec2ll(b,c)) #define fi first #define se second #define all(c) begin(c),end(c) #define ios ios_base::sync_with_stdio(0),cin.tie(0),cout.tie(0); #define lb(c,x) distance(c.begin(),lower_bound(all(c),x)) #define ub(c,x) distance(c.begin(),upper_bound(all(c),x)) using namespace std ; int in ( ) { int x ; cin > > x ; return x ; } ll lin ( ) { ll x ; cin > > x ; return x ; } template < class T > inline bool chmax ( T & a , T b ) { if ( a < b ) { a = b ; return 1 ; } return 0 ; } template < class T > inline bool chmin ( T & a , T b ) { if ( a > b ) { a = b ; return 1 ; } return 0 ; } template < class T > inline void print ( pair < T , T > p ) { cout << "(" << p . first << "," << p . second << ") " ; } template < typename T > istream & operator > > ( istream & is , vector < T > & vec ) { for ( T & x : vec ) is > > x ; return is ; } const ll INF = 1e10+100 ; ll v ; ll d [ 105 ] [ 105 ] ; void floyd ( ) { rep ( k , v ) { rep ( i , v ) { if ( d [ i ] [ k ] == INF ) continue ; rep ( j , v ) { if ( d [ k ] [ j ] == INF ) continue ; d [ i ] [ j ] = min ( d [ i ] [ j ] , d [ i ] [ k ] + d [ k ] [ j ] ) ; } } } } int main ( ) { ll e ; cin > > v > > e ; rep ( i , v ) { rep ( j , v ) { d [ i ] [ j ] = ( ( i == j ) ? 0 : INF ) ; } } rep ( i , e ) { ll s , t , c ; cin > > s > > t > > c ; d [ s ] [ t ] = c ; } floyd ( ) ; bool negative = false ; rep ( i , v ) { if ( d [ i ] [ i ] < 0 ) { negative = true ; } } if ( negative ) { cout << "NEGATIVE CYCLE" << endl ; } else { rep ( i , v ) { rep ( j , v ) { if ( j ) cout << " " ; if ( d [ i ] [ j ] == INF ) cout << "INF" ; else cout << d [ i ] [ j ] ; } cout << endl ; } } }<CODESPLIT>5.6670403480529785<CODESPLIT>-1.000241994857788<CODESPLIT>-1.0624325275421143<CODESPLIT>-1.2015550136566162<CODESPLIT>-1.2625904083251953<CODESPLIT>-1.2939952611923218
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include<bits/stdc++.h> using namespace std ; typedef long long ll ; using vll = vector < ll > ; using vi = vector < int > ; using vb = vector < bool > ; using pii = pair < int , int > ; template < class T > inline bool chmin ( T & a , T b ) { if ( a > b ) { a = b ; return true ; } return false ; } template < class T > inline bool chmax ( T & a , T b ) { if ( a < b ) { a = b ; return true ; } return false ; } template < class T > ll llpow ( ll x , T n ) { ll ans = 1 ; if ( x == 0 ) ans = 0 ; while ( n ) { if ( n & 1 ) ans *= x ; x *= x ; n > >= 1 ; } return ans ; } long long modpow ( long long a , long long n , long long mod ) { long long res = 1 ; while ( n > 0 ) { if ( n & 1 ) res = res * a % mod ; a = a * a % mod ; n > >= 1 ; } return res ; } template < class T > inline T gcd ( T x , T y ) { if ( y == 0 ) return x ; else { return gcd ( y , x % y ) ; } } template < class T > inline T lcm ( T x , T y ) { return x / gcd ( x , y ) * y ; } long long modinv ( long long a , long long m ) { long long b = m , u = 1 , v = 0 ; while ( b ) { long long t = a / b ; a -= t * b ; swap ( a , b ) ; u -= t * v ; swap ( u , v ) ; } u % = m ; if ( u < 0 ) u += m ; return u ; } #define rep(i, begin_i, end_i) for (ll i = (ll)begin_i; i < (ll)end_i; i++) long long INF = 1LL << 60 ; int main ( ) { int V , E ; cin > > V > > E ; vector < vll > Dist ( V , vll ( V , INF ) ) ; rep ( i , 0 , V ) Dist [ i ] [ i ] = 0 ; rep ( i , 0 , E ) { int f , t ; cin > > f > > t ; int d ; cin > > d ; Dist [ f ] [ t ] = d ; } rep ( i , 0 , V ) { rep ( j , 0 , V ) { if ( Dist [ j ] [ i ] == INF ) continue ; rep ( k , 0 , V ) { if ( Dist [ i ] [ k ] == INF ) continue ; chmin ( Dist [ j ] [ k ] , Dist [ j ] [ i ] + Dist [ i ] [ k ] ) ; } } } bool check = false ; rep ( i , 0 , V ) if ( Dist [ i ] [ i ] < 0 ) check = true ; if ( check ) { cout << "NEGATIVE CYCLE" << endl ; return 0 ; } rep ( i , 0 , V ) { rep ( j , 0 , V ) { if ( j >= 1 && j <= V - 1 ) cout << " " ; if ( Dist [ i ] [ j ] == INF ) cout << "INF" ; else { cout << Dist [ i ] [ j ] ; } } cout << endl ; } return 0 ; }<CODESPLIT>5.589720249176025<CODESPLIT>-0.9431079030036926<CODESPLIT>-1.0366789102554321<CODESPLIT>-1.2308522462844849<CODESPLIT>-1.2686368227005005<CODESPLIT>-1.2257328033447266
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include<iostream> #include<vector> #include<utility> #define NMAX 100 #define INFTY 10101010101010101 using namespace std ; typedef long long nat ; typedef pair < int , int > pii ; typedef pair < nat , int > pni ; typedef pair < nat , pair < int , int > > pnii ; class FloydWarshall { public : vector < pnii > edge ; vector < vector < nat > > l ; vector < vector < int > > p ; int n ; FloydWarshall ( ) { } FloydWarshall ( int size ) { l . resize ( size ) ; p . resize ( size ) ; edge . resize ( 0 ) ; for ( int i = 0 ; i < size ; ++ i ) { l [ i ] . resize ( size ) ; p [ i ] . resize ( size ) ; for ( int j = 0 ; j < size ; ++ j ) { l [ i ] [ j ] = INFTY ; p [ i ] [ j ] = - 1 ; } } n = size ; } void add_dir_edge ( int s , int t , nat c ) { edge . push_back ( pnii ( c , pii ( s , t ) ) ) ; } int solve ( ) { int s , t ; nat c ; for ( int i = 0 ; i < n ; ++ i ) { l [ i ] [ i ] = 0 ; p [ i ] [ i ] = i ; } for ( auto itr = edge . begin ( ) ; itr ! = edge . end ( ) ; ++ itr ) { c = itr -> first ; s = itr -> second . first ; t = itr -> second . second ; l [ s ] [ t ] = c ; p [ s ] [ t ] = s ; } for ( int j = 0 ; j < n ; ++ j ) { for ( int i = 0 ; i < n ; ++ i ) { if ( l [ i ] [ j ] == INFTY ) { continue ; } for ( int k = 0 ; k < n ; ++ k ) { if ( l [ j ] [ k ] == INFTY ) { continue ; } if ( l [ i ] [ k ] > l [ i ] [ j ] + l [ j ] [ k ] ) { l [ i ] [ k ] = l [ i ] [ j ] + l [ j ] [ k ] ; p [ i ] [ k ] = p [ j ] [ k ] ; } } } } return detect_cycle ( ) ; } private : vector < int > visited ; int detect_cycle ( ) { visited . resize ( n ) ; int s = - 1 , t = - 1 , u , v ; nat c ; for ( int i = 0 ; i < n ; ++ i ) { for ( int i = 0 ; i < n ; ++ i ) { visited [ i ] = 0 ; } for ( auto itr = edge . begin ( ) ; itr ! = edge . end ( ) ; ++ itr ) { u = itr -> second . first ; v = itr -> second . second ; c = itr -> first ; if ( l [ i ] [ u ] == INFTY || l [ i ] [ v ] == INFTY ) { continue ; } if ( l [ i ] [ v ] > l [ i ] [ u ] + c ) { return 0 ; } } } return - 1 ; } } ; int main ( ) { int n , m , r ; int s , t , d ; cin > > n > > m ; FloydWarshall fw = FloydWarshall ( n ) ; for ( int i = 0 ; i < m ; ++ i ) { cin > > s > > t > > d ; fw . add_dir_edge ( s , t , d ) ; } int f = fw . solve ( ) ; if ( f ! = - 1 ) { cout << "NEGATIVE CYCLE" << endl ; return 0 ; } for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) { if ( fw . l [ i ] [ j ] ! = INFTY ) { cout << fw . l [ i ] [ j ] ; } else { cout << "INF" ; } if ( j ! = n - 1 ) { cout << " " ; } } cout << endl ; } return 0 ; }<CODESPLIT>5.6774115562438965<CODESPLIT>-0.9884023666381836<CODESPLIT>-1.0321576595306396<CODESPLIT>-1.1962170600891113<CODESPLIT>-1.2513335943222046<CODESPLIT>-1.3191899061203003
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> using namespace std ; #define INF INT32_MAX int main ( ) { int V , E ; cin > > V > > E ; vector < vector < long long > > mat ( V , vector < long long > ( V , INF ) ) ; for ( int i = 0 ; i < V ; i ++ ) mat [ i ] [ i ] = 0 ; for ( int i = 0 ; i < E ; i ++ ) { int s , t , d ; cin > > s > > t > > d ; mat [ s ] [ t ] = d ; } for ( int k = 0 ; k < V ; k ++ ) { for ( int i = 0 ; i < V ; i ++ ) { if ( mat [ i ] [ k ] == INF ) continue ; for ( int j = 0 ; j < V ; j ++ ) { if ( mat [ k ] [ j ] == INF ) continue ; mat [ i ] [ j ] = min ( mat [ i ] [ j ] , mat [ i ] [ k ] + mat [ k ] [ j ] ) ; } } } int nega = 0 ; for ( int i = 0 ; i < V ; i ++ ) { if ( mat [ i ] [ i ] < 0 ) { nega = 1 ; break ; } } if ( nega ) { cout << "NEGATIVE CYCLE" << endl ; } else { for ( int i = 0 ; i < V ; i ++ ) { for ( int j = 0 ; j < V ; j ++ ) { if ( j ) cout << " " ; int d = mat [ i ] [ j ] ; if ( d == INF ) cout << "INF" ; else cout << d ; } cout << endl ; } } }<CODESPLIT>5.675117015838623<CODESPLIT>-1.1117186546325684<CODESPLIT>-1.0471371412277222<CODESPLIT>-1.1372404098510742<CODESPLIT>-1.234096646308899<CODESPLIT>-1.2907638549804688
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> using namespace std ; long long MAX_V = 105 ; long long INF = 1e12 ; vector < vector < long long > > d ( MAX_V , vector < long long > ( MAX_V ) ) ; long long v ; void warshall_floyd ( ) { for ( long long k = 0 ; k < v ; k ++ ) { for ( long long i = 0 ; i < v ; i ++ ) { for ( long long j = 0 ; j < v ; j ++ ) { if ( d [ i ] [ k ] == INF || d [ k ] [ j ] == INF ) continue ; d [ i ] [ j ] = min ( d [ i ] [ j ] , d [ i ] [ k ] + d [ k ] [ j ] ) ; } } } } int main ( ) { long long e ; cin > > v > > e ; for ( long long i = 0 ; i < v ; i ++ ) { for ( long long j = 0 ; j < v ; j ++ ) { d [ i ] [ j ] = INF ; } } for ( long long i = 0 ; i < e ; i ++ ) { long long s , t , c ; cin > > s > > t > > c ; d [ s ] [ t ] = c ; } for ( long long i = 0 ; i < v ; i ++ ) { d [ i ] [ i ] = 0 ; } warshall_floyd ( ) ; for ( long long i = 0 ; i < v ; i ++ ) { if ( d [ i ] [ i ] < 0 ) { cout << "NEGATIVE CYCLE" << endl ; return 0 ; } } for ( long long i = 0 ; i < v ; i ++ ) { for ( long long j = 0 ; j < v ; j ++ ) { if ( j > 0 ) cout << ' ' ; if ( d [ i ] [ j ] == INF ) cout << "INF" ; else cout << d [ i ] [ j ] ; } cout << endl ; } }<CODESPLIT>5.676139831542969<CODESPLIT>-1.2166168689727783<CODESPLIT>-1.0272328853607178<CODESPLIT>-1.129197597503662<CODESPLIT>-1.2171345949172974<CODESPLIT>-1.2518763542175293
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include <iostream> using namespace std ; #define INF 2000000001 #define MAX_V 100 int d [ MAX_V ] [ MAX_V ] ; int main ( void ) { int v , e ; cin > > v > > e ; for ( int i = 0 ; i < v ; i ++ ) { for ( int j = 0 ; j < v ; j ++ ) { d [ i ] [ j ] = INF ; if ( i == j ) d [ i ] [ j ] = 0 ; } } for ( int i = 0 ; i < e ; i ++ ) { int s , t , c ; cin > > s > > t > > c ; d [ s ] [ t ] = c ; } for ( int k = 0 ; k < v ; k ++ ) { for ( int i = 0 ; i < v ; i ++ ) { for ( int j = 0 ; j < v ; j ++ ) { if ( d [ i ] [ k ] < INF && d [ k ] [ j ] < INF ) d [ i ] [ j ] = min ( d [ i ] [ j ] , d [ i ] [ k ] + d [ k ] [ j ] ) ; } } } for ( int i = 0 ; i < v ; i ++ ) { if ( d [ i ] [ i ] < 0 ) { cout << "NEGATIVE CYCLE" << endl ; return 0 ; } } for ( int i = 0 ; i < v ; i ++ ) { for ( int j = 0 ; j < v ; j ++ ) { if ( d [ i ] [ j ] == INF ) cout << "INF" ; else cout << d [ i ] [ j ] ; if ( j ! = v - 1 ) cout << " " ; } cout << endl ; } }<CODESPLIT>5.674840450286865<CODESPLIT>-1.1570069789886475<CODESPLIT>-1.0663450956344604<CODESPLIT>-1.1350253820419312<CODESPLIT>-1.2176810503005981<CODESPLIT>-1.26513671875
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include <iostream> #include <cstdio> #include <cstdlib> #include <algorithm> #include <vector> #include <utility> #include <queue> #include <climits> using namespace std ; void floyd ( vector < vector < long long > > & d ) { for ( int k = 0 ; k < d . size ( ) ; k ++ ) { for ( int i = 0 ; i < d . size ( ) ; i ++ ) { if ( LLONG_MAX == d [ i ] [ k ] ) continue ; for ( int j = 0 ; j < d . size ( ) ; j ++ ) { if ( LLONG_MAX == d [ k ] [ j ] ) continue ; d [ i ] [ j ] = min ( d [ i ] [ j ] , d [ i ] [ k ] + d [ k ] [ j ] ) ; } } } } int main ( ) { int v , e ; cin > > v > > e ; vector < vector < long long > > d ( v , vector < long long > ( v , LLONG_MAX ) ) ; int s , t ; for ( int i = 0 ; i < v ; i ++ ) d [ i ] [ i ] = 0 ; for ( int i = 0 ; i < e ; i ++ ) { cin > > s > > t ; cin > > d [ s ] [ t ] ; } floyd ( d ) ; for ( int i = 0 ; i < v ; i ++ ) { if ( d [ i ] [ i ] < 0 ) { cout << "NEGATIVE CYCLE" << endl ; return 0 ; } } for ( int i = 0 ; i < v ; i ++ ) { for ( auto itr = d . at ( i ) . begin ( ) ; itr ! = d . at ( i ) . end ( ) ; ++ itr ) { if ( itr ! = d . at ( i ) . begin ( ) ) cout << " " ; if ( LLONG_MAX == * itr ) cout << "INF" ; else cout << * itr ; } cout << endl ; } return 0 ; }<CODESPLIT>5.66171932220459<CODESPLIT>-1.203460693359375<CODESPLIT>-1.0353002548217773<CODESPLIT>-1.1108298301696777<CODESPLIT>-1.232765555381775<CODESPLIT>-1.2642056941986084
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include <iostream> #include <vector> #include <string> #include <cstring> #include <algorithm> #include <sstream> #include <map> #include <set> #define REP(i,k,n) for(int i=k;i<n;i++) #define rep(i,n) for(int i=0;i<n;i++) #define INF 1LL<<50 #define pb push_back #define mp make_pair using namespace std ; typedef long long ll ; typedef pair < int , int > P ; ll d [ 105 ] [ 105 ] ; void warshall_floyd ( int n ) { rep ( k , n ) { rep ( i , n ) { rep ( j , n ) { if ( d [ i ] [ k ] ! = INF && d [ k ] [ j ] ! = INF ) { d [ i ] [ j ] = min ( d [ i ] [ j ] , d [ i ] [ k ] + d [ k ] [ j ] ) ; } } } } } int main ( ) { int n , m ; cin > > n > > m ; rep ( i , n ) rep ( j , n ) d [ i ] [ j ] = INF ; rep ( i , n ) d [ i ] [ i ] = 0 ; rep ( i , m ) { int s , t , c ; cin > > s > > t > > c ; d [ s ] [ t ] = c ; } warshall_floyd ( n ) ; bool flag = false ; rep ( i , n ) { if ( d [ i ] [ i ] < 0 ) flag = true ; } if ( flag ) { cout << "NEGATIVE CYCLE" << endl ; } else { rep ( i , n ) { rep ( j , n ) { if ( d [ i ] [ j ] == INF ) cout << "INF" ; else cout << d [ i ] [ j ] ; if ( j == n - 1 ) cout << endl ; else cout << " " ; } } } return 0 ; }<CODESPLIT>5.6771159172058105<CODESPLIT>-1.1231675148010254<CODESPLIT>-1.0292291641235352<CODESPLIT>-1.1156630516052246<CODESPLIT>-1.21358060836792<CODESPLIT>-1.2662230730056763
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> using namespace std ; #define INF 1001001001 #define LINF 1001001001001001001 #define MOD 1000000007 #define MOD2 998244353 template < class T , class U > bool chmax ( T & a , const U & b ) { if ( a < b ) { a = b ; return 1 ; } return 0 ; } template < class T , class U > bool chmin ( T & a , const U & b ) { if ( b < a ) { a = b ; return 1 ; } return 0 ; } #define rep(i,n) for(int i=0,_i=(n);i<_i;++i) #define rep1(i,a,b) for(int a_=(a),b_=(b),i=a_;i<b_;++i) #define repr(i,n) for(int _i=(n),i=_i;i>0;--i) #define db(x) cerr<<#x<<" = "<<x<<" "; #define db2(x,y) cerr<<"("<<#x<<", "<<#y<<") = ("<<x<<", "<<y<<") "; #define db3(x,y,z) cerr<<"("<<#x<<", "<<#y<<", "<<#z<<") = ("<<x<<", "<<y<<", "<<z<<") "; #define ln cout<<endl; #define all(a)  (a).begin(),(a).end() #define dig(n)  to_string(n).length() #define pb push_back #define eb emplace_back #define mp make_pair #define se second #define fi first typedef long long ll ; typedef pair < int , int > P ; typedef pair < int , P > iP ; typedef pair < P , P > PP ; ll gcd ( ll a , ll b ) { return b ? gcd ( b , a % b ) : a ; } ll lcm ( ll a , ll b ) { return ( a * b ) / gcd ( a , b ) ; } int dx [ 4 ] = { 1 , 0 , - 1 , 0 } ; int dy [ 4 ] = { 0 , 1 , 0 , - 1 } ; class iv { } ; class ie { } ; class edge { public : int frm ; int to ; int cost ; edge ( int f , int t ) : frm ( f ) , to ( t ) { } ; edge ( int f , int t , int c ) : frm ( f ) , to ( t ) , cost ( c ) { } ; } ; class Graph { public : int nV ; int nE ; vector < iv > vinfo ; vector < ie > einfo ; vector < vector < edge > > g ; Graph ( int _nV , int _nE ) : nV ( _nV ) , nE ( _nE ) { g . resize ( nV ) ; vinfo . resize ( nV ) ; einfo . resize ( nE ) ; } void addE ( int u , int v ) { edge e ( u , v , 1 ) ; g [ u ] . eb ( e ) ; } void addE ( int u , int v , int cost ) { edge e ( u , v , cost ) ; g [ u ] . eb ( e ) ; } vector < int > dijkstra ( int s ) { vector < int > dist ( nV , INF ) ; dist [ s ] = 0 ; vector < bool > vis ( nV , false ) ; priority_queue < P , vector < P > , greater < P > > que ; que . push ( P ( 0 , s ) ) ; while ( ! que . empty ( ) ) { P vd = que . top ( ) ; que . pop ( ) ; int cur = vd . se ; int cdist = vd . fi ; vis [ cur ] = true ; rep ( i , g [ cur ] . size ( ) ) { edge e = g [ cur ] [ i ] ; int nex = e . to ; int cost = e . cost ; if ( vis [ nex ] ) continue ; if ( chmin ( dist [ nex ] , cdist + cost ) ) { } else { } que . push ( P ( dist [ nex ] , nex ) ) ; } } return dist ; } vector < int > bellman_ford ( int s ) { vector < int > dist ( nV , INF ) ; dist [ s ] = 0 ; int roopcnt = 0 ; while ( 1 ) { bool update = false ; rep ( i , nV ) rep ( j , g [ i ] . size ( ) ) { edge e = g [ i ] [ j ] ; int from = e . frm ; int nex = e . to ; int cost = e . cost ; if ( dist [ from ] ! = INF ) if ( chmin ( dist [ nex ] , dist [ from ] + cost ) ) update = true ; } if ( update ) { ++ roopcnt ; if ( roopcnt > nV - 1 ) { vector < int > negcy ; return negcy ; } } else break ; } return dist ; } vector < vector < ll > > warshall_floyid ( ) { vector < vector < ll > > dist ( nV , vector < ll > ( nV , LINF ) ) ; rep ( i , nV ) dist [ i ] [ i ] = 0 ; rep ( i , nV ) rep ( j , g [ i ] . size ( ) ) { edge e = g [ i ] [ j ] ; dist [ e . frm ] [ e . to ] = e . cost ; } rep ( k , nV ) rep ( i , nV ) rep ( j , nV ) { if ( ! ( dist [ i ] [ k ] == LINF || dist [ k ] [ j ] == LINF ) ) chmin ( dist [ i ] [ j ] , dist [ i ] [ k ] + dist [ k ] [ j ] ) ; } rep ( i , nV ) if ( dist [ i ] [ i ] < 0 ) { vector < vector < ll > > negcy ; return negcy ; } return dist ; } } ; int main ( ) { bool flag = false ; ll ans = 0 , sum = 0 ; int V , E , r ; cin > > V > > E ; Graph g ( V , E ) ; rep ( i , E ) { int u , v , c ; cin > > u > > v > > c ; g . addE ( u , v , c ) ; } vector < vector < ll > > dist = g . warshall_floyid ( ) ; if ( dist . empty ( ) ) { puts ( "NEGATIVE CYCLE" ) ; return 0 ; } rep ( i , V ) { rep ( j , V ) { if ( dist [ i ] [ j ] ! = LINF ) cout << dist [ i ] [ j ] ; else cout << "INF" ; if ( j ! = V - 1 ) cout << " " ; else ln ; } } return 0 ; }<CODESPLIT>5.672922611236572<CODESPLIT>-0.8785163164138794<CODESPLIT>-1.076053261756897<CODESPLIT>-1.1944069862365723<CODESPLIT>-1.3066319227218628<CODESPLIT>-1.3157143592834473
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include<bits/stdc++.h> using namespace std ; const int64_t INF = 1e16 ; int main ( ) { int n , e ; cin > > n > > e ; vector < vector < pair < int , int > > > g ( n ) ; vector < vector < int64_t > > dp ( n , vector < int64_t > ( n , INF ) ) ; for ( int i = 0 ; i < e ; i ++ ) { int s , t , d ; cin > > s > > t > > d ; dp . at ( s ) . at ( t ) = d ; } for ( int i = 0 ; i < n ; i ++ ) dp . at ( i ) . at ( i ) = 0 ; for ( int k = 0 ; k < n ; k ++ ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { dp . at ( i ) . at ( j ) = min ( dp . at ( i ) . at ( j ) , dp . at ( i ) . at ( k ) + dp . at ( k ) . at ( j ) ) ; } } } bool flg = 1 ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == j && dp . at ( i ) . at ( j ) < 0 ) flg = 0 ; } } if ( flg ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( dp . at ( i ) . at ( j ) < 1e10 ) cout << dp . at ( i ) . at ( j ) << ( j ! = n - 1 ? " " : "" ) ; else cout << "INF" << ( j ! = n - 1 ? " " : "" ) ; } cout << endl ; } } else cout << "NEGATIVE CYCLE" << endl ; }<CODESPLIT>5.70485258102417<CODESPLIT>-1.0328748226165771<CODESPLIT>-1.0335041284561157<CODESPLIT>-1.1582868099212646<CODESPLIT>-1.2540581226348877<CODESPLIT>-1.301628589630127
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include<iostream> #include<cstdio> #include<algorithm> #include<vector> #define MAX 10000 #define NEG -10000 using namespace std ; static const long long INFTY = ( 1LL << 32 ) ; long long path [ MAX ] [ MAX ] ; int V ; void Floyd ( ) { for ( int k = 0 ; k < V ; k ++ ) { for ( int i = 0 ; i < V ; i ++ ) { if ( path [ i ] [ k ] == INFTY ) { continue ; } for ( int j = 0 ; j < V ; j ++ ) { if ( path [ k ] [ j ] == INFTY ) { continue ; } path [ i ] [ j ] = min ( path [ i ] [ j ] , path [ i ] [ k ] + path [ k ] [ j ] ) ; } } } } int main ( ) { int E ; int s , t , d ; long long neg [ MAX ] ; cin > > V ; for ( int i = 0 ; i < V ; i ++ ) { for ( int j = 0 ; j < V ; j ++ ) { if ( i == j ) { path [ i ] [ j ] = 0 ; } else { path [ i ] [ j ] = INFTY ; neg [ i ] = INFTY ; } } } cin > > E ; for ( int i = 0 ; i < E ; i ++ ) { cin > > s > > t > > d ; path [ s ] [ t ] = d ; } Floyd ( ) ; bool Neg = false ; for ( int i = 0 ; i < V ; i ++ ) { if ( path [ i ] [ i ] < 0 ) { Neg = true ; } } if ( Neg ) { cout << "NEGATIVE CYCLE" << endl ; } else { for ( int j = 0 ; j < V ; j ++ ) { for ( int k = 0 ; k < V ; k ++ ) { if ( path [ j ] [ k ] == INFTY ) { if ( k ! = 0 ) cout << " " ; cout << "INF" ; } else { if ( k ! = 0 ) cout << " " ; cout << path [ j ] [ k ] ; } } cout << endl ; } } return 0 ; }<CODESPLIT>5.677792072296143<CODESPLIT>-1.206074595451355<CODESPLIT>-1.0248240232467651<CODESPLIT>-1.117964267730713<CODESPLIT>-1.2265413999557495<CODESPLIT>-1.2683135271072388
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> #include<iostream> #include<cstdio> #include<vector> #include<queue> #include<map> #include<cstring> #include<string> #include <math.h> #include<algorithm> #include<functional> #define int long long #define inf  100000000000007 #define pa pair<int,int> #define ll long long #define pal pair<ll,ll> #define ppa pair<int,pa> #define EPS (1e-10) #define equals(a,b) (fabs((a)-(b))<EPS) using namespace std ; int dx [ 4 ] = { 1 , 0 , - 1 , 0 } ; int dy [ 4 ] = { 0 , 1 , 0 , - 1 } ; int dis [ 105 ] [ 105 ] ; int a [ 105 ] [ 105 ] ; signed main ( ) { int V , E ; cin > > V > > E ; for ( int i = 0 ; i < V ; i ++ ) for ( int j = 0 ; j < V ; j ++ ) dis [ i ] [ j ] = inf , a [ i ] [ j ] = inf ; for ( int i = 0 ; i < V ; i ++ ) dis [ i ] [ i ] = 0 ; for ( int i = 0 ; i < E ; i ++ ) { int y , yy , yyy ; cin > > y > > yy > > yyy ; dis [ y ] [ yy ] = yyy ; a [ y ] [ yy ] = yyy ; } for ( int i = 0 ; i < V ; i ++ ) for ( int j = 0 ; j < V ; j ++ ) for ( int k = 0 ; k < V ; k ++ ) { if ( dis [ j ] [ i ] ! = inf && dis [ i ] [ k ] ! = inf ) dis [ j ] [ k ] = min ( dis [ j ] [ k ] , dis [ j ] [ i ] + dis [ i ] [ k ] ) ; } for ( int i = 0 ; i < V ; i ++ ) { if ( dis [ i ] [ i ] < 0 ) { cout << "NEGATIVE CYCLE" << endl ; return 0 ; } } for ( int i = 0 ; i < V ; i ++ ) { if ( dis [ i ] [ 0 ] < inf ) cout << dis [ i ] [ 0 ] ; else cout << "INF" ; for ( int j = 1 ; j < V ; j ++ ) { if ( dis [ i ] [ j ] < inf ) cout << " " << dis [ i ] [ j ] ; else cout << " INF" ; } cout << endl ; } return 0 ; }<CODESPLIT>5.665618419647217<CODESPLIT>-0.9577858448028564<CODESPLIT>-0.976283848285675<CODESPLIT>-1.2367194890975952<CODESPLIT>-1.226413607597351<CODESPLIT>-1.2569208145141602
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> using namespace std ; template < typename T > bool chmax ( T & u , const T z ) { if ( u < z ) { u = z ; return true ; } else return false ; } template < typename T > bool chmin ( T & u , const T z ) { if ( u > z ) { u = z ; return true ; } else return false ; } #define rep(i, n) for (int i = 0; i < (int)(n); i++) #define ll long long  typedef pair < ll , ll > P ; const ll INF = 1LL << 60 ; int v , e ; ll dist [ 110 ] [ 110 ] ; void warshall_floyd ( ) { rep ( k , v ) rep ( i , v ) rep ( j , v ) { chmin ( dist [ i ] [ j ] , dist [ i ] [ k ] + dist [ k ] [ j ] ) ; } } int main ( ) { cin > > v > > e ; rep ( i , v ) rep ( j , v ) dist [ i ] [ j ] = INF ; rep ( i , v ) dist [ i ] [ i ] = 0 ; rep ( i , e ) { int s , t , d ; cin > > s > > t > > d ; dist [ s ] [ t ] = d ; } warshall_floyd ( ) ; rep ( i , v ) rep ( j , v ) rep ( k , v ) { if ( dist [ i ] [ j ] > dist [ i ] [ k ] + dist [ k ] [ j ] ) { puts ( "NEGATIVE CYCLE" ) ; return 0 ; } } rep ( i , v ) rep ( j , v ) { if ( dist [ i ] [ j ] <= 1e10 ) { if ( j ! = v - 1 ) cout << dist [ i ] [ j ] << " " ; else cout << dist [ i ] [ j ] << endl ; } else { if ( j ! = v - 1 ) cout << "INF " ; else cout << "INF\n" ; } } return 0 ; }<CODESPLIT>5.703754901885986<CODESPLIT>-1.038641333580017<CODESPLIT>-1.0600826740264893<CODESPLIT>-1.164102554321289<CODESPLIT>-1.2846747636795044<CODESPLIT>-1.2809499502182007
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include<bits/stdc++.h> #define rep(i,N) for(int i=0;i<N;i++) #define rep2(i,N) for(int i=1;i<=N;i++) using namespace std ; long long INF = 1e18 ; long long mod = 1e9+7 ; long long edge [ 110 ] [ 110 ] ; long long dist [ 105 ] [ 105 ] ; int main ( ) { int V , E ; cin > > V > > E ; rep ( i , V ) rep ( k , V ) edge [ i ] [ k ] = INF ; rep ( i , E ) { int s , t ; long long d ; cin > > s > > t > > d ; edge [ s ] [ t ] = d ; } rep ( l , 3 ) { rep ( i , V ) { rep ( j , V ) { rep ( k , V ) { if ( edge [ i ] [ j ] ! = INF && edge [ j ] [ k ] ! = INF ) { edge [ i ] [ k ] = min ( edge [ i ] [ k ] , edge [ i ] [ j ] + edge [ j ] [ k ] ) ; } } } } } rep ( i , V ) { if ( edge [ i ] [ i ] < 0 ) { cout << "NEGATIVE CYCLE" << endl ; ; return 0 ; } } rep ( i , V ) { rep ( k , V ) { if ( i == k ) { cout << "0" ; } else if ( edge [ i ] [ k ] == INF ) cout << "INF" ; else { cout << edge [ i ] [ k ] ; } if ( k ! = V - 1 ) cout << " " ; else cout << endl ; } } return 0 ; }<CODESPLIT>5.701000690460205<CODESPLIT>-1.0919238328933716<CODESPLIT>-1.0329782962799072<CODESPLIT>-1.1729769706726074<CODESPLIT>-1.2182027101516724<CODESPLIT>-1.3042848110198975
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> using namespace std ; const long long INF = 1e17 ; void warshall_floyd ( vector < vector < long long > > & dist , vector < vector < long long > > & prev ) { int V = dist . size ( ) ; for ( int k = 0 ; k < V ; k ++ ) { for ( int i = 0 ; i < V ; i ++ ) { for ( int j = 0 ; j < V ; j ++ ) { if ( dist [ i ] [ k ] + dist [ k ] [ j ] < dist [ i ] [ j ] ) { dist [ i ] [ j ] = dist [ i ] [ k ] + dist [ k ] [ j ] ; prev [ i ] [ j ] = prev [ k ] [ j ] ; } } } } } vector < int > get_path ( const vector < vector < long long > > & prev , int s , int t ) { vector < int > path ; for ( int cur = t ; cur ! = s ; cur = prev [ s ] [ cur ] ) { path . push_back ( cur ) ; } path . push_back ( s ) ; reverse ( path . begin ( ) , path . end ( ) ) ; return path ; } bool is_negative ( const vector < vector < long long > > & dist ) { int V = dist . size ( ) ; for ( int i = 0 ; i < V ; i ++ ) { if ( dist [ i ] [ i ] < 0 ) { return true ; } } return false ; } int main ( ) { int V , E ; cin > > V > > E ; vector < vector < long long > > dist ( V , vector < long long > ( V , INF ) ) ; vector < vector < long long > > prev ( V ) ; for ( int i = 0 ; i < V ; ++ i ) { dist [ i ] [ i ] = 0 ; prev [ i ] = vector < long long > ( V , i ) ; } for ( int i = 0 ; i < E ; i ++ ) { long long s , t , c ; cin > > s > > t > > c ; dist [ s ] [ t ] = c ; } warshall_floyd ( dist , prev ) ; if ( is_negative ( dist ) ) { cout << "NEGATIVE CYCLE" << endl ; } else { for ( int i = 0 ; i < V ; i ++ ) { for ( int j = 0 ; j < V ; j ++ ) { if ( dist [ i ] [ j ] >= INF / 2 ) { cout << "INF" ; } else { cout << dist [ i ] [ j ] ; } if ( j ! = V - 1 ) { cout << " " ; } } cout << endl ; } } return 0 ; }<CODESPLIT>5.664844036102295<CODESPLIT>-1.1706297397613525<CODESPLIT>-1.0350604057312012<CODESPLIT>-1.1091190576553345<CODESPLIT>-1.2348097562789917<CODESPLIT>-1.2809141874313354
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include<iostream> #include<cstdio> #include<vector> #define INF 99999999999999999 #define ll long long using namespace std ; struct edge { int from ; int to ; int cost ; } ; const int MAX_N = 100 ; const int MAX_M = 10000 ; ll d [ MAX_N ] [ MAX_N ] ; edge es [ MAX_M ] ; bool flag ; void shortest_path ( int n , int m , int s ) { int cnt = 0 ; d [ s ] [ s ] = 0 ; while ( true && cnt < n ) { bool update = false ; for ( int i = 0 ; i < m ; i ++ ) { edge e = es [ i ] ; if ( d [ s ] [ e . from ] ! = INF && d [ s ] [ e . to ] > d [ s ] [ e . from ] + e . cost ) { d [ s ] [ e . to ] = d [ s ] [ e . from ] + e . cost ; update = true ; } } if ( ! update ) break ; cnt ++ ; } if ( cnt == n ) { flag = true ; } } int main ( ) { int i , n , m , s ; cin > > n ; cin > > m ; for ( int i = 0 ; i < m ; i ++ ) { scanf ( "%d" , & es [ i ] . from ) ; scanf ( "%d" , & es [ i ] . to ) ; scanf ( "%d" , & es [ i ] . cost ) ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { d [ i ] [ j ] = INF ; } } flag = false ; for ( int i = 0 ; i < n ; i ++ ) { shortest_path ( n , m , i ) ; if ( flag ) { break ; } } if ( ! flag ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n - 1 ; j ++ ) { if ( d [ i ] [ j ] == INF ) { cout << "INF " ; } else { cout << d [ i ] [ j ] << " " ; } } if ( d [ i ] [ n - 1 ] == INF ) { cout << "INF" ; } else { cout << d [ i ] [ n - 1 ] ; } cout << "\n" ; } } else { cout << "NEGATIVE CYCLE\n" ; } }<CODESPLIT>5.661792278289795<CODESPLIT>-1.0528626441955566<CODESPLIT>-1.0210858583450317<CODESPLIT>-1.1549170017242432<CODESPLIT>-1.2445991039276123<CODESPLIT>-1.2517739534378052
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include "bits/stdc++.h" #include <unordered_set> #define _CRT_SECURE_NO_WARNINGS #define REP(i, n) for(decltype(n) i = 0; i < (n); i++) #define REP2(i, x, n) for(decltype(x) i = (x); i < (n); i++) #define REP3(i, x, n) for(decltype(x) i = (x); i <= (n); i++) #define RREP(i, n) for (decltype(n) i = (n) - 1; i >= 0; i--) #define ALL(a) (a).begin(),(a).end() #define SORT(c) sort((c).begin(),(c).end()) #define DESCSORT(c) sort(c.begin(), c.end(), greater<int>()) using namespace std ; const int dx [ 4 ] = { 1 , 0 , - 1 , 0 } ; const int dy [ 4 ] = { 0 , 1 , 0 , - 1 } ; using LL = long long int ; using LD = long double ; const int INF = ( 1 << 30 ) - 1 ; const LL INF64 = ( ( LL ) 1 << 62 ) - 1 ; const double PI = 3.1415926535897932384626433832795 ; using pii = pair < int , int > ; using pll = pair < LL , LL > ; using pdd = pair < double , double > ; using vi = vector < int > ; using vvi = vector < vi > ; using vvvi = vector < vvi > ; using vl = vector < LL > ; using vvl = vector < vl > ; using vvvl = vector < vvl > ; using vd = vector < double > ; using vs = vector < string > ; using vb = vector < bool > ; int n , e ; vvl M ; void warshallFloyd ( ) { REP ( k , n ) { REP ( i , n ) { if ( M [ i ] [ k ] == INF64 ) continue ; REP ( j , n ) { if ( M [ k ] [ j ] == INF64 ) continue ; M [ i ] [ j ] = min ( M [ i ] [ j ] , M [ i ] [ k ] + M [ k ] [ j ] ) ; } } } } void print ( ) { REP ( i , n ) { if ( M [ i ] [ i ] < 0 ) { cout << "NEGATIVE CYCLE" << "\n" ; return ; } } REP ( i , n ) { REP ( j , n ) { if ( j ) cout << " " ; if ( M [ i ] [ j ] == INF64 ) cout << "INF" ; else cout << M [ i ] [ j ] ; } cout << "\n" ; } } void solve ( ) { warshallFloyd ( ) ; print ( ) ; } int main ( ) { ios :: sync_with_stdio ( false ) ; cin . tie ( 0 ) ; cin > > n > > e ; M . resize ( n , vl ( n , INF64 ) ) ; REP ( i , n ) M [ i ] [ i ] = 0 ; LL s , t , d ; REP ( i , e ) { cin > > s > > t > > d ; M [ s ] [ t ] = d ; } solve ( ) ; return 0 ; }<CODESPLIT>5.658583164215088<CODESPLIT>-1.1143134832382202<CODESPLIT>-1.0308711528778076<CODESPLIT>-1.1567778587341309<CODESPLIT>-1.2272818088531494<CODESPLIT>-1.2506927251815796
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> using namespace std ; using vi = vector < int > ; using vvi = vector < vi > ; using vvvi = vector < vvi > ; using ll = long long int ; using vll = vector < ll > ; using vvll = vector < vll > ; using vvvll = vector < vvll > ; using vd = vector < double > ; using vvd = vector < vd > ; using vvvd = vector < vvd > ; using P = pair < int , int > ; using Pll = pair < ll , ll > ; using cdouble = complex < double > ; const double eps = 1e-7 ; #define Loop(i, n) for(int i = 0; i < int(n); i++) #define Loopll(i, n) for(ll i = 0; i < ll(n); i++) #define Loop1(i, n) for(int i = 1; i <= int(n); i++) #define Loopll1(i, n) for(ll i = 1; i <= ll(n); i++) #define Loopr(i, n) for(int i = int(n) - 1; i >= 0; i--) #define Looprll(i, n) for(ll i = ll(n) - 1; i >= 0; i--) #define Loopr1(i, n) for(int i = int(n); i >= 1; i--) #define Looprll1(i, n) for(ll i = ll(n); i >= 1; i--) #define Foreach(buf, container) for(auto buf : container) #define Loopdiag(i, j, h, w, sum) for(int i = ((sum) >= (h) ? (h) - 1 : (sum)), j = (sum) - i; i >= 0 && j < (w); i--, j++) #define Loopdiagr(i, j, h, w, sum) for(int j = ((sum) >= (w) ? (w) - 1 : (sum)), i = (sum) - j; j >= 0 && i < (h); j--, i++) #define Loopdiagsym(i, j, h, w, gap) for (int i = ((gap) >= 0 ? (gap) : 0), j = i - (gap); i < (h) && j < (w); i++, j++) #define Loopdiagsymr(i, j, h, w, gap) for (int i = ((gap) > (h) - (w) - 1 ? (h) - 1 : (w) - 1 + (gap)), j = i - (gap); i >= 0 && j >= 0; i--, j--) #define Loopitr(itr, container) for(auto itr = container.begin(); itr != container.end(); itr++) #define printv(vector) Loop(ex_i, vector.size()) { cout << vector[ex_i] << " "; } cout << endl; #define printmx(matrix) Loop(ex_i, matrix.size()) { Loop(ex_j, matrix[ex_i].size()) { cout << matrix[ex_i][ex_j] << " "; } cout << endl; } #define quickio() ios::sync_with_stdio(false); cin.tie(0); #define bitmanip(m,val) static_cast<bitset<(int)m>>(val) #define Comp(type_t) bool operator<(const type_t &another) const #define fst first #define snd second #define INF INFINITY bool feq ( double x , double y ) { return abs ( x - y ) <= eps ; } bool inrange ( ll x , ll t ) { return x >= 0 && x < t ; } bool inrange ( vll xs , ll t ) { Foreach ( x , xs ) if ( ! ( x >= 0 && x < t ) ) return false ; return true ; } int ceillog2 ( ll x ) { int ret = 0 ; x -- ; while ( x > 0 ) { ret ++ ; x > >= 1 ; } return ret ; } ll rndf ( double x ) { return ( ll ) ( x + ( x >= 0 ? 0.5 : - 0.5 ) ) ; } ll floorsqrt ( ll x ) { ll m = ( ll ) sqrt ( ( double ) x ) ; return m + ( m * m <= x ? 0 : - 1 ) ; } ll ceilsqrt ( ll x ) { ll m = ( ll ) sqrt ( ( double ) x ) ; return m + ( x <= m * m ? 0 : 1 ) ; } ll rnddiv ( ll a , ll b ) { return ( a / b + ( a % b * 2 >= b ? 1 : 0 ) ) ; } ll ceildiv ( ll a , ll b ) { return ( a / b + ( a % b == 0 ? 0 : 1 ) ) ; } ll gcd ( ll m , ll n ) { if ( n == 0 ) return m ; else return gcd ( n , m % n ) ; } ll lcm ( ll m , ll n ) { return m * n / gcd ( m , n ) ; } class Warshallfloyd { private : int n ; bool negative_cycle ; vvll table ; public : Warshallfloyd ( const vvi & lst , const vvll & cst ) { n = lst . size ( ) ; table = vvll ( n , vll ( n , LLONG_MAX ) ) ; Loop ( i , n ) { Loop ( j , lst [ i ] . size ( ) ) { table [ i ] [ lst [ i ] [ j ] ] = cst [ i ] [ j ] ; } } Loop ( i , n ) table [ i ] [ i ] = 0 ; Loop ( k , n ) { Loop ( i , n ) { Loop ( j , n ) { if ( table [ i ] [ k ] == LLONG_MAX || table [ k ] [ j ] == LLONG_MAX ) continue ; table [ i ] [ j ] = min ( table [ i ] [ j ] , table [ i ] [ k ] + table [ k ] [ j ] ) ; } } } Loop ( i , n ) { if ( table [ i ] [ i ] < 0 ) { negative_cycle = true ; return ; } } negative_cycle = false ; return ; } vvll get_table ( ) { return table ; } bool is_negative_cycle ( ) { return negative_cycle ; } } ; int main ( ) { int n , m ; cin > > n > > m ; vvi lst ( n ) ; vvll cst ( n ) ; Loop ( i , m ) { int s , t ; ll c ; cin > > s > > t > > c ; lst [ s ] . push_back ( t ) ; cst [ s ] . push_back ( c ) ; } Warshallfloyd wf ( lst , cst ) ; if ( wf . is_negative_cycle ( ) ) { cout << "NEGATIVE CYCLE" << endl ; } else { vvll table = wf . get_table ( ) ; Loop ( i , n ) { Loop ( j , n ) { if ( j > 0 ) cout << " " ; if ( table [ i ] [ j ] == LLONG_MAX ) { cout << "INF" ; } else { cout << table [ i ] [ j ] ; } } cout << endl ; } } }<CODESPLIT>5.671528339385986<CODESPLIT>-1.2178875207901<CODESPLIT>-0.9903134703636169<CODESPLIT>-1.165949821472168<CODESPLIT>-1.2375794649124146<CODESPLIT>-1.228258490562439
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include <algorithm> #include <iostream> using namespace std ; const int MAX_V = 100 ; const long long INF = ( 1LL << 32 ) ; long D [ MAX_V ] [ MAX_V ] ; int V ; void wf ( ) { for ( int k = 0 ; k < V ; k ++ ) { for ( int i = 0 ; i < V ; i ++ ) { if ( D [ i ] [ k ] == INF ) continue ; for ( int j = 0 ; j < V ; j ++ ) { if ( D [ k ] [ j ] == INF ) continue ; D [ i ] [ j ] = min ( D [ i ] [ j ] , D [ i ] [ k ] + D [ k ] [ j ] ) ; } } } } int main ( ) { int e ; cin > > V > > e ; for ( int i = 0 ; i < V ; i ++ ) { for ( int j = 0 ; j < V ; j ++ ) { D [ i ] [ j ] = ( ( i == j ) ? 0 : INF ) ; } } for ( int i = 0 ; i < e ; i ++ ) { int s , t ; cin > > s > > t ; long d ; cin > > d ; D [ s ] [ t ] = d ; } wf ( ) ; bool negative = false ; for ( int i = 0 ; i < V ; i ++ ) { if ( D [ i ] [ i ] < 0 ) negative = true ; } if ( negative ) { cout << "NEGATIVE CYCLE" << endl ; return 0 ; } for ( int i = 0 ; i < V ; i ++ ) { for ( int j = 0 ; j < V ; j ++ ) { if ( j ) cout << ' ' ; if ( D [ i ] [ j ] == INF ) cout << "INF" ; else cout << D [ i ] [ j ] ; } cout << endl ; } return 0 ; }<CODESPLIT>5.687281608581543<CODESPLIT>-1.2035799026489258<CODESPLIT>-1.0233891010284424<CODESPLIT>-1.1073087453842163<CODESPLIT>-1.2195645570755005<CODESPLIT>-1.2575136423110962
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include <vector> #include <iostream> #include <stdio.h> #include <functional> #include <cassert> #define INF 2000000000000000 using namespace std ; int main ( ) { int v , e , s , t , d ; cin > > v > > e ; vector < vector < long long > > ans ( v , vector < long long > ( v , INF ) ) ; for ( int i = 0 ; i < e ; ++ i ) { cin > > s > > t > > d ; ans [ s ] [ t ] = d ; } for ( int i = 0 ; i < v ; ++ i ) { ans [ i ] [ i ] = 0 ; } for ( int k = 0 ; k < v ; ++ k ) { for ( int i = 0 ; i < v ; ++ i ) { for ( int j = 0 ; j < v ; ++ j ) { if ( ans [ i ] [ j ] > ans [ i ] [ k ] + ans [ k ] [ j ] && ans [ i ] [ k ] ! = INF && ans [ k ] [ j ] ! = INF ) { ans [ i ] [ j ] = ans [ i ] [ k ] + ans [ k ] [ j ] ; } } } } bool flag = false ; for ( int i = 0 ; i < v ; ++ i ) { if ( ans [ i ] [ i ] ! = 0 ) { flag = true ; } } if ( flag ) { cout << "NEGATIVE CYCLE" << endl ; } else { for ( int i = 0 ; i < v ; ++ i ) { for ( int j = 0 ; j < v - 1 ; ++ j ) { if ( ans [ i ] [ j ] ! = INF ) { cout << ans [ i ] [ j ] << " " ; } else { cout << "INF " ; } } if ( ans [ i ] [ v - 1 ] ! = INF ) { cout << ans [ i ] [ v - 1 ] << endl ; } else { cout << "INF" << endl ; } } } return 0 ; }<CODESPLIT>5.6945366859436035<CODESPLIT>-1.1191669702529907<CODESPLIT>-1.0329347848892212<CODESPLIT>-1.143996238708496<CODESPLIT>-1.2086459398269653<CODESPLIT>-1.2660619020462036
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> using namespace std ; using ll = long long ; const int mod = 1e9 + 7 ; const int inf = ( 1 << 30 ) - 1 ; const ll infll = ( 1LL << 61 ) - 1 ; template < typename T > struct edge { int src , to ; T cost ; edge ( int to , T cost ) : src ( - 1 ) , to ( to ) , cost ( cost ) { } edge ( int src , int to , T cost ) : src ( src ) , to ( to ) , cost ( cost ) { } edge & operator = ( const int & x ) { to = x ; return * this ; } operator int ( ) const { return to ; } } ; template < typename T > using Edges = vector < edge < T > > ; template < typename T > using WeightedGraph = vector < Edges < T > > ; template < typename T > using UnweightedGraph = vector < vector < T > > ; template < typename T > using Matrix = vector < vector < T > > ; template < typename T > void Warshall_Floyd ( Matrix < T > & g , T INF ) { int N = g . size ( ) ; for ( int k = 0 ; k < N ; k ++ ) { for ( int i = 0 ; i < N ; i ++ ) { for ( int j = 0 ; j < N ; j ++ ) { if ( g [ i ] [ k ] == INF || g [ k ] [ j ] == INF ) continue ; g [ i ] [ j ] = min ( g [ i ] [ j ] , g [ i ] [ k ] + g [ k ] [ j ] ) ; } } } } int main ( ) { int V , E ; scanf ( "%d %d" , & V , & E ) ; Matrix < int > mat ( V , vector < int > ( V , INT_MAX ) ) ; for ( int i = 0 ; i < V ; i ++ ) mat [ i ] [ i ] = 0 ; for ( int i = 0 ; i < E ; i ++ ) { int x , y , z ; scanf ( "%d %d %d" , & x , & y , & z ) ; mat [ x ] [ y ] = z ; } Warshall_Floyd ( mat , INT_MAX ) ; for ( int i = 0 ; i < V ; i ++ ) { if ( mat [ i ] [ i ] < 0 ) { puts ( "NEGATIVE CYCLE" ) ; return 0 ; } } for ( int i = 0 ; i < V ; i ++ ) { for ( int j = 0 ; j < V ; j ++ ) { if ( j > 0 ) putchar ( ' ' ) ; if ( mat [ i ] [ j ] == INT_MAX ) printf ( "INF" ) ; else printf ( "%d" , mat [ i ] [ j ] ) ; } putchar ( '\n' ) ; } }<CODESPLIT>5.642403602600098<CODESPLIT>-1.1488560438156128<CODESPLIT>-0.9525517225265503<CODESPLIT>-1.167844533920288<CODESPLIT>-1.230360746383667<CODESPLIT>-1.2004822492599487
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include <iostream> #include <algorithm> #include <vector> #include <climits> #define MAX 100 #define Infty 9999999999 using namespace std ; int n , e ; long long d [ MAX ] [ MAX ] ; void floyd ( ) { for ( int k = 0 ; k < n ; ++ k ) { for ( int i = 0 ; i < n ; ++ i ) { if ( d [ i ] [ k ] == Infty ) continue ; for ( int j = 0 ; j < n ; ++ j ) { if ( d [ k ] [ j ] == Infty ) continue ; d [ i ] [ j ] = min ( d [ i ] [ j ] , d [ i ] [ k ] + d [ k ] [ j ] ) ; } } } } int main ( ) { scanf ( "%d %d" , & n , & e ) ; int s , t , v ; for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) { d [ i ] [ j ] = ( ( i == j ) ? 0 : Infty ) ; } } for ( int k = 0 ; k < e ; ++ k ) { scanf ( "%d %d %d" , & s , & t , & v ) ; d [ s ] [ t ] = v ; } floyd ( ) ; bool negative = false ; for ( int l = 0 ; l < n ; ++ l ) { if ( d [ l ] [ l ] < 0 ) negative = true ; } if ( negative ) cout << "NEGATIVE CYCLE" << endl ; else { for ( int i = 0 ; i < n ; ++ i ) { for ( int j = 0 ; j < n ; ++ j ) { if ( j ) cout << " " ; if ( d [ i ] [ j ] == Infty ) cout << "INF" ; else cout << d [ i ] [ j ] ; } cout << endl ; } } return 0 ; }<CODESPLIT>5.686575412750244<CODESPLIT>-1.215863585472107<CODESPLIT>-1.0004868507385254<CODESPLIT>-1.1036332845687866<CODESPLIT>-1.2104047536849976<CODESPLIT>-1.2540398836135864
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> using namespace std ; #define ll long long int static const ll INF = ( 1LL << 32 ) ; static const int MAX = 100 ; ll n , d [ MAX ] [ MAX ] ; void warshall_floyd ( ) { for ( int k = 0 ; k < n ; k ++ ) { for ( int i = 0 ; i < n ; i ++ ) { if ( d [ i ] [ k ] == INF ) continue ; for ( int j = 0 ; j < n ; j ++ ) { if ( d [ k ] [ j ] == INF ) continue ; d [ i ] [ j ] = min ( d [ i ] [ j ] , d [ i ] [ k ] + d [ k ] [ j ] ) ; } } } } int main ( ) { int e ; cin > > n > > e ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { d [ i ] [ j ] = ( i == j ) ? 0 : INF ; } } for ( int i = 0 ; i < e ; i ++ ) { int s , t , c ; cin > > s > > t > > c ; d [ s ] [ t ] = c ; } warshall_floyd ( ) ; bool neg = false ; for ( int i = 0 ; i < n ; i ++ ) if ( d [ i ] [ i ] < 0 ) neg = true ; if ( neg ) cout << "NEGATIVE CYCLE" << endl ; else { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( j ) cout << " " ; if ( d [ i ] [ j ] == INF ) cout << "INF" ; else cout << d [ i ] [ j ] ; } cout << endl ; } } return 0 ; }<CODESPLIT>5.672947406768799<CODESPLIT>-1.2490254640579224<CODESPLIT>-1.0194556713104248<CODESPLIT>-1.0869269371032715<CODESPLIT>-1.2214747667312622<CODESPLIT>-1.2606738805770874
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include <iostream> #include <climits> #include <algorithm> using namespace std ; int main ( ) { long long dist [ 105 ] [ 105 ] ; for ( int i = 0 ; i < 105 ; ++ i ) { for ( int j = 0 ; j < 105 ; ++ j ) { dist [ i ] [ j ] = INT_MAX ; if ( i == j ) dist [ i ] [ j ] = 0 ; } } int v , e , s , t , d ; cin > > v > > e ; for ( int i = 0 ; i < e ; ++ i ) { cin > > s > > t > > d ; dist [ s ] [ t ] = d ; } for ( int k = 0 ; k < v ; ++ k ) { for ( int i = 0 ; i < v ; ++ i ) { for ( int j = 0 ; j < v ; ++ j ) { if ( dist [ i ] [ k ] ! = INT_MAX && dist [ k ] [ j ] ! = INT_MAX ) dist [ i ] [ j ] = min ( dist [ i ] [ j ] , dist [ i ] [ k ] + dist [ k ] [ j ] ) ; } } } for ( int i = 0 ; i < v ; ++ i ) { if ( dist [ i ] [ i ] < 0 ) { cout << "NEGATIVE CYCLE" << endl ; return 0 ; } } for ( int i = 0 ; i < v ; ++ i ) { for ( int j = 0 ; j < v ; ++ j ) { if ( dist [ i ] [ j ] == INT_MAX ) cout << "INF" << ( j ! = v - 1 ? " " : "" ) ; else cout << dist [ i ] [ j ] << ( j ! = v - 1 ? " " : "" ) ; } cout << endl ; } return 0 ; }<CODESPLIT>5.682653903961182<CODESPLIT>-1.200600504875183<CODESPLIT>-1.0468811988830566<CODESPLIT>-1.1327369213104248<CODESPLIT>-1.1911745071411133<CODESPLIT>-1.2493336200714111
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> using namespace std ; #define rep(i, l, n) for (int i = (int)(l); i < (int)(n); i++) #define drep(i, n) for (int i = (int)(n); i > 0; i--) #define INF (pow(10,12)) #define def (200007) #define MOD (1000000007) typedef vector < int > veci ; typedef vector < vector < int > > Veci ; typedef vector < int64_t > vecit ; typedef vector < vector < int64_t > > Vecit ; typedef int64_t intt ; typedef vector < vector < double > > Vecd ; typedef vector < double > vecd ; typedef pair < int , int > P ; int main ( ) { int V , E ; cin > > V > > E ; Vecit dp ( V , vecit ( V , INF ) ) ; rep ( i , 0 , E ) { int s , t , d ; cin > > s > > t > > d ; dp [ s ] [ t ] = d ; } rep ( k , 0 , V ) { rep ( i , 0 , V ) { rep ( j , 0 , V ) { if ( ! ( dp [ i ] [ k ] == INF || dp [ k ] [ j ] == INF ) ) { dp [ i ] [ j ] = min ( dp [ i ] [ k ] + dp [ k ] [ j ] , dp [ i ] [ j ] ) ; } } } } int judge = 0 ; rep ( i , 0 , V ) { if ( dp [ i ] [ i ] < 0 ) judge = 1 ; } if ( ! judge ) { rep ( i , 0 , V ) { rep ( j , 0 , V ) { if ( i == j && dp [ i ] [ j ] >= 0 ) cout << "0" ; else if ( dp [ i ] [ j ] == INF ) cout << "INF" ; else cout << dp [ i ] [ j ] ; if ( j ! = V - 1 ) cout << " " ; } cout << endl ; } } else cout << "NEGATIVE CYCLE" << endl ; return 0 ; }<CODESPLIT>5.6879472732543945<CODESPLIT>-0.9737821817398071<CODESPLIT>-1.037561058998108<CODESPLIT>-1.2360421419143677<CODESPLIT>-1.2740521430969238<CODESPLIT>-1.2916494607925415
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> int ri ( ) { int n ; scanf ( "%d" , & n ) ; return n ; } int64_t rs64 ( ) { int64_t n ; scanf ( "%" SCNd64 , & n ) ; return n ; } #define INF (10000000000LL) int main ( ) { int n = ri ( ) , m = ri ( ) ; std :: vector < std :: pair < int , int64_t > > hen [ n ] ; for ( int i = 0 ; i < m ; i ++ ) { int x = ri ( ) ; int y = ri ( ) ; int cost = ri ( ) ; hen [ x ] . push_back ( { y , cost } ) ; } auto bf = [ & ] ( int start ) { std :: vector < int64_t > dist ( n , 0 ) ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) for ( auto k : hen [ j ] ) if ( dist [ k . first ] > dist [ j ] + k . second ) { if ( i == n - 1 ) return std :: vector < int64_t > ( ) ; dist [ k . first ] = dist [ j ] + k . second ; } } return dist ; } ; auto solve = [ & ] ( ) { std :: vector < std :: vector < int64_t > > res ( n , std :: vector < int64_t > ( n , INF ) ) ; auto pot = bf ( 0 ) ; if ( ! pot . size ( ) ) return std :: vector < std :: vector < int64_t > > ( ) ; for ( int i = 0 ; i < n ; i ++ ) for ( auto & j : hen [ i ] ) j . second += pot [ i ] - pot [ j . first ] ; for ( int i = 0 ; i < n ; i ++ ) { using T = std :: pair < int64_t , int > ; std :: priority_queue < T , std :: vector < T > , std :: greater < T > > que ; que . push ( { res [ i ] [ i ] = 0 , i } ) ; while ( que . size ( ) ) { auto cur = que . top ( ) ; que . pop ( ) ; if ( cur . first ! = res [ i ] [ cur . second ] ) continue ; for ( auto j : hen [ cur . second ] ) { if ( res [ i ] [ j . first ] > cur . first + j . second ) { res [ i ] [ j . first ] = cur . first + j . second ; que . push ( { res [ i ] [ j . first ] , j . first } ) ; } } } for ( int j = 0 ; j < n ; j ++ ) { res [ i ] [ j ] -= pot [ i ] - pot [ j ] ; if ( res [ i ] [ j ] > INF / 2 ) res [ i ] [ j ] = INF ; } } return res ; } ; auto cor = solve ( ) ; if ( ! cor . size ( ) ) { std :: cout << "NEGATIVE CYCLE" << std :: endl ; return 0 ; } for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( j ) printf ( " " ) ; if ( cor [ i ] [ j ] == INF ) printf ( "INF" ) ; else printf ( "%lld" , ( long long ) cor [ i ] [ j ] ) ; } puts ( "" ) ; } return 0 ; }<CODESPLIT>5.686817646026611<CODESPLIT>-0.9944319128990173<CODESPLIT>-1.0392467975616455<CODESPLIT>-1.1870542764663696<CODESPLIT>-1.2541718482971191<CODESPLIT>-1.2741225957870483
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> #define rep(i, n) for (int i = 0; i < (int)(n); i++) #define repi(i, a, b) for (int i = int(a); i < int(b); ++i) typedef long long ll ; long long mod = 1e9 + 7 ; const long long INF = 0x3f3f3f3f3f3f3f3f ; using namespace std ; template < class T > inline bool chmin ( T & a , T b ) { if ( a > b ) { a = b ; return true ; } return false ; } template < class T > inline bool chmax ( T & a , T b ) { if ( a < b ) { a = b ; return true ; } return false ; } int main ( ) { int V , E ; cin > > V > > E ; ll d [ 110 ] [ 110 ] ; memset ( d , 0x3f , sizeof ( d ) ) ; rep ( i , V ) { rep ( j , V ) { d [ i ] [ j ] = INF ; } d [ i ] [ i ] = 0 ; } rep ( i , E ) { int s , t , dist ; cin > > s > > t > > dist ; d [ s ] [ t ] = dist ; } rep ( k , V ) rep ( i , V ) rep ( j , V ) { if ( d [ i ] [ k ] ! = INF && d [ k ] [ j ] ! = INF ) d [ i ] [ j ] = min ( d [ i ] [ j ] , d [ i ] [ k ] + d [ k ] [ j ] ) ; } rep ( i , V ) { rep ( j , V ) { if ( d [ i ] [ i ] ! = 0 ) { cout << "NEGATIVE CYCLE" << endl ; return 0 ; } } } rep ( i , V ) { rep ( j , V ) { if ( d [ i ] [ j ] >= INF ) cout << "INF" ; else if ( i == j ) cout << 0 ; else cout << d [ i ] [ j ] ; if ( j ! = V - 1 ) cout << " " ; } cout << endl ; } return 0 ; }<CODESPLIT>5.677327632904053<CODESPLIT>-0.8346661925315857<CODESPLIT>-1.074273705482483<CODESPLIT>-1.2410805225372314<CODESPLIT>-1.2731903791427612<CODESPLIT>-1.304813265800476
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include <algorithm> #include <array> #include <bitset> #include <cmath> #include <cstdlib> #include <functional> #include <iomanip> #include <iostream> #include <list> #include <map> #include <memory> #include <numeric> #include <queue> #include <set> #include <stack> #include <string> #include <vector> using namespace std ; using ll = long long ; const ll INF = numeric_limits < ll > :: max ( ) / 100 ; vector < vector < ll > > cost ; bool WarshallFloyd ( int V ) { for ( int k = 0 ; k < V ; ++ k ) { for ( int i = 0 ; i < V ; ++ i ) { for ( int j = 0 ; j < V ; ++ j ) { if ( cost [ i ] [ k ] ! = INF and cost [ k ] [ j ] ! = INF ) cost [ i ] [ j ] = min ( cost [ i ] [ j ] , cost [ i ] [ k ] + cost [ k ] [ j ] ) ; } } } for ( int i = 0 ; i < V ; ++ i ) { if ( cost [ i ] [ i ] < 0 ) { return true ; } } return false ; } int main ( ) { int V , E ; cin > > V > > E ; cost . assign ( V , vector < ll > ( V , INF ) ) ; for ( int i = 0 ; i < V ; ++ i ) { cost [ i ] [ i ] = 0 ; } for ( int i = 0 ; i < E ; ++ i ) { int u , v ; ll c ; cin > > u > > v > > c ; cost [ u ] [ v ] = min ( cost [ u ] [ v ] , c ) ; } bool flag = WarshallFloyd ( V ) ; if ( flag ) { cout << "NEGATIVE CYCLE" << endl ; } else { for ( int i = 0 ; i < V ; ++ i ) { for ( int j = 0 ; j < V ; ++ j ) { if ( cost [ i ] [ j ] == INF ) { cout << "INF" ; } else { cout << cost [ i ] [ j ] ; } if ( j < V - 1 ) { cout << " " ; } } cout << endl ; } } }<CODESPLIT>5.68245792388916<CODESPLIT>-1.0563602447509766<CODESPLIT>-0.9947507977485657<CODESPLIT>-1.1463600397109985<CODESPLIT>-1.2230380773544312<CODESPLIT>-1.263070821762085
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> #define rep(i,n) for (int i = 0; i < (n); ++i) using namespace std ; using ll = long long ; using P = pair < int , int > ; const ll INF = 1001001001001001001 ; int main ( ) { int v , e ; cin > > v > > e ; ll G [ v ] [ v ] ; rep ( i , v ) rep ( j , v ) G [ i ] [ j ] = INF ; vector < vector < int > > to ( v ) ; vector < vector < ll > > weight ( v ) ; rep ( i , v ) rep ( j , v ) { if ( i == j ) G [ i ] [ j ] = 0 ; else G [ i ] [ j ] = INF ; } rep ( i , e ) { int s , t ; ll d ; cin > > s > > t > > d ; to [ s ] . push_back ( t ) ; weight [ s ] . push_back ( d ) ; G [ s ] [ t ] = d ; } for ( int i = 0 ; i < v ; ++ i ) { rep ( k , to [ i ] . size ( ) ) { int temp = to [ i ] [ k ] ; if ( temp > i ) continue ; for ( int j = 0 ; j < i ; ++ j ) { G [ i ] [ j ] = min ( G [ i ] [ j ] , G [ i ] [ temp ] + G [ temp ] [ j ] ) ; } } rep ( j , v ) { rep ( k , v ) { G [ j ] [ k ] = min ( G [ j ] [ k ] , G [ j ] [ i ] + G [ i ] [ k ] ) ; } } } rep ( i , v ) { if ( G [ i ] [ i ] < 0 ) { cout << "NEGATIVE CYCLE" << endl ; return 0 ; } } rep ( i , v ) { rep ( j , v ) { if ( G [ i ] [ j ] > ( INF - 100100100100100 ) ) cout << "INF" ; else cout << G [ i ] [ j ] ; if ( j ! = v - 1 ) cout << " " ; else cout << endl ; } } }<CODESPLIT>5.688045978546143<CODESPLIT>-1.198685884475708<CODESPLIT>-1.0468857288360596<CODESPLIT>-1.1428139209747314<CODESPLIT>-1.2139371633529663<CODESPLIT>-1.257649540901184
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> #define rep(i, start, end) for (long long i = start; i < end; ++i) #define srt(x) sort((x).begin(), (x).end()); #define rsrt(x) sort((x).rbegin(), (x).rend()); #define deb(x) cout<<#x<<" = "<<(x)<<" (L"<<LINE<<")"<<endl; #define vdeb(x) {cout<<#x<<" = { "; rep(i, x.size()) cout<<x[i]<<' '; cout <<'}'<<" (L"<<LINE<<")"<<endl;} using namespace std ; using ll = long long ; using ld = long double ; using vi = vector < int > ; using vivi = vector < vi > ; using vll = vector < long long > ; using vllvll = vector < vll > ; using vs = vector < string > ; using um = unordered_map < long long , long long > ; const long long INF = 1LL << 60 ; const long long MOD = 1e9 + 7 ; int main ( ) { ll V , E ; cin > > V > > E ; vllvll M ( V , vll ( V , INF ) ) ; ll s , t , d ; rep ( i , 0 , E ) { cin > > s > > t > > d ; M [ s ] [ t ] = d ; } rep ( i , 0 , V ) { M [ i ] [ i ] = 0 ; } rep ( k , 0 , V ) { rep ( i , 0 , V ) { rep ( j , 0 , V ) { M [ i ] [ j ] = min ( M [ i ] [ j ] , M [ i ] [ k ] + M [ k ] [ j ] ) ; } } } rep ( i , 0 , V ) { if ( M [ i ] [ i ] < 0 ) { cout << "NEGATIVE CYCLE" << endl ; return 0 ; } } rep ( i , 0 , V ) { rep ( j , 0 , V ) { if ( M [ i ] [ j ] >= 1LL << 59 ) cout << "INF" ; else cout << M [ i ] [ j ] ; if ( j ! = V - 1 ) cout << ' ' ; } cout << endl ; } }<CODESPLIT>5.67609977722168<CODESPLIT>-1.2505093812942505<CODESPLIT>-0.9662505388259888<CODESPLIT>-1.1259275674819946<CODESPLIT>-1.1929347515106201<CODESPLIT>-1.1563713550567627
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include <iostream> #include <vector> #include <queue> #include <algorithm> using namespace std ; #define rep(i, n)for(int i=0; i<n; i++) long long INF = 100000000000000000 ; int main ( ) { int V , E ; cin > > V > > E ; vector < vector < int > > G ( V ) ; long long dist [ V ] [ V ] ; rep ( i , V ) rep ( j , V ) { if ( i == j ) dist [ i ] [ j ] = 0 ; else dist [ i ] [ j ] = INF ; } int s , t ; rep ( i , E ) { cin > > s > > t ; G [ s ] . push_back ( t ) ; cin > > dist [ s ] [ t ] ; } rep ( k , V ) { rep ( i , V ) { rep ( j , V ) { if ( dist [ i ] [ k ] == INF || dist [ k ] [ j ] == INF ) continue ; else dist [ i ] [ j ] = min ( dist [ i ] [ j ] , dist [ i ] [ k ] + dist [ k ] [ j ] ) ; } } } rep ( i , V ) { if ( dist [ i ] [ i ] < 0 ) { cout << "NEGATIVE CYCLE" << endl ; return 0 ; } } rep ( i , V ) { rep ( j , V ) { if ( dist [ i ] [ j ] == INF ) cout << "INF" ; else cout << dist [ i ] [ j ] ; if ( j < V - 1 ) cout << " " ; } cout << endl ; } return 0 ; }<CODESPLIT>5.7067484855651855<CODESPLIT>-1.11654794216156<CODESPLIT>-1.051500916481018<CODESPLIT>-1.152433156967163<CODESPLIT>-1.2322520017623901<CODESPLIT>-1.2825487852096558
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> #include <cmath> using namespace std ; typedef long long ll ; #define rep(i, n) for (int i = 0; i < (n); ++i) typedef pair < ll , ll > P ; const ll INF = LONG_LONG_MAX / 100 ; const ll MINF = LONG_LONG_MIN ; #define cmin(x, y) x = min(x, y) #define cmax(x, y) x = max(x, y) bool contain ( set < P > & s , P a ) { return s . find ( a ) ! = s . end ( ) ; } const int mod = 1000000007 ; void print_line ( vector < string > & line ) { if ( line . size ( ) == 0ll ) { cout << endl ; return ; } for ( ll i = 0 ; i < line . size ( ) ; i ++ ) { cout << line [ i ] ; if ( i == line . size ( ) - 1 ) cout << endl ; else cout << ' ' ; } } typedef priority_queue < long long , vector < long long > , greater < long long > > PQ_ASK ; struct Edge { ll to , cost ; } ; class Dijkstra { ll vector_count ; vector < ll > distances ; public : vector < vector < Edge > > edges ; Dijkstra ( ll n ) { vector_count = n ; distances . resize ( n , INF ) ; edges . resize ( n ) ; } void insertTowWay ( ll from , ll to , ll cost ) { edges [ from ] . push_back ( { to , cost } ) ; edges [ to ] . push_back ( { from , cost } ) ; } void insert ( ll from , ll to , ll cost ) { edges [ from ] . push_back ( { to , cost } ) ; } void dijkstra ( ll k ) { distances [ k ] = 0 ; priority_queue < P , vector < P > , greater < P > > que ; que . push ( P ( 0 , k ) ) ; while ( ! que . empty ( ) ) { P p = que . top ( ) ; que . pop ( ) ; int v = p . second ; if ( distances [ v ] < p . first ) { continue ; } for ( auto e : edges [ v ] ) { if ( distances [ e . to ] > distances [ v ] + e . cost ) { distances [ e . to ] = distances [ v ] + e . cost ; que . push ( P ( distances [ e . to ] , e . to ) ) ; } } } } ll distance ( ll to ) { return distances [ to ] ; } } ; ; void warshall_floyd ( int n , vector < vector < ll > > & distances ) { for ( int k = 0 ; k < n ; k ++ ) { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( distances [ i ] [ j ] == INF && ( distances [ i ] [ k ] == INF || distances [ k ] [ j ] == INF ) ) { distances [ i ] [ j ] = INF ; } else { distances [ i ] [ j ] = min ( distances [ i ] [ j ] , distances [ i ] [ k ] + distances [ k ] [ j ] ) ; } } } } } string to_string2 ( ll n ) { std :: ostringstream stm ; stm << n ; return stm . str ( ) ; } int main ( ) { int v , e ; cin > > v > > e ; vector < vector < ll > > distances ( v , vector < ll > ( v , INF ) ) ; rep ( i , v ) distances [ i ] [ i ] = 0 ; rep ( i , e ) { ll s , t , d ; cin > > s > > t > > d ; distances [ s ] [ t ] = d ; } warshall_floyd ( v , distances ) ; { vector < vector < ll > > check = distances ; warshall_floyd ( v , check ) ; if ( check ! = distances ) { cout << "NEGATIVE CYCLE" << endl ; return 0 ; } } rep ( i , v ) { vector < string > ans ; rep ( j , v ) { ll now = distances [ i ] [ j ] ; if ( now >= INF ) ans . push_back ( "INF" ) ; else ans . push_back ( to_string2 ( now ) ) ; } print_line ( ans ) ; } }<CODESPLIT>5.694077491760254<CODESPLIT>-1.0210565328598022<CODESPLIT>-1.025001049041748<CODESPLIT>-1.1867215633392334<CODESPLIT>-1.281495213508606<CODESPLIT>-1.2500461339950562
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include <algorithm> #include <vector> #include <iostream> template < typename T > struct edge { int to ; T cost ; } ; template < typename T > std :: vector < std :: vector < T > > warshallFloyd ( const int size , const std :: vector < std :: vector < edge < T > > > & g , const T init ) { std :: vector < std :: vector < T > > d ( size ) ; for ( int i = 0 ; i < size ; i ++ ) { for ( int j = 0 ; j < size ; j ++ ) { if ( i == j ) { d [ i ] . push_back ( 0 ) ; } else { d [ i ] . push_back ( init ) ; } } } for ( int i = 0 ; i < size ; i ++ ) { for ( const auto & e : g [ i ] ) { d [ i ] [ e . to ] = e . cost ; } } for ( int k = 0 ; k < size ; k ++ ) { for ( int i = 0 ; i < size ; i ++ ) { for ( int j = 0 ; j < size ; j ++ ) { if ( d [ i ] [ k ] ! = init && d [ k ] [ j ] ! = init ) d [ i ] [ j ] = std :: min ( d [ i ] [ j ] , d [ i ] [ k ] + d [ k ] [ j ] ) ; } } } return d ; } int main ( ) { int v , e ; std :: cin > > v > > e ; std :: vector < std :: vector < edge < long long int > > > g ( v ) ; for ( int i = 0 ; i < e ; i ++ ) { int a , b ; long long int c ; std :: cin > > a > > b > > c ; g [ a ] . push_back ( { b , c } ) ; } long long int MAX = 200000000001 ; auto d = warshallFloyd ( v , g , MAX ) ; bool negative_cycle = false ; for ( int i = 0 ; i < v ; i ++ ) { if ( d [ i ] [ i ] < 0LL ) { negative_cycle = true ; break ; } } if ( negative_cycle ) { std :: cout << "NEGATIVE CYCLE" << std :: endl ; } else { for ( int i = 0 ; i < v ; i ++ ) { for ( int j = 0 ; j < v ; j ++ ) { if ( d [ i ] [ j ] == MAX ) { std :: cout << "INF" ; } else { std :: cout << d [ i ] [ j ] ; } std :: cout << ( j ! = v - 1 ? " " : "\n" ) ; } } } }<CODESPLIT>5.676596164703369<CODESPLIT>-1.0384232997894287<CODESPLIT>-1.0514185428619385<CODESPLIT>-1.157097578048706<CODESPLIT>-1.24994957447052<CODESPLIT>-1.270713210105896
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> using namespace std ; struct cww { cww ( ) { ios :: sync_with_stdio ( false ) ; cin . tie ( 0 ) ; } } star ; #define P(x) cout << (x) << "\n" #define p(x) cout << (x) #define all(c) (c).begin(), (c).end() #define rall(c) (c).rbegin(), (c).rend() #define vv(type, c, m, n, i) vector<vector<type>> c(m, vector<type>(n, i)); #define rep(i,a,n) for(int i=(a), i##_len=(n); i<i##_len; ++i) #define rrep(i,a,n) for(int i=(a), i##_len=(n); i>i##_len; --i) #define len(x) ((int)(x).size()) #define mp make_pair #define eb emplace_back typedef long long ll ; typedef vector < int > vi ; typedef vector < double > vd ; typedef vector < long long > vll ; typedef vector < string > vs ; typedef vector < bool > vb ; const constexpr int MAX = 100 ; const constexpr ll INF = 1LL << 32 ; int n ; vv ( ll , d , MAX , MAX , INF ) ; inline void floyd ( ) { rep ( k , 0 , n ) { rep ( i , 0 , n ) { if ( d [ i ] [ k ] == INF ) continue ; rep ( j , 0 , n ) { if ( d [ k ] [ j ] == INF ) continue ; d [ i ] [ j ] = min ( d [ i ] [ j ] , d [ i ] [ k ] + d [ k ] [ j ] ) ; } } } } int main ( ) { int e ; cin > > n > > e ; rep ( i , 0 , n ) d [ i ] [ i ] = 0LL ; int u , v , c ; rep ( i , 0 , e ) { cin > > u > > v > > c ; d [ u ] [ v ] = c ; } floyd ( ) ; rep ( i , 0 , n ) if ( d [ i ] [ i ] < 0 ) { P ( "NEGATIVE CYCLE" ) ; return 0 ; } rep ( i , 0 , n ) { rep ( j , 0 , n ) { if ( d [ i ] [ j ] == INF ) p ( "INF" ) ; else p ( d [ i ] [ j ] ) ; p ( j + 1 == n ? "\n" : " " ) ; } } return 0 ; }<CODESPLIT>5.66243314743042<CODESPLIT>-1.0560024976730347<CODESPLIT>-1.027653694152832<CODESPLIT>-1.1796183586120605<CODESPLIT>-1.2825093269348145<CODESPLIT>-1.2449856996536255
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include <cstdio> #include <algorithm> #include <string> #include <cmath> #include <cstring> #include <vector> #include <numeric> #include <iostream> #include <random> #include <map> #include <unordered_map> #include <queue> #include <regex> #include <functional> #include <complex> #include <list> #include <cassert> #include <iomanip> #include <set> #include <stack> #include <bitset> #define rep(i, n) for(int i = 0; i < (n); ++i) #define rep1(i, n) for(int i = 1; i <= (n); ++i) #define rep2(i, n) for(int i = 2; i < (n); ++i) #define repr(i, n) for(int i = n; i >= 0; --i) #define reprm(i, n) for(int i = n - 1; i >= 0; --i) #define printynl(a) printf(a ? "yes\n" : "no\n") #define printyn(a) printf(a ? "Yes\n" : "No\n") #define printYN(a) printf(a ? "YES\n" : "NO\n") #define printim(a) printf(a ? "possible\n" : "imposible\n") #define printdb(a) printf("%.50lf\n", a)  #define printLdb(a) printf("%.50Lf\n", a)  #define printdbd(a) printf("%.16lf\n", a)  #define prints(s) printf("%s\n", s.c_str())  #define all(x) (x).begin(), (x).end() #define allsum(a, b, c) ((a + b) * c / 2LL)  #define pb push_back #define rpriq priq<int, vector<int>, greater<int>> #define deg_to_rad(deg) (((deg)/360.0L)*2.0L*PI) #define rad_to_deg(rad) (((rad)/2.0L/PI)*360.0L) #define Please return #define AC 0 #define manhattan_dist(a, b, c, d) (abs(a - c) + abs(b - d))  #define inf numeric_limits<double>::infinity(); #define linf numeric_limits<long double>::infinity() using ll = long long ; constexpr int INF = 1073741823 ; constexpr int MINF = - 1073741823 ; constexpr ll LINF = ll ( 4661686018427387903 ) ; constexpr ll MOD = 1000000007 ; constexpr long double eps = 1e-9 ; const long double PI = acosl ( - 1.0L ) ; using namespace std ; void scans ( string & str ) { char c ; str = "" ; scanf ( "%c" , & c ) ; if ( c == '\n' ) scanf ( "%c" , & c ) ; while ( c ! = '\n' && c ! = - 1 && c ! = ' ' ) { str += c ; scanf ( "%c" , & c ) ; } } void scanc ( char & str ) { char c ; scanf ( "%c" , & c ) ; if ( c == - 1 ) return ; while ( c == '\n' ) { scanf ( "%c" , & c ) ; } str = c ; } double acot ( double x ) { return PI / 2 - atan ( x ) ; } ll LSB ( ll n ) { return ( n & ( - n ) ) ; } void WarshallFloyd ( int n , vector < vector < ll > > & d ) { rep ( i , n ) { rep ( j , n ) { rep ( k , n ) { d [ j ] [ k ] = min ( d [ j ] [ k ] , d [ j ] [ i ] + d [ i ] [ k ] ) ; } } } } int main ( ) { int v , e ; scanf ( "%d%d" , & v , & e ) ; vector < vector < ll > > g ( v , vector < ll > ( v ) ) ; rep ( i , v ) fill ( all ( g [ i ] ) , LINF / 2 ) ; rep ( i , v ) g [ i ] [ i ] = 0 ; while ( e -- ) { int s , t , d ; scanf ( "%d%d%d" , & s , & t , & d ) ; g [ s ] [ t ] = d ; } WarshallFloyd ( v , g ) ; rep ( i , v ) { if ( g [ i ] [ i ] < 0 ) { puts ( "NEGATIVE CYCLE" ) ; Please AC ; } } rep ( i , v ) { rep ( j , v ) { if ( g [ i ] [ j ] >= LINF / 4 ) printf ( "INF" ) ; else printf ( "%lld" , g [ i ] [ j ] ) ; if ( j ! = v - 1 ) printf ( " " ) ; else puts ( "" ) ; } } Please AC ; }<CODESPLIT>5.6487579345703125<CODESPLIT>-1.003250241279602<CODESPLIT>-1.0209779739379883<CODESPLIT>-1.159003496170044<CODESPLIT>-1.2180758714675903<CODESPLIT>-1.2897847890853882
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include <iostream> #include <algorithm> using namespace std ; #define INF 10000000000000000 #define N 100 long long A [ N ] [ N ] ; void warshallfloyd ( int n ) { for ( int k = 0 ; k < n ; k ++ ) { for ( int i = 0 ; i < n ; i ++ ) { if ( A [ i ] [ k ] == INF ) continue ; for ( int j = 0 ; j < n ; j ++ ) { if ( A [ k ] [ j ] == INF ) continue ; A [ i ] [ j ] = min ( A [ i ] [ j ] , A [ i ] [ k ] + A [ k ] [ j ] ) ; } } } } int main ( ) { int n , e ; cin > > n > > e ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( i == j ) A [ i ] [ j ] = 0 ; else A [ i ] [ j ] = INF ; } } int node1 , node2 ; long long w ; for ( int i = 0 ; i < e ; i ++ ) { cin > > node1 > > node2 > > w ; A [ node1 ] [ node2 ] = w ; } warshallfloyd ( n ) ; bool negative = false ; for ( int i = 0 ; i < n ; i ++ ) { if ( A [ i ] [ i ] < 0 ) { negative = true ; break ; } } if ( negative ) { cout << "NEGATIVE CYCLE" << endl ; } else { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( j ! = 0 ) cout << " " ; if ( A [ i ] [ j ] == INF ) cout << "INF" ; else cout << A [ i ] [ j ] ; } cout << endl ; } } return 0 ; }<CODESPLIT>5.6818413734436035<CODESPLIT>-1.1705259084701538<CODESPLIT>-1.0228700637817383<CODESPLIT>-1.1019296646118164<CODESPLIT>-1.2244200706481934<CODESPLIT>-1.2639079093933105
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include<bits/stdc++.h> using namespace std ; static const int MAX = 100 ; static const long long INFTY = ( 1LL << 32 ) ; int V ; long long d [ MAX ] [ MAX ] ; void floyd ( ) { for ( int k = 0 ; k < V ; k ++ ) { for ( int i = 0 ; i < V ; i ++ ) { if ( d [ i ] [ k ] == INFTY ) continue ; for ( int j = 0 ; j < V ; j ++ ) { if ( d [ k ] [ j ] == INFTY ) continue ; d [ i ] [ j ] = min ( d [ i ] [ j ] , d [ i ] [ k ] + d [ k ] [ j ] ) ; } } } } int main ( ) { int E , s , t , cost ; cin > > V > > E ; for ( int i = 0 ; i < V ; i ++ ) { for ( int j = 0 ; j < V ; j ++ ) { d [ i ] [ j ] = ( ( i == j ) ? 0 : INFTY ) ; } } for ( int i = 0 ; i < E ; i ++ ) { cin > > s > > t > > cost ; d [ s ] [ t ] = cost ; } floyd ( ) ; bool negative = false ; for ( int i = 0 ; i < V ; i ++ ) if ( d [ i ] [ i ] < 0 ) negative = true ; if ( negative ) { cout << "NEGATIVE CYCLE" << endl ; } else { for ( int i = 0 ; i < V ; i ++ ) { for ( int j = 0 ; j < V ; j ++ ) { if ( j ) cout << " " ; if ( d [ i ] [ j ] == INFTY ) cout << "INF" ; else cout << d [ i ] [ j ] ; } cout << endl ; } } return 0 ; }<CODESPLIT>5.673830032348633<CODESPLIT>-1.2262684106826782<CODESPLIT>-1.0265321731567383<CODESPLIT>-1.0941259860992432<CODESPLIT>-1.2212260961532593<CODESPLIT>-1.2624692916870117
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include <stdio.h> #include <vector> #include <algorithm> #include <stack> #define INFINITY 2000000000 using namespace std ; int main ( ) { int V , E , from , to , dist ; scanf ( "%d %d" , & V , & E ) ; long long int table [ V ] [ V ] ; for ( int i = 0 ; i < V ; i ++ ) { for ( int k = 0 ; k < V ; k ++ ) { if ( i ! = k ) { table [ i ] [ k ] = INFINITY ; } else { table [ i ] [ k ] = 0 ; } } } for ( int i = 0 ; i < E ; i ++ ) { scanf ( "%d %d %d" , & from , & to , & dist ) ; table [ from ] [ to ] = dist ; } for ( int k = 0 ; k < V ; k ++ ) { for ( int i = 0 ; i < V ; i ++ ) { if ( table [ i ] [ k ] == INFINITY ) continue ; for ( int j = 0 ; j < V ; j ++ ) { if ( table [ k ] [ j ] == INFINITY ) continue ; table [ i ] [ j ] = min ( table [ i ] [ j ] , table [ i ] [ k ] + table [ k ] [ j ] ) ; } } } bool FLG = true ; for ( int i = 0 ; i < V ; i ++ ) { if ( table [ i ] [ i ] < 0 ) { FLG = false ; break ; } } if ( ! FLG ) printf ( "NEGATIVE CYCLE\n" ) ; else { for ( int i = 0 ; i < V ; i ++ ) { if ( table [ i ] [ 0 ] == INFINITY ) printf ( "INF" ) ; else { printf ( "%lld" , table [ i ] [ 0 ] ) ; } for ( int k = 1 ; k < V ; k ++ ) { if ( table [ i ] [ k ] == INFINITY ) printf ( " INF" ) ; else { printf ( " %lld" , table [ i ] [ k ] ) ; } } printf ( "\n" ) ; } } return 0 ; }<CODESPLIT>5.658968448638916<CODESPLIT>-1.046523928642273<CODESPLIT>-1.0500915050506592<CODESPLIT>-1.1240825653076172<CODESPLIT>-1.2606302499771118<CODESPLIT>-1.3042434453964233
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> using namespace std ; #define rep(i,n) for(int i=0; i<(n); i++) using ll = long long ; using P = pair < int , int > ; static const int MAX = 100 ; static const long long INFTY = ( 1LL << 32 ) ; int n ; long long d [ MAX ] [ MAX ] ; void floyd ( ) { for ( int k = 0 ; k < n ; k ++ ) { for ( int i = 0 ; i < n ; i ++ ) { if ( d [ i ] [ k ] == INFTY ) continue ; for ( int j = 0 ; j < n ; j ++ ) { if ( d [ k ] [ j ] == INFTY ) continue ; d [ i ] [ j ] = min ( d [ i ] [ j ] , d [ i ] [ k ] + d [ k ] [ j ] ) ; } } } } int main ( ) { int e , u , v , c ; cin > > n > > e ; for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { d [ i ] [ j ] = ( ( i == j ) ? 0 : INFTY ) ; } } for ( int i = 0 ; i < e ; i ++ ) { cin > > u > > v > > c ; d [ u ] [ v ] = c ; } floyd ( ) ; bool negative = false ; for ( int i = 0 ; i < n ; i ++ ) if ( d [ i ] [ i ] < 0 ) negative = true ; if ( negative ) { cout << "NEGATIVE CYCLE" << endl ; } else { for ( int i = 0 ; i < n ; i ++ ) { for ( int j = 0 ; j < n ; j ++ ) { if ( j ) cout << " " ; if ( d [ i ] [ j ] == INFTY ) cout << "INF" ; else cout << d [ i ] [ j ] ; } cout << endl ; } } return 0 ; }<CODESPLIT>5.672175884246826<CODESPLIT>-1.1956158876419067<CODESPLIT>-1.0426597595214844<CODESPLIT>-1.1068207025527954<CODESPLIT>-1.2299681901931763<CODESPLIT>-1.269020915031433
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> #define debug(x) cerr << #x << ": " << x << '\n'; using namespace std ; using ll = long long ; using P = pair < int , int > ; const int INF = ( int ) 1e9 ; template < typename T > class edge { public : int src , to ; T cost ; edge ( int to , T cost ) : src ( - 1 ) , to ( to ) , cost ( cost ) { } edge ( int src , int to , T cost ) : src ( src ) , to ( to ) , cost ( cost ) { } } ; template < typename T > using Edges = vector < edge < T > > ; template < typename T > using AdjacencyList = vector < Edges < T > > ; template < typename T > using Matrix = vector < vector < T > > ; template < typename T > void warshall_floyd ( Matrix < T > & g , T INF ) { for ( int k = 0 ; k < ( int ) g . size ( ) ; k ++ ) { for ( int i = 0 ; i < ( int ) g . size ( ) ; i ++ ) { for ( int j = 0 ; j < ( int ) g . size ( ) ; j ++ ) { if ( g [ i ] [ k ] == INF or g [ k ] [ j ] == INF ) continue ; g [ i ] [ j ] = min ( g [ i ] [ j ] , g [ i ] [ k ] + g [ k ] [ j ] ) ; } } } } int main ( void ) { int V , E ; scanf ( "%d %d" , & V , & E ) ; Matrix < int > mat ( V , vector < int > ( V , INT_MAX ) ) ; for ( int i = 0 ; i < V ; i ++ ) mat [ i ] [ i ] = 0 ; for ( int i = 0 ; i < E ; i ++ ) { int x , y , z ; scanf ( "%d %d %d" , & x , & y , & z ) ; mat [ x ] [ y ] = z ; } warshall_floyd ( mat , INT_MAX ) ; for ( int i = 0 ; i < V ; i ++ ) { if ( mat [ i ] [ i ] < 0 ) { puts ( "NEGATIVE CYCLE" ) ; return 0 ; } } for ( int i = 0 ; i < V ; i ++ ) { for ( int j = 0 ; j < V ; j ++ ) { if ( j > 0 ) putchar ( ' ' ) ; if ( mat [ i ] [ j ] == INT_MAX ) printf ( "INF" ) ; else printf ( "%d" , mat [ i ] [ j ] ) ; } putchar ( '\n' ) ; } return 0 ; }<CODESPLIT>5.654455661773682<CODESPLIT>-1.0572400093078613<CODESPLIT>-0.968803346157074<CODESPLIT>-1.1768684387207031<CODESPLIT>-1.2272788286209106<CODESPLIT>-1.2061225175857544
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include "bits/stdc++.h" #define REP(i, n, N) for(ll i=n; i<N; i++) using namespace std ; typedef long long ll ; template < typename A , size_t N , typename T > void Fill ( A ( & array ) [ N ] , const T & val ) { std :: fill ( ( T * ) array , ( T * ) ( array + N ) , val ) ; } int main ( ) { ll INF = 1e18 ; int v , e ; cin > > v > > e ; ll dist [ 100 ] [ 100 ] ; Fill ( dist , INF ) ; REP ( i , 0 , v ) { dist [ i ] [ i ] = 0 ; } REP ( i , 0 , e ) { int a , b , d ; cin > > a > > b > > d ; dist [ a ] [ b ] = d ; } REP ( i , 0 , v ) { REP ( j , 0 , v ) { if ( dist [ j ] [ i ] == INF ) continue ; REP ( k , 0 , v ) { if ( dist [ i ] [ k ] == INF ) continue ; dist [ j ] [ k ] = min ( dist [ j ] [ k ] , dist [ j ] [ i ] + dist [ i ] [ k ] ) ; } } } REP ( i , 0 , v ) { if ( dist [ i ] [ i ] < 0 ) { cout << "NEGATIVE CYCLE" << endl ; return 0 ; } } REP ( i , 0 , v ) { REP ( j , 0 , v ) { if ( j ! = 0 ) cout << " " ; if ( 1e18 == dist [ i ] [ j ] ) { cout << "INF" ; } else { cout << dist [ i ] [ j ] ; } } cout << endl ; } }<CODESPLIT>5.701736927032471<CODESPLIT>-1.0980221033096313<CODESPLIT>-1.015730619430542<CODESPLIT>-1.162816047668457<CODESPLIT>-1.2392500638961792<CODESPLIT>-1.2561575174331665
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> using namespace std ; #define rep(i,n)for(int i=0;i<(n);i++) using ll = long long ; using P = pair < int , int > ; using Matrix = vector < vector < int > > ; const int INF = 2000000000 ; int main ( ) { int V , E ; cin > > V > > E ; Matrix dist ; dist = Matrix ( V , vector < int > ( V , INF ) ) ; rep ( i , V ) dist [ i ] [ i ] = 0 ; rep ( i , E ) { int from , to , cost ; cin > > from > > to > > cost ; dist [ from ] [ to ] = cost ; } rep ( k , V ) { rep ( i , V ) { if ( dist [ i ] [ k ] ! = INF ) { rep ( j , V ) { if ( dist [ k ] [ j ] ! = INF ) { dist [ i ] [ j ] = min ( dist [ i ] [ j ] , dist [ i ] [ k ] + dist [ k ] [ j ] ) ; if ( i == j && dist [ i ] [ j ] < 0 ) { printf ( "NEGATIVE CYCLE\n" ) ; return 0 ; } } } } } } rep ( i , V ) { rep ( j , V ) { if ( dist [ i ] [ j ] == INF ) { cout << "INF" ; } else { cout << dist [ i ] [ j ] ; } if ( j ! = V - 1 ) cout << " " ; } cout << endl ; } }<CODESPLIT>5.696081161499023<CODESPLIT>-1.0647333860397339<CODESPLIT>-1.0380059480667114<CODESPLIT>-1.1595797538757324<CODESPLIT>-1.2586710453033447<CODESPLIT>-1.3124157190322876
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> #define FOR(i, m, n) for(int i = m;i < n;i++) #define REP(i,n) for(int i=0;i<n;i++) #define FORq(i, m, n) for(int i = m;i <= n;i++) #define SCD(n) scanf("%d",&n) #define SCD2(m,n) scanf("%d%d",&m,&n) #define SCD3(m,n,k) scanf("%d%d%d",&m,&n,&k) #define PB push_back #define MP make_pair #define PRINTD(n) printf("%d\n",n) #define PRINTLLD(n) printf("%lld\n",n); #define DEBUG printf("%s\n","debug") using namespace std ; typedef pair < int , int > P ; const long long INF = 9223372036854775000 ; const int VMAX = 102 ; const int EMAX = 10000 ; struct Edge { int from ; int to ; int cost ; } ; int main ( ) { int V , E ; SCD2 ( V , E ) ; struct Edge e [ EMAX ] ; long long d [ VMAX ] [ VMAX ] ; bool negcycle = false ; REP ( i , E ) { int s , t , c ; SCD3 ( s , t , c ) ; e [ i ] . from = s ; e [ i ] . to = t ; e [ i ] . cost = c ; } REP ( s , V ) { REP ( i , VMAX ) { d [ s ] [ i ] = INF ; } d [ s ] [ s ] = 0 ; REP ( i , V ) { bool update = false ; REP ( j , E ) { int u = e [ j ] . from ; int v = e [ j ] . to ; int c = e [ j ] . cost ; if ( ( d [ s ] [ u ] + c < d [ s ] [ v ] ) and ( d [ s ] [ u ] ! = INF ) ) { d [ s ] [ v ] = d [ s ] [ u ] + c ; update = true ; } } if ( ( update ) and ( i == V - 1 ) ) { negcycle = true ; } } } if ( negcycle ) { printf ( "NEGATIVE CYCLE\n" ) ; return 0 ; } REP ( s , V ) { REP ( i , V - 1 ) { if ( d [ s ] [ i ] ! = INF ) { printf ( "%lld " , d [ s ] [ i ] ) ; } else { printf ( "INF " ) ; } } if ( d [ s ] [ V - 1 ] ! = INF ) { printf ( "%lld\n" , d [ s ] [ V - 1 ] ) ; } else { printf ( "INF\n" ) ; } } return 0 ; }<CODESPLIT>5.654228687286377<CODESPLIT>-1.096821665763855<CODESPLIT>-1.025280237197876<CODESPLIT>-1.162644624710083<CODESPLIT>-1.2264933586120605<CODESPLIT>-1.2933160066604614
0<CODESPLIT>Single Source Shortest Path<CODESPLIT>#include<bits/stdc++.h> using namespace std ; #define INF 5000000000 #define INF2 2000000000 using ll = long long ; int main ( ) { ll V , E ; cin > > V > > E ; vector < vector < ll > > dis ( V , vector < ll > ( V , INF ) ) ; ll u , v , d ; for ( ll i = 0 ; i < E ; i ++ ) { cin > > u > > v > > d ; dis [ u ] [ v ] = d ; } bool can = true ; for ( ll i = 0 ; i < V ; i ++ ) dis [ i ] [ i ] = 0 ; for ( ll k = 0 ; k < V ; k ++ ) { for ( ll i = 0 ; i < V ; i ++ ) { for ( ll j = 0 ; j < V ; j ++ ) { dis [ i ] [ j ] = min ( dis [ i ] [ j ] , dis [ i ] [ k ] + dis [ k ] [ j ] ) ; } } } for ( ll i = 0 ; i < V ; i ++ ) if ( dis [ i ] [ i ] < 0 ) can = false ; if ( ! can ) cout << "NEGATIVE CYCLE" << endl ; else { for ( ll i = 0 ; i < V ; i ++ ) { for ( ll j = 0 ; j < V ; j ++ ) { if ( dis [ i ] [ j ] >= INF2 ) { if ( j == V - 1 ) cout << "INF" ; else cout << "INF " ; } else { if ( j == V - 1 ) cout << dis [ i ] [ j ] ; else cout << dis [ i ] [ j ] << " " ; } } cout << endl ; } } return 0 ; }<CODESPLIT>5.69539213180542<CODESPLIT>-1.1759073734283447<CODESPLIT>-1.033398151397705<CODESPLIT>-1.129903793334961<CODESPLIT>-1.2227779626846313<CODESPLIT>-1.2501246929168701
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> using namespace std ; const long long INF = ( 1LL << 60 ) ; const bool WHITE = false ; const bool BLACK = true ; int main ( ) { int N , M , r ; cin > > N > > M > > r ; vector < vector < pair < int , int > > > adj ( N ) ; for ( int i = 0 ; i < M ; i ++ ) { int s , t , d ; cin > > s > > t > > d ; adj . at ( s ) . push_back ( make_pair ( t , d ) ) ; } vector < long long > d ( N , INF ) ; vector < bool > color ( N , WHITE ) ; priority_queue < pair < long long , int > > pq ; pq . push ( make_pair ( 0 , r ) ) ; while ( ! pq . empty ( ) ) { long long cost ; int u ; tie ( cost , u ) = pq . top ( ) ; cost *= - 1 ; pq . pop ( ) ; if ( color . at ( u ) == BLACK ) { continue ; } color . at ( u ) = BLACK ; d . at ( u ) = cost ; for ( int i = 0 ; i < adj . at ( u ) . size ( ) ; i ++ ) { int v , cost_uv ; tie ( v , cost_uv ) = adj . at ( u ) . at ( i ) ; if ( color . at ( v ) == WHITE && d . at ( v ) > d . at ( u ) + cost_uv ) { pq . push ( make_pair ( - 1 * ( d . at ( u ) + cost_uv ) , v ) ) ; } } } for ( int i = 0 ; i < N ; i ++ ) { if ( d . at ( i ) < INF ) { cout << d . at ( i ) << endl ; } else { cout << "INF" << endl ; } } }<CODESPLIT>-1.0595550537109375<CODESPLIT>5.7532267570495605<CODESPLIT>-1.2268669605255127<CODESPLIT>-1.2279194593429565<CODESPLIT>-1.1065229177474976<CODESPLIT>-1.3841341733932495
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <iostream> #include <cstdlib> #include <queue> #include <vector> #include <utility> #include <climits> using namespace std ; struct edge { int to , cost ; } ; typedef int Vertex ; typedef pair < int , Vertex > P ; typedef vector < vector < edge > > Graph ; Graph make_graph ( const int V , const int E ) { Graph G ( V ) ; for ( int i = 0 ; i < E ; ++ i ) { int s , t , d ; cin > > s > > t > > d ; G [ s ] . emplace_back ( edge { t , d } ) ; } return G ; } vector < int > dijkstra ( Graph & G , Vertex s ) { vector < int > d ( G . size ( ) , INT_MAX ) ; d [ s ] = 0 ; priority_queue < P , vector < P > , greater < P > > q ; q . push ( make_pair ( 0 , s ) ) ; while ( ! q . empty ( ) ) { int cost = q . top ( ) . first ; Vertex current = q . top ( ) . second ; q . pop ( ) ; if ( d [ current ] < cost ) continue ; for ( auto & e : G [ current ] ) { if ( d [ e . to ] > d [ current ] + e . cost ) { d [ e . to ] = d [ current ] + e . cost ; q . push ( make_pair ( d [ e . to ] , e . to ) ) ; } } } return d ; } int main ( ) { int V , E , r ; cin > > V > > E > > r ; Graph G = make_graph ( V , E ) ; vector < int > d = dijkstra ( G , r ) ; for ( int v = 0 ; v < V ; ++ v ) { if ( d [ v ] < INT_MAX ) cout << d [ v ] << endl ; else cout << "INF\n" ; } return EXIT_SUCCESS ; }<CODESPLIT>-1.1293048858642578<CODESPLIT>5.739774703979492<CODESPLIT>-1.2209839820861816<CODESPLIT>-1.2094783782958984<CODESPLIT>-1.1187776327133179<CODESPLIT>-1.3826994895935059
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> using namespace std ; using ll = long long ; using P = pair < ll , ll > ; using Graph = vector < vector < ll > > ; #define rep(i, n) for(ll i=0;i<(ll)(n);i++) #define rep2(i, m, n) for(ll i=m;i<(ll)(n);i++) #define rrep(i, n, m) for(ll i=n;i>=(ll)(m);i--) const int dx [ 4 ] = { 1 , 0 , - 1 , 0 } ; const int dy [ 4 ] = { 0 , 1 , 0 , - 1 } ; const int ddx [ 8 ] = { 0 , 1 , 1 , 1 , 0 , - 1 , - 1 , - 1 } ; const int ddy [ 8 ] = { 1 , 1 , 0 , - 1 , - 1 , - 1 , 0 , 1 } ; const ll MOD = 1000000007 ; const ll INF = 1000000000000000000L ; #ifdef __DEBUG #include "cpp-pyprint/pyprint.h" #endif struct edge { int from , to ; ll cost ; } ; class Dijkstra { int V ; vector < vector < edge > > edges ; vector < ll > dist ; vector < ll > prev ; vector < ll > route_count ; public : Dijkstra ( int v ) : V ( v ) { edges . resize ( V ) ; dist . resize ( V , INF ) ; prev . resize ( V , INF ) ; route_count . resize ( V , 0 ) ; } void add_edge ( int from , int to , ll cost ) { edges [ from ] . push_back ( { from , to , cost } ) ; } ll get_cost ( int goal ) { return dist [ goal ] ; } ll get_route_count ( int goal ) { return route_count [ goal ] ; } vector < ll > get_route ( int goal ) { vector < ll > res ; res . push_back ( goal ) ; ll dest = goal ; while ( prev [ dest ] ! = INF ) { res . push_back ( prev [ dest ] ) ; dest = prev [ dest ] ; } reverse ( res . begin ( ) , res . end ( ) ) ; return res ; } void exec ( int start ) { dist [ start ] = 0 ; route_count [ start ] = 1 ; priority_queue < P , vector < P > , greater < > > queue ; queue . push ( { dist [ start ] , start } ) ; while ( ! queue . empty ( ) ) { P p = queue . top ( ) ; queue . pop ( ) ; ll prev_cost = p . first ; ll src = p . second ; if ( dist [ src ] < prev_cost ) continue ; for ( edge & e : edges [ src ] ) { ll to = e . to ; ll cost = e . cost ; if ( cost ! = INF && dist [ to ] > dist [ src ] + cost ) { dist [ to ] = dist [ src ] + cost ; queue . push ( { dist [ to ] , to } ) ; prev [ to ] = src ; route_count [ to ] = route_count [ src ] ; } else if ( dist [ to ] == dist [ src ] + cost ) { route_count [ to ] += route_count [ src ] ; route_count [ to ] % = MOD ; } } } } } ; void Main ( ) { ll V , E , r ; cin > > V > > E > > r ; Dijkstra dijkstra ( V ) ; rep ( i , E ) { ll s , t , e ; cin > > s > > t > > e ; dijkstra . add_edge ( s , t , e ) ; } dijkstra . exec ( r ) ; rep ( i , V ) { ll ans = dijkstra . get_cost ( i ) ; if ( ans == INF ) { cout << "INF" << '\n' ; } else { cout << ans << '\n' ; } } } int main ( ) { cin . tie ( nullptr ) ; ios :: sync_with_stdio ( false ) ; cout << fixed << setprecision ( 15 ) ; Main ( ) ; return 0 ; }<CODESPLIT>-0.8208845257759094<CODESPLIT>5.719056129455566<CODESPLIT>-1.2562494277954102<CODESPLIT>-1.2411819696426392<CODESPLIT>-1.161421537399292<CODESPLIT>-1.4453154802322388
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> using namespace std ; struct Edge { int to ; long long cost ; Edge ( int a , long long b ) { to = a ; cost = b ; } } ; using Graph = vector < vector < Edge > > ; long long dist [ 100100 ] ; int main ( ) { int V , E , r ; cin > > V > > E > > r ; Graph G ( V ) ; for ( int i = 0 ; i < E ; i ++ ) { int s , t ; long long d ; cin > > s > > t > > d ; G [ s ] . emplace_back ( t , d ) ; } for ( int i = 0 ; i < V ; i ++ ) { dist [ i ] = - 1 ; } dist [ r ] = 0 ; priority_queue < pair < long long , int > , vector < pair < long long , int > > , greater < pair < long long , int > > > pq ; pq . emplace ( 0 , r ) ; while ( ! pq . empty ( ) ) { int v = pq . top ( ) . second ; long long v_dist = pq . top ( ) . first ; pq . pop ( ) ; for ( int i = 0 ; i < G [ v ] . size ( ) ; i ++ ) { int nv = G [ v ] [ i ] . to ; long long nv_dist = G [ v ] [ i ] . cost ; if ( dist [ nv ] == - 1 ) { dist [ nv ] = v_dist + nv_dist ; pq . emplace ( dist [ nv ] , nv ) ; } else if ( dist [ nv ] <= v_dist + nv_dist ) { continue ; } dist [ nv ] = v_dist + nv_dist ; pq . emplace ( dist [ nv ] , nv ) ; } } for ( int i = 0 ; i < V ; i ++ ) { if ( dist [ i ] == - 1 ) { cout << "INF" << endl ; } else { cout << dist [ i ] << endl ; } } }<CODESPLIT>-1.0350254774093628<CODESPLIT>5.746479034423828<CODESPLIT>-1.2338122129440308<CODESPLIT>-1.2511112689971924<CODESPLIT>-1.117003321647644<CODESPLIT>-1.3757514953613281
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include "bits/stdc++.h" using namespace std ; typedef pair < int , int > pii ; #define rep(i,n) for(int i=0;i<(int)(n);i++) #define MAX_V 100001 #define INF 999999999 struct edge { int to , cost ; } ; vector < edge > G [ MAX_V ] ; int d [ MAX_V ] ; void dijkstra ( int s , int V ) { priority_queue < pii , vector < pii > , greater < pii > > que ; rep ( i , V ) d [ i ] = INF ; d [ s ] = 0 ; que . push ( pii ( 0 , s ) ) ; while ( que . size ( ) ) { pii p = que . top ( ) ; que . pop ( ) ; int v = p . second ; if ( d [ v ] < p . first ) continue ; rep ( i , G [ v ] . size ( ) ) { edge e = G [ v ] [ i ] ; if ( d [ e . to ] > d [ v ] + e . cost ) { d [ e . to ] = d [ v ] + e . cost ; que . push ( pii ( d [ e . to ] , e . to ) ) ; } } } } int main ( ) { int v , e , r ; cin > > v > > e > > r ; rep ( i , e ) { int s , t , d ; cin > > s > > t > > d ; G [ s ] . push_back ( edge { t , d } ) ; } dijkstra ( r , v ) ; rep ( i , v ) { if ( d [ i ] == INF ) cout << "INF" << endl ; else cout << d [ i ] << endl ; } }<CODESPLIT>-1.125760793685913<CODESPLIT>5.742395401000977<CODESPLIT>-1.228722095489502<CODESPLIT>-1.2128673791885376<CODESPLIT>-1.1059685945510864<CODESPLIT>-1.3778356313705444
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT># include <bits/stdc++.h> # define rep(i,n) for(int i=0, i##_len=(n); i<i##_len; ++i) # define len(x) ((int)(x).size()) # define pb push_back # define int long long using namespace std ; struct Graph { Graph ( ) = default ; Graph ( int v , int e ) : V ( v ) , E ( e ) { adj = vector < vector < int > > ( V ) ; cost = vector < vector < int > > ( V ) ; } void connect_to ( int a , int b , int c = 0 ) { adj [ a ] . pb ( b ) ; cost [ a ] . pb ( c ) ; } vector < int > dijkstra ( int ini ) { using P = pair < int , int > ; vector < int > dist ( V , - 1 ) ; vector < bool > visited ( V , false ) ; priority_queue < P , vector < P > , greater < P > > que ; que . emplace ( 0 , ini ) ; while ( not que . empty ( ) ) { int d = que . top ( ) . first , to = que . top ( ) . second ; que . pop ( ) ; if ( visited [ to ] ) continue ; dist [ to ] = d ; visited [ to ] = true ; rep ( i , len ( adj [ to ] ) ) { int nxt = adj [ to ] [ i ] ; int c = cost [ to ] [ i ] ; if ( dist [ nxt ] ! = - 1 and dist [ nxt ] <= dist [ to ] + c ) continue ; que . emplace ( dist [ to ] + c , nxt ) ; } } return dist ; } vector < vector < int > > adj ; vector < vector < int > > cost ; int V ; int E ; } ; signed main ( ) { int V , E , r ; cin > > V > > E > > r ; Graph g ( V , E ) ; rep ( i , E ) { int s , t , d ; cin > > s > > t > > d ; g . connect_to ( s , t , d ) ; } vector < int > dist = g . dijkstra ( r ) ; auto Ans = [ ] ( int d ) { if ( d == - 1 ) { string ret = "INF" ; return ret ; } else return to_string ( d ) ; } ; rep ( i , V ) cout << Ans ( dist [ i ] ) << endl ; return 0 ; }<CODESPLIT>-1.1029280424118042<CODESPLIT>5.732417106628418<CODESPLIT>-1.2303006649017334<CODESPLIT>-1.2258081436157227<CODESPLIT>-1.1065287590026855<CODESPLIT>-1.3967007398605347
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include<bits/stdc++.h> #define MAX 100010 #define inf 1000000010 #define linf (1e16) #define eps (1e-8) #define Eps (1e-12) #define mod 1000000007 #define pi acos(-1.0) #define phi (1.0+sqrt(5.0))/2.0 #define f first #define s second #define mp make_pair #define pb push_back #define all(a) (a).begin(),(a).end() #define pd(a) printf("%.10f\n",(double)(a)) #define pld(a) printf("%.10Lf\n",(ld)(a)) #define FOR(i,a,b) for(int i=(a);i<(b);i++) #define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--) #define Unique(v) v.erase(unique(all(v)),v.end()) #define equals(a,b) (fabs((a)-(b))<eps) using namespace std ; typedef long double ld ; typedef long long ll ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < int , double > pid ; typedef pair < double , int > pdi ; typedef pair < double , double > pdd ; typedef vector < int > vi ; typedef vector < pii > vpi ; int n , m , s ; vector < pii > E [ MAX ] ; void compute ( ) { int d [ MAX ] ; fill ( d , d + MAX , inf ) ; priority_queue < pii , vector < pii > , greater < pii > > pq ; d [ s ] = 0 ; pq . push ( mp ( 0 , s ) ) ; while ( pq . size ( ) ) { pii u = pq . top ( ) ; pq . pop ( ) ; if ( d [ u . s ] < u . f ) continue ; FOR ( i , 0 , E [ u . s ] . size ( ) ) { int next = E [ u . s ] [ i ] . f ; int cost = d [ u . s ] + E [ u . s ] [ i ] . s ; if ( cost < d [ next ] ) { d [ next ] = cost ; pq . push ( mp ( cost , next ) ) ; } } } FOR ( i , 0 , n ) { if ( d [ i ] == inf ) cout << "INF" << endl ; else cout << d [ i ] << endl ; } } int main ( ) { cin > > n > > m > > s ; FOR ( i , 0 , m ) { int a , b , c ; cin > > a > > b > > c ; E [ a ] . pb ( mp ( b , c ) ) ; } compute ( ) ; return 0 ; }<CODESPLIT>-0.8971330523490906<CODESPLIT>5.733370304107666<CODESPLIT>-1.2616140842437744<CODESPLIT>-1.2190032005310059<CODESPLIT>-1.1535148620605469<CODESPLIT>-1.435533881187439
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT># include <iostream> # include <algorithm> #include <array> # include <cassert> #include <cctype> #include <climits> #include <numeric> # include <vector> # include <string> # include <set> # include <map> # include <cmath> # include <iomanip> # include <functional> # include <tuple> # include <utility> # include <stack> # include <queue> # include <list> # include <bitset> # include <complex> # include <chrono> # include <random> # include <limits.h> # include <unordered_map> # include <unordered_set> # include <deque> # include <cstdio> # include <cstring> #include <stdio.h> #include<time.h> #include <stdlib.h> #include <cstdint> #include <cfenv> #include<fstream> using namespace std ; using LL = long long ; using ULL = unsigned long long ; long long MOD = 1000000000 + 7 ; constexpr long long INF = numeric_limits < LL > :: max ( ) ; const double PI = acos ( - 1 ) ; #define fir first #define sec second #define thi third #define debug(x) cerr<<#x<<": "<<x<<'\n' typedef pair < LL , LL > Pll ; typedef pair < LL , pair < LL , LL > > Ppll ; typedef pair < LL , pair < LL , bitset < 100001 > > > Pbll ; typedef pair < LL , pair < LL , vector < LL > > > Pvll ; typedef pair < LL , LL > Vec2 ; struct Tll { LL first , second , third ; } ; struct Fll { LL first , second , third , fourth ; } ; typedef pair < LL , Tll > Ptll ; #define rep(i,rept) for(LL i=0;i<rept;i++) #define Rrep(i,mf) for(LL i=mf-1;i>=0;i--) LL h , w , n , m , k , t , s , p , q , last , first , cnt , sum , ans , a [ 400000 ] , b [ 400000 ] ; vector < LL > d , dp1 , d_p , d_q ; string str , ss ; bool f ; char c [ 3000 ] [ 3000 ] ; int di [ 4 ] [ 2 ] = { { 0 , 1 } , { 1 , 0 } , { 0 , - 1 } , { - 1 , 0 } } ; struct Edge { LL to , cost ; } ; struct edge { LL from , to , cost ; } ; vector < vector < Edge > > vec ; vector < edge > ed ; vector < LL > v ; map < Pll , LL > ma ; multiset < LL > st ; void YN ( bool f ) { if ( f ) cout << "YES" << endl ; else cout << "NO" << endl ; } void yn ( bool f ) { if ( f ) cout << "Yes" << endl ; else cout << "No" << endl ; } vector < LL > dijk ( vector < vector < Edge > > & g , LL s ) { vector < LL > dis ( g . size ( ) ) ; rep ( i , g . size ( ) ) { dis [ i ] = INF ; } dis [ s ] = 0 ; priority_queue < Pll , vector < Pll > , greater < Pll > > pq ; pq . push ( Pll ( 0 , s ) ) ; while ( ! pq . empty ( ) ) { Pll num = pq . top ( ) ; pq . pop ( ) ; LL v = num . sec , cost = num . fir ; if ( dis [ v ] < cost ) continue ; rep ( i , g [ v ] . size ( ) ) { if ( dis [ g [ v ] [ i ] . to ] > dis [ v ] + g [ v ] [ i ] . cost ) { dis [ g [ v ] [ i ] . to ] = dis [ v ] + g [ v ] [ i ] . cost ; pq . push ( Pll ( dis [ g [ v ] [ i ] . to ] , g [ v ] [ i ] . to ) ) ; } } } return dis ; } LL dfs ( LL s , LL p_cos , LL q_cos ) { LL ret = min ( { p_cos + d_q [ s ] , q_cos + d_p [ s ] , p_cos + q_cos } ) ; rep ( i , vec [ s ] . size ( ) ) { LL next = vec [ s ] [ i ] . to ; if ( d [ s ] <= d [ next ] ) continue ; if ( d [ s ] == d [ next ] + vec [ s ] [ i ] . cost ) { ret = min ( ret , dfs ( next , min ( p_cos , d_p [ next ] ) , min ( q_cos , d_q [ next ] ) ) ) ; } } return ret ; } int main ( ) { cin > > n > > m > > s ; vec . resize ( n ) ; rep ( i , m ) { LL x , y , z ; cin > > x > > y > > z ; vec [ x ] . push_back ( Edge { y , z } ) ; } d = dijk ( vec , s ) ; rep ( i , n ) { if ( d [ i ] == INF ) cout << "INF" << endl ; else cout << d [ i ] << endl ; } return 0 ; }<CODESPLIT>-0.7646717429161072<CODESPLIT>5.705983638763428<CODESPLIT>-1.3052211999893188<CODESPLIT>-1.243246078491211<CODESPLIT>-1.1803125143051147<CODESPLIT>-1.4453338384628296
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include<bits/stdc++.h> using namespace std ; typedef long long int lld ; #define INF (1<<30) typedef pair < int , int > P ; struct Edge { int to , cost ; } ; vector < vector < Edge > > Graph ; void Dijkstra ( int s , int g ) { vector < int > min_cost ( Graph . size ( ) , INF ) ; priority_queue < P , vector < P > , greater < P > > que ; que . push ( P ( 0 , s ) ) ; min_cost [ s ] = 0 ; while ( ! que . empty ( ) ) { int cost = que . top ( ) . first ; int now = que . top ( ) . second ; que . pop ( ) ; if ( cost > min_cost [ now ] ) continue ; for ( int i = 0 ; i < Graph [ now ] . size ( ) ; i ++ ) { Edge e = Graph [ now ] [ i ] ; if ( cost + e . cost < min_cost [ e . to ] ) { min_cost [ e . to ] = cost + e . cost ; que . push ( P ( min_cost [ e . to ] , e . to ) ) ; } } } for ( int i = 0 ; i < g ; i ++ ) { if ( min_cost [ i ] == INF ) cout << "INF" << endl ; else cout << min_cost [ i ] << endl ; } } int main ( ) { int V , E , r ; cin > > V > > E > > r ; Graph . resize ( V ) ; for ( int i = 0 ; i < E ; i ++ ) { int a , b , c ; cin > > a > > b > > c ; Edge e ; e . to = b ; e . cost = c ; Graph [ a ] . push_back ( e ) ; } Dijkstra ( r , V ) ; }<CODESPLIT>-1.1118758916854858<CODESPLIT>5.738422393798828<CODESPLIT>-1.2129673957824707<CODESPLIT>-1.224867582321167<CODESPLIT>-1.099588394165039<CODESPLIT>-1.3404839038848877
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> using namespace std ; long long INF = 10000000000000 ; struct Edge { int to ; int cost ; } ; int main ( ) { int V , E , r ; cin > > V > > E > > r ; priority_queue < pair < int , int > , vector < pair < int , int > > , greater < pair < int , int > > > pq ; vector < vector < Edge > > G ( V ) ; for ( int i = 0 ; i < E ; i ++ ) { int s , t , d ; cin > > s > > t > > d ; Edge e ; e . to = t ; e . cost = d ; G [ s ] . push_back ( e ) ; } long long dist [ 100100 ] ; for ( int i = 0 ; i < 100100 ; i ++ ) { dist [ i ] = INF ; } dist [ r ] = 0 ; pq . push ( make_pair ( dist [ r ] , r ) ) ; while ( ! pq . empty ( ) ) { int v = pq . top ( ) . second ; int v_dist = pq . top ( ) . first ; pq . pop ( ) ; for ( int i = 0 ; i < G [ v ] . size ( ) ; i ++ ) { int next_v = G [ v ] [ i ] . to ; int next_v_cost = G [ v ] [ i ] . cost ; if ( dist [ next_v ] <= dist [ v ] + next_v_cost ) { continue ; } dist [ next_v ] = dist [ v ] + next_v_cost ; pq . push ( make_pair ( dist [ next_v ] , next_v ) ) ; } } for ( int i = 0 ; i < V ; i ++ ) { if ( dist [ i ] == INF ) { cout << "INF" << endl ; continue ; } cout << dist [ i ] << endl ; } }<CODESPLIT>-1.110294222831726<CODESPLIT>5.746310710906982<CODESPLIT>-1.2239595651626587<CODESPLIT>-1.228074073791504<CODESPLIT>-1.098548412322998<CODESPLIT>-1.367943525314331
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> using namespace std ; struct Edge { long to ; long w ; } ; using Graph = vector < vector < Edge > > ; const long INF = 10000 * ( 100000 - 1 ) + 1 ; int main ( ) { long V , E , r ; cin > > V > > E > > r ; Graph g ; g . resize ( V ) ; for ( long i = 0 ; i < E ; i ++ ) { long u , v , w ; cin > > u > > v > > w ; g [ u ] . push_back ( { v , w } ) ; } priority_queue < pair < long , long > , vector < pair < long , long > > , greater < pair < long , long > > > pq ; vector < long > dist ( V , INF ) ; pq . push ( make_pair ( r , 0 ) ) ; dist [ r ] = 0 ; while ( ! pq . empty ( ) ) { long u = pq . top ( ) . first ; long d = pq . top ( ) . second ; pq . pop ( ) ; if ( dist [ u ] < d ) continue ; for ( Edge e : g [ u ] ) { long v = e . to ; if ( dist [ u ] + e . w < dist [ v ] ) { dist [ v ] = dist [ u ] + e . w ; pq . push ( make_pair ( v , dist [ v ] ) ) ; } } } for ( long u = 0 ; u < V ; u ++ ) { if ( dist [ u ] == INF ) cout << "INF" ; else cout << dist [ u ] ; cout << endl ; } }<CODESPLIT>-1.1116626262664795<CODESPLIT>5.7323527336120605<CODESPLIT>-1.2269269227981567<CODESPLIT>-1.2257037162780762<CODESPLIT>-1.102986454963684<CODESPLIT>-1.3636651039123535
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> using namespace std ; using ll = long long ; #define REP(i, n) for (int i = 0; i < n; i++) #define REPR(i, n) for (int i = n; i >= 0; i--) #define FOR(i, m, n) for (int i = m; i < n; i++) #define pb push_back #define mp make_pair #define fill(x, y) memset(x, y, sizeof(x)) #define even(x) x % 2 == 0 #define odd(x) x % 2 != 0 #define all(x) x.begin(), x.end() #define pcnt __builtin_popcount #define buli(x) __builtin_popcountll(x) #define F first #define S second #define UNIQUE(v) v.erase(unique(v.begin(), v.end()), v.end()); ll qp ( ll a , ll b , int mo ) { ll ans = 1 ; do { if ( b & 1 ) ans = 1ll * ans * a % mo ; a = 1ll * a * a % mo ; } while ( b > >= 1 ) ; return ans ; } int gcd ( int a , int b ) { return b ? gcd ( b , a % b ) : a ; } int dx [ 4 ] = { 1 , 0 , - 1 , 0 } ; int dy [ 4 ] = { 0 , 1 , 0 , - 1 } ; template < typename T > vector < T > make_v ( size_t a ) { return vector < T > ( a ) ; } template < typename T , typename . . . Ts > auto make_v ( size_t a , size_t b , Ts . . . ts ) { return vector < decltype ( make_v < T > ( b , ts . . . ) ) > ( a , make_v < T > ( b , ts . . . ) ) ; } template < typename T , typename V > typename enable_if < is_class < T > :: value == 0 > :: type fill_v ( T & t , const V & v ) { t = v ; } template < typename T , typename V > typename enable_if < is_class < T > :: value ! = 0 > :: type fill_v ( T & t , const V & v ) { for ( auto & e : t ) fill_v ( e , v ) ; } const ll INF_LL = ( 1ll << 60 ) ; const int INF_INT = ( int ) 1e9 ; const ll MOD_CONST = ( ll ) ( 1e9 + 7 ) ; template < class T > bool chmax ( T & a , const T & b ) { if ( a < b ) { a = b ; return 1 ; } return 0 ; } template < class T > bool chmin ( T & a , const T & b ) { if ( b < a ) { a = b ; return 1 ; } return 0 ; } inline tuple < ll , ll > rotate45 ( tuple < ll , ll > p ) { ll x = get < 0 > ( p ) , y = get < 1 > ( p ) ; return tuple < ll , ll > ( x + y , x - y ) ; } typedef tuple < int , ll > Edge ; class Dijkstra { public : vector < vector < Edge > > edges ; Dijkstra ( int size ) { edges = make_v < vector < Edge > > ( size ) ; } vector < ll > get_shortest_path ( int start ) { int node_num = edges . size ( ) ; assert ( start < node_num ) ; typedef tuple < ll , int > P ; priority_queue < P , vector < P > , greater < P > > que ; auto d = make_v < ll > ( node_num ) ; fill_v ( d , INF_LL ) ; d [ start ] = 0 ; que . push ( P ( 0 , start ) ) ; while ( not que . empty ( ) ) { P p = que . top ( ) ; que . pop ( ) ; int v = get < 1 > ( p ) ; if ( d [ v ] < get < 0 > ( p ) ) continue ; REP ( i , edges [ v ] . size ( ) ) { Edge e = edges [ v ] [ i ] ; int to = get < 0 > ( e ) ; ll cost = get < 1 > ( e ) ; ll new_cost = d [ v ] + cost ; if ( d [ to ] > new_cost ) { d [ to ] = new_cost ; que . push ( P ( d [ to ] , to ) ) ; } } } return d ; } } ; int main ( void ) { cin . tie ( 0 ) ; ios :: sync_with_stdio ( 0 ) ; cout << fixed << setprecision ( 20 ) ; int N , M , start ; cin > > N > > M > > start ; Dijkstra dj ( N ) ; REP ( i , M ) { int from , to ; ll cost ; cin > > from > > to > > cost ; dj . edges [ from ] . pb ( Edge ( to , cost ) ) ; } auto d = dj . get_shortest_path ( start ) ; for ( auto c : d ) { if ( c == INF_LL ) cout << "INF" ; else cout << c ; cout << endl ; } return 0 ; }<CODESPLIT>-0.9572387933731079<CODESPLIT>5.752017974853516<CODESPLIT>-1.2383103370666504<CODESPLIT>-1.2509181499481201<CODESPLIT>-1.1109750270843506<CODESPLIT>-1.4475268125534058
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#line 2 "lib/template.cpp" #ifndef LOCAL #pragma GCC diagnostic warning "-w" #pragma GCC optimize("O3") #pragma GCC optimize("unroll-loops") #pragma GCC target("avx") #endif #include <algorithm> #include <bitset> #include <cassert> #include <cmath> #include <cstring> #include <functional> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <stack> #include <tuple> #include <utility> #include <vector> using namespace std ; using ll = long long ; using ull = unsigned long long ; using VI = vector < int > ; using VVI = vector < vector < int > > ; using VLL = vector < ll > ; using VVLL = vector < vector < ll > > ; using VB = vector < bool > ; using PII = pair < int , int > ; using PLL = pair < ll , ll > ; template < typename T > using minheap = priority_queue < T , vector < T > , greater < T > > ; constexpr int INF = 1000000007 ; constexpr ll INF_LL = 1 '000' 000 '000' 000 '000' 007 ; #define EXIT(out) ({ OUT(out); exit(0); }) #define BREAK ({ break; }) #define CONTINUE ({ continue; }) #define all(x) begin(x), end(x) #define rall(x) rbegin(x), rend(x) #define newl '\n' #define OVERLOAD3(_1, _2, _3, name, ...) name #define rep(...) OVERLOAD3(__VA_ARGS__, REPEAT_FROM_UNTIL, REPEAT_UNTIL, REPEAT)(__VA_ARGS__) #define REPEAT(times) REPEAT_CNT(_repeat, __COUNTER__, times) #define REPEAT_CNT(_repeat, cnt, times) REPEAT_CNT_CAT(_repeat, cnt, times) #define REPEAT_CNT_CAT(_repeat, cnt, times) REPEAT_FROM_UNTIL(_repeat ## cnt, 0, times) #define REPEAT_UNTIL(name, times) REPEAT_FROM_UNTIL(name, 0, times) #define REPEAT_FROM_UNTIL(name, from, until) for (int name = from, name ## __until = (until); name < name ## __until; name++) #define repr(...) OVERLOAD3(__VA_ARGS__, REPR_FROM_UNTIL, REPR_UNTIL, REPEAT)(__VA_ARGS__) #define REPR_UNTIL(name, times) REPR_FROM_UNTIL(name, 0, times) #define REPR_FROM_UNTIL(name, from, until) for (int name = (until)-1, name ## __from = (from); name >= name ## __from; name--) #define repi(it, ds) for (auto it = ds.begin(); it != ds.end(); it++) template < typename T , typename U > bool chmin ( T & var , U x ) { if ( var > x ) { var = x ; return true ; } else return false ; } template < typename T , typename U > bool chmax ( T & var , U x ) { if ( var < x ) { var = x ; return true ; } else return false ; } template < typename T > int sgn ( T val ) { return ( T ( 0 ) < val ) - ( val < T ( 0 ) ) ; } ll power ( ll e , ll t , ll mod = INF_LL ) { ll res = 1 ; for ( ; t ; t > >= 1 , ( e *= e ) % = mod ) if ( t & 1 ) ( res *= e ) % = mod ; return res ; } ll choose ( ll n , int r ) { chmin ( r , n - r ) ; if ( r < 0 ) return 0 ; ll res = 1 ; rep ( i , r ) res *= n - i , res / = i + 1 ; return res ; } template < typename T > T divceil ( T m , T d ) { assert ( m >= 0 and d > 0 ) ; return ( m + d - 1 ) / d ; } template < typename T > vector < T > make_v ( size_t a , T b ) { return vector < T > ( a , b ) ; } template < typename . . . Ts > auto make_v ( size_t a , Ts . . . ts ) { return vector < decltype ( make_v ( ts . . . ) ) > ( a , make_v ( ts . . . ) ) ; } string operator * ( const string & s , int times ) { string res = "" ; rep ( times ) res += s ; return res ; } struct Edge { int to ; ll cost ; Edge ( int _to ) : to ( _to ) , cost ( 1 ) { } Edge ( int _to , ll _cost ) : to ( _to ) , cost ( _cost ) { } operator int ( ) { return to ; } } ; using Graph = vector < vector < Edge > > ; #pragma GCC diagnostic push #pragma GCC diagnostic ignored "-Wmisleading-indentation" class MyScanner { public : int offset = 0 ; char nc ( ) { return getchar ( ) ; } template < typename T > void input_integer ( T & var ) { var = 0 ; T sign = 1 ; int cc = nc ( ) ; for ( ; cc < '0' || '9' < cc ; cc = nc ( ) ) if ( cc == '-' ) sign = - 1 ; for ( ; '0' <= cc && cc <= '9' ; cc = nc ( ) ) var = ( var << 3 ) + ( var << 1 ) + cc - '0' ; var = var * sign ; var += offset ; } int c ( ) { char c ; while ( c = nc ( ) , c == ' ' or c == '\n' ) ; return c ; } MyScanner & operator > > ( char & var ) { var = c ( ) ; return * this ; } MyScanner & operator > > ( int & var ) { input_integer < int > ( var ) ; return * this ; } MyScanner & operator > > ( ll & var ) { input_integer < ll > ( var ) ; return * this ; } MyScanner & operator > > ( string & var ) { var = "" ; int cc = nc ( ) ; for ( ; ! isgraph ( cc ) ; cc = nc ( ) ) ; for ( ; isgraph ( cc ) ; cc = nc ( ) ) var . push_back ( cc ) ; return * this ; } template < size_t N > MyScanner & operator > > ( bitset < N > & var ) { ll v ; input_integer < ll > ( v ) ; var = bitset < N > ( v ) ; return * this ; } template < typename T > operator T ( ) { T x ; * this > > x ; return x ; } template < typename T > void operator ( ) ( T & t ) { * this > > t ; } template < typename T , typename . . . Ts > void operator ( ) ( T & t , Ts & . . . ts ) { * this > > t ; this -> operator ( ) ( ts . . . ) ; } template < typename Iter > void iter ( Iter first , Iter last ) { while ( first ! = last ) * this > > * first , first ++ ; } VI vi ( int n ) { VI res ( n ) ; iter ( all ( res ) ) ; return res ; } VVI vvi ( int n , int m ) { VVI res ( n ) ; rep ( i , n ) res [ i ] = vi ( m ) ; return res ; } VLL vll ( int n ) { VLL res ( n ) ; iter ( all ( res ) ) ; return res ; } VVLL vvll ( int n , int m ) { VVLL res ( n ) ; rep ( i , n ) res [ i ] = vll ( m ) ; return res ; } template < typename T > vector < T > v ( int n ) { vector < T > res ( n ) ; iter ( all ( res ) ) ; return res ; } } IN , IN1 { - 1 } ; class MyPrinter { public : int offset = 0 ; template < typename T > void output_integer ( T var ) { var += offset ; if ( var == 0 ) { putchar ( '0' ) ; return ; } if ( var < 0 ) putchar ( '-' ) , var = - var ; char stack [ 32 ] ; int stack_p = 0 ; while ( var ) stack [ stack_p ++ ] = '0' + ( var % 10 ) , var / = 10 ; while ( stack_p ) putchar ( stack [ -- stack_p ] ) ; } MyPrinter & operator << ( char c ) { putchar ( c ) ; return * this ; } MyPrinter & operator << ( double x ) { printf ( "%.10f" , x ) ; return * this ; } template < typename T > MyPrinter & operator << ( T var ) { output_integer < T > ( var ) ; return * this ; } MyPrinter & operator << ( char * str_p ) { while ( * str_p ) putchar ( * ( str_p ++ ) ) ; return * this ; } MyPrinter & operator << ( const char * str_p ) { while ( * str_p ) putchar ( * ( str_p ++ ) ) ; return * this ; } MyPrinter & operator << ( const string & str ) { const char * p = str . c_str ( ) ; const char * l = p + str . size ( ) ; while ( p < l ) putchar ( * p ++ ) ; return * this ; } template < typename T > void operator ( ) ( T x ) { * this << x << newl ; } template < typename T , typename . . . Ts > void operator ( ) ( T x , Ts . . . xs ) { * this << x << " " ; this -> operator ( ) ( xs . . . ) ; } template < typename Iter > void iter ( Iter s , Iter t ) { if ( s == t ) * this << "\n" ; else for ( ; s ! = t ; s ++ ) * this << * s << " \n" [ next ( s , 1 ) == t ] ; } } OUT , OUT1 { 1 } ; template < typename T , typename U > MyPrinter & operator << ( MyPrinter & out , const pair < T , U > & var ) { return out << var . first << " " << var . second ; } template < typename Tuple , size_t I , size_t N , enable_if_t < I == N > * = nullptr > MyPrinter & tuple_impl ( MyPrinter & out , const Tuple & var ) { return out ; } template < typename Tuple , size_t I , size_t N , enable_if_t < I ! = N > * = nullptr > MyPrinter & tuple_impl ( MyPrinter & out , const Tuple & var ) { out << get < I > ( var ) << " " ; return tuple_impl < Tuple , I + 1 , N > ( out , var ) ; } template < typename . . . Ts > MyPrinter & operator << ( MyPrinter & out , const tuple < Ts . . . > & var ) { return tuple_impl < tuple < Ts . . . > , 0 , sizeof . . . ( Ts ) > ( out , var ) ; } template < typename T , typename U > MyScanner & operator > > ( MyScanner & in , pair < T , U > & var ) { return in > > var . first > > var . second ; } template < typename Tuple , size_t I , size_t N , enable_if_t < I == N > * = nullptr > MyScanner & tuple_impl ( MyScanner & in , Tuple & var ) { return in ; } template < typename Tuple , size_t I , size_t N , enable_if_t < I ! = N > * = nullptr > MyScanner & tuple_impl ( MyScanner & in , Tuple & var ) { in > > get < I > ( var ) ; return tuple_impl < Tuple , I + 1 , N > ( in , var ) ; } template < typename . . . Ts > MyScanner & operator > > ( MyScanner & in , tuple < Ts . . . > & var ) { return tuple_impl < tuple < Ts . . . > , 0 , sizeof . . . ( Ts ) > ( in , var ) ; } class DebugPrint { public : template < typename T > DebugPrint & operator << ( const T & v ) { #ifdef LOCAL cerr << v ; #endif return * this ; } } debugos ; template < typename T > DebugPrint & operator << ( DebugPrint & os , const vector < T > & vec ) { os << "{" ; for ( int i = 0 ; i < vec . size ( ) ; i ++ ) os << vec [ i ] << ( i + 1 == vec . size ( ) ? "" : ", " ) ; os << "}" ; return os ; } template < typename T , typename U > DebugPrint & operator << ( DebugPrint & os , map < T , U > & map_var ) { os << "{" ; repi ( itr , map_var ) { os << * itr ; itr ++ ; if ( itr ! = map_var . end ( ) ) os << ", " ; itr -- ; } os << "}" ; return os ; } template < typename T > DebugPrint & operator << ( DebugPrint & os , set < T > & set_var ) { os << "{" ; repi ( itr , set_var ) { os << * itr ; itr ++ ; if ( itr ! = set_var . end ( ) ) os << ", " ; itr -- ; } os << "}" ; return os ; } template < typename T , typename U > DebugPrint & operator << ( DebugPrint & os , const pair < T , U > & p ) { os << "(" << p . first << ", " << p . second << ")" ; return os ; } void dump_func ( ) { debugos << newl ; } template < class Head , class . . . Tail > void dump_func ( Head && head , Tail && . . . tail ) { debugos << head ; if ( sizeof . . . ( Tail ) > 0 ) { debugos << ", " ; } dump_func ( std :: move ( tail ) . . . ) ; } #define dump(...) debugos << "  " << string(#__VA_ARGS__) << ": " << "[" << to_string(__LINE__) \<CODESPLIT>-0.8592493534088135<CODESPLIT>5.718776702880859<CODESPLIT>-1.2694594860076904<CODESPLIT>-1.241542100906372<CODESPLIT>-1.1646658182144165<CODESPLIT>-1.4081507921218872
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <algorithm> #include <climits> #include <cmath> #include <deque> #include <iostream> #include <numeric> #include <queue> #include <string> #include <vector> using namespace std ; const long long INF = 1e18 ; using ll = long long ; template < class T > bool chmax ( T & a , const T & b ) { if ( a < b ) { a = b ; return 1 ; } return 0 ; } template < class T > bool chmin ( T & a , const T & b ) { if ( b < a ) { a = b ; return 1 ; } return 0 ; } struct Edge { ll to ; ll cost ; } ; using Graph = vector < vector < Edge > > ; using P = pair < ll , int > ; void dijkstra ( const Graph & G , int s , vector < ll > & dis ) { int N = G . size ( ) ; dis . resize ( N , INF ) ; priority_queue < P , vector < P > , greater < P > > pq ; dis [ s ] = 0 ; pq . emplace ( dis [ s ] , s ) ; while ( ! pq . empty ( ) ) { P p = pq . top ( ) ; pq . pop ( ) ; int v = p . second ; if ( dis [ v ] < p . first ) { continue ; } for ( auto & e : G [ v ] ) { if ( dis [ e . to ] > dis [ v ] + e . cost ) { dis [ e . to ] = dis [ v ] + e . cost ; pq . emplace ( dis [ e . to ] , e . to ) ; } } } } int main ( ) { ll V , E , r ; cin > > V > > E > > r ; Graph g ; g . assign ( V , vector < Edge > ( ) ) ; for ( int i = 0 ; i < E ; ++ i ) { ll s , t , d ; cin > > s > > t > > d ; Edge e = { t , d } ; g [ s ] . emplace_back ( e ) ; } vector < ll > dis ; dijkstra ( g , r , dis ) ; for ( auto d : dis ) { if ( d == INF ) { cout << "INF" << endl ; continue ; } cout << d << endl ; } return 0 ; }<CODESPLIT>-1.0494778156280518<CODESPLIT>5.729388236999512<CODESPLIT>-1.2272839546203613<CODESPLIT>-1.2259786128997803<CODESPLIT>-1.172411322593689<CODESPLIT>-1.3958202600479126
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> #define _GLIBCXX_DEBUG #define rep(i,n) for(int i=0;i<n;++i) #define rrep(i,n) for(int i=n-1;i>=0;--i) #define reps(i,a,b) for(int i=a;i<b;++i) #define fi first #define se second #define pb push_back #define eb emplace_back #define sz(x) (int)(x).size() #define all(v) v.begin(),v.end() #define rall(v) v.rbegin(),v.rend() using namespace std ; using ll = long long ; using P = pair < int , int > ; template < typename T > inline bool chmax ( T & a , T b ) { if ( a < b ) { a = b ; return 1 ; } return 0 ; } template < typename T > inline bool chmin ( T & a , T b ) { if ( b < a ) { a = b ; return 1 ; } return 0 ; } template < typename T > vector < T > make_vec ( size_t a ) { return vector < T > ( a ) ; } template < typename T , typename . . . Ts > auto make_vec ( size_t a , Ts . . . ts ) { return vector < decltype ( make_vec < T > ( ts . . . ) ) > ( a , make_vec < T > ( ts . . . ) ) ; } template < typename T , typename U , typename . . . V > typename enable_if < is_same < T , U > :: value > :: type fill_v ( U & u , const V . . . v ) { u = U ( v . . . ) ; } template < typename T , typename U , typename . . . V > typename enable_if < ! is_same < T , U > :: value > :: type fill_v ( U & u , const V . . . v ) { for ( auto & e : u ) fill_v < T > ( e , v . . . ) ; } struct edge { int to ; long long weight ; } ; vector < vector < edge > > G ; vector < long long > dijkstra ( int s ) { vector < long long > dist ( G . size ( ) , numeric_limits < long long > :: max ( ) ) ; dist [ s ] = 0 ; using P = pair < long long , long long > ; priority_queue < P , vector < P > , greater < P > > que ; que . push ( P ( 0 , s ) ) ; while ( ! que . empty ( ) ) { P p = que . top ( ) ; que . pop ( ) ; int v = p . second ; if ( dist [ v ] < p . first ) continue ; for ( edge e : G [ v ] ) { if ( dist [ e . to ] > dist [ v ] + e . weight ) { dist [ e . to ] = dist [ v ] + e . weight ; que . push ( P ( dist [ e . to ] , e . to ) ) ; } } } return dist ; } int main ( ) { ios :: sync_with_stdio ( false ) ; cin . tie ( nullptr ) ; int v , e , r ; cin > > v > > e > > r ; G . resize ( v ) ; rep ( i , e ) { int s , t , d ; cin > > s > > t > > d ; G [ s ] . pb ( edge { t , d } ) ; } auto dist = dijkstra ( r ) ; rep ( i , v ) { if ( dist [ i ] > 1e18 ) cout << "INF" << endl ; else cout << dist [ i ] << endl ; } }<CODESPLIT>-1.0176359415054321<CODESPLIT>5.7527923583984375<CODESPLIT>-1.2340526580810547<CODESPLIT>-1.2271499633789062<CODESPLIT>-1.118733525276184<CODESPLIT>-1.43380606174469
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> #define int long long struct edge { int to ; int cost ; } ; using namespace std ; using vi = vector < int > ; using vii = vector < vector < int > > ; using vb = vector < bool > ; using qi = queue < int > ; using P = pair < int , int > ; using ge = vector < vector < edge > > ; using gi = vector < vector < int > > ; #define FOR(i, a, b) for (int i = a; i < (b); i++) #define REP(i,n) for(int i=0;i<n;i++) #define delim(i, n) cout << (i == n-1 ? "\n" : " ") #define print1(v) cout << fixed << setprecision(10) << v << "\n" #define print2(v1, v2) cout << fixed << setprecision(10) << v1 << " " << v2 << "\n" #define print3(v1, v2, v3) cout << fixed << setprecision(10) << v1 << " " << v2 << " " << v3 << "\n" #define printvi(v, n) REP(iiii, n) { cout << v[iiii]; delim(iiii, n); } #define printvii(v, h, w) REP(iiiii, h) { printvi(v[iiiii], w); } template < class T > inline bool chmax ( T & a , T b ) { if ( a < b ) { a = b ; return true ; } return false ; } template < class T > inline bool chmin ( T & a , T b ) { if ( a > b ) { a = b ; return true ; } return false ; } const int inf = 1LL << 60 ; const int mod = 1000000007 ; const int maxn = 100000 ; int n , m , r ; ge G ( maxn ) ; vi mindist ( maxn ) ; void printge ( ) { REP ( i , n ) { cout << ( i + 1 ) << ":" ; for ( auto v : G [ i ] ) cout << " " << ( v . to + 1 ) << "(" << v . cost << ")" ; cout << "\n" ; } } void dijkstra ( ) { mindist . assign ( n , inf ) ; priority_queue < P , vector < P > , greater < P > > pq ; mindist [ r ] = 0 ; pq . emplace ( mindist [ r ] , r ) ; while ( ! pq . empty ( ) ) { P p = pq . top ( ) ; pq . pop ( ) ; int v = p . second ; if ( mindist [ v ] < p . first ) continue ; for ( auto & e : G [ v ] ) { if ( mindist [ e . to ] > mindist [ v ] + e . cost ) { mindist [ e . to ] = mindist [ v ] + e . cost ; pq . emplace ( mindist [ e . to ] , e . to ) ; } } } } signed main ( ) { cin . tie ( 0 ) ; ios :: sync_with_stdio ( false ) ; cin > > n > > m > > r ; REP ( i , m ) { edge e ; int s ; cin > > s > > e . to > > e . cost ; G [ s ] . push_back ( e ) ; } dijkstra ( ) ; REP ( i , n ) { if ( mindist [ i ] == inf ) { cout << "INF\n" ; } else { cout << mindist [ i ] << "\n" ; } } }<CODESPLIT>-1.096393346786499<CODESPLIT>5.741443634033203<CODESPLIT>-1.2290871143341064<CODESPLIT>-1.2311663627624512<CODESPLIT>-1.1231623888015747<CODESPLIT>-1.3999873399734497
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#pragma gcc optimize("Ofast") #include <bits/stdc++.h> using namespace std ; #define int long long  using ll = long long ; using lld = long double ; #define P pair<ll,ll> #define Vi vector<ll> #define VVi vector<vector<ll>> #define Vd vector<double> #define Vb vector<bool> #define Vs vector<string> #define Vc vector<char> #define M map<ll,ll> #define S set<ll> #define PQ priority_queue<ll> #define PQG priority_queue<ll,V,greater<ll> template < typename T > struct edge { int src , to ; T cost ; edge ( int to , T cost ) : src ( - 1 ) , to ( to ) , cost ( cost ) { } edge ( int src , int to , T cost ) : src ( src ) , to ( to ) , cost ( cost ) { } edge & operator = ( const int & x ) { to = x ; return * this ; } operator int ( ) const { return to ; } } ; template < typename T > using Edges = vector < edge < T > > ; template < typename T > using WeightedGraph = vector < Edges < T > > ; using UnWeightedGraph = VVi ; template < typename T > using Matrix = vector < vector < T > > ; const int MOD = 1000000007 ; const int INF = 1061109567 ; const double EPS = 1e-10 ; const double PI = acos ( - 1.0 ) ; const int dx [ 4 ] = { 1 , 0 , - 1 , 0 } ; const int dy [ 4 ] = { 0 , 1 , 0 , - 1 } ; #define FOR(i, a, b) for (int i = (a); i < (b); ++i) #define REP(i, n) for (int i = 0; i < (n); ++i) #define PER(i, n) for (int i = (n-1); i >= 0; --i) #define ALL(V) (V).begin(),(V).end() #define SORT(V) sort(ALL(V))  #define REV(V) reverse(ALL(V))  #define RSORT(V) SORT(V);REV(V)  #define NEXP(V) next_permutation(ALL(V))  #define pb(n) emplace_back(n) #define popb pop_back() #define endl '\n' #define Endl '\n' #define DUMP(x)  cout << #x << " = " << (x) << endl class UnionFind { public : vector < int > par ; vector < int > siz ; UnionFind ( int sz_ ) : par ( sz_ ) , siz ( sz_ , 1LL ) { for ( int i = 0 ; i < sz_ ; ++ i ) par [ i ] = i ; } void init ( ll sz_ ) { par . resize ( sz_ ) ; siz . assign ( sz_ , 1LL ) ; for ( int i = 0 ; i < sz_ ; ++ i ) par [ i ] = i ; } int root ( int x ) { while ( par [ x ] ! = x ) { x = par [ x ] = par [ par [ x ] ] ; } return x ; } bool merge ( int x , int y ) { x = root ( x ) ; y = root ( y ) ; if ( x == y ) return false ; if ( siz [ x ] < siz [ y ] ) swap ( x , y ) ; siz [ x ] += siz [ y ] ; par [ y ] = x ; return true ; } bool issame ( int x , int y ) { return root ( x ) == root ( y ) ; } int size ( int x ) { return siz [ root ( x ) ] ; } } ; template < int mod > struct ModInt { int x ; ModInt ( ) : x ( 0 ) { } ModInt ( int64_t y ) : x ( y >= 0 ? y % mod : ( mod - ( - y ) % mod ) % mod ) { } ModInt & operator += ( const ModInt & p ) { if ( ( x += p . x ) >= mod ) x -= mod ; return * this ; } ModInt & operator -= ( const ModInt & p ) { if ( ( x += mod - p . x ) >= mod ) x -= mod ; return * this ; } ModInt & operator *= ( const ModInt & p ) { x = ( int ) ( 1LL * x * p . x % mod ) ; return * this ; } ModInt & operator / = ( const ModInt & p ) { * this *= p . inverse ( ) ; return * this ; } ModInt operator - ( ) const { return ModInt ( - x ) ; } ModInt operator + ( const ModInt & p ) const { return ModInt ( * this ) += p ; } ModInt operator - ( const ModInt & p ) const { return ModInt ( * this ) -= p ; } ModInt operator * ( const ModInt & p ) const { return ModInt ( * this ) *= p ; } ModInt operator / ( const ModInt & p ) const { return ModInt ( * this ) / = p ; } bool operator == ( const ModInt & p ) const { return x == p . x ; } bool operator ! = ( const ModInt & p ) const { return x ! = p . x ; } ModInt inverse ( ) const { int a = x , b = mod , u = 1 , v = 0 , t ; while ( b > 0 ) { t = a / b ; swap ( a -= t * b , b ) ; swap ( u -= t * v , v ) ; } return ModInt ( u ) ; } ModInt pow ( int64_t n ) const { ModInt ret ( 1 ) , mul ( x ) ; while ( n > 0 ) { if ( n & 1 ) ret *= mul ; mul *= mul ; n > >= 1 ; } return ret ; } friend ostream & operator << ( ostream & os , const ModInt & p ) { return os << p . x ; } friend istream & operator > > ( istream & is , ModInt & a ) { int64_t t ; is > > t ; a = ModInt < mod > ( t ) ; return ( is ) ; } static int get_mod ( ) { return mod ; } } ; using modint = ModInt < MOD > ; template < typename T > vector < T > dijkstra ( WeightedGraph < T > & g , int s ) { const auto INF2 = numeric_limits < T > :: max ( ) ; vector < T > dist ( g . size ( ) , INF2 ) ; using Pi = pair < T , int > ; priority_queue < Pi , vector < Pi > , greater < Pi > > que ; dist [ s ] = 0 ; que . emplace ( dist [ s ] , s ) ; while ( ! que . empty ( ) ) { T cost ; int idx ; tie ( cost , idx ) = que . top ( ) ; que . pop ( ) ; if ( dist [ idx ] < cost ) continue ; for ( auto & e : g [ idx ] ) { auto next_cost = cost + e . cost ; if ( dist [ e . to ] <= next_cost ) continue ; dist [ e . to ] = next_cost ; que . emplace ( dist [ e . to ] , e . to ) ; } } return dist ; } void fast ( void ) { cin . tie ( 0 ) ; ios :: sync_with_stdio ( false ) ; cout << fixed << setprecision ( 15 ) ; return ; } ll vsum ( Vi V ) { ll res = 0LL ; REP ( i , V . size ( ) ) res += V [ i ] ; return res ; } lld vave ( Vi V ) { lld size = V . size ( ) ; return ( lld ) vsum ( V ) / size ; } template < typename T > bool mid1 ( T a , T b , T c ) { return ( a < b ) && ( b < c ) ; } template < typename T > bool mid2 ( T a , T b , T c ) { return ( a <= b ) && ( b <= c ) ; } template < typename T > void YES ( T n ) { cout << ( ( n ) ? "YES" : "NO" ) << endl ; } template < typename T > void Yes ( T n ) { cout << ( ( n ) ? "Yes" : "No" ) << endl ; } template < typename T > void yes ( T n ) { cout << ( ( n ) ? "yes" : "no" ) << endl ; } template < typename T > void Yay ( T n ) { cout << ( ( n ) ? "Yay!" : ":(" ) << endl ; } inline void in ( void ) { return ; } template < typename First , typename . . . Rest > void in ( First & first , Rest & . . . rest ) { cin > > first ; in ( rest . . . ) ; return ; } template < typename T > void vin ( T & V ) { REP ( i , V . size ( ) ) { cin > > V [ i ] ; } return ; } inline void out ( void ) { cout << endl ; return ; } template < typename T > void out ( T only ) { cout << only << endl ; return ; } template < typename First , typename . . . Rest > void out ( First first , Rest . . . rest ) { cout << first << " " ; out ( rest . . . ) ; return ; } template < typename T > void vout ( T & V ) { REP ( i , V . size ( ) ) { cout << V [ i ] << endl ; } } template < typename T > void vout2 ( T & V ) { REP ( i , V . size ( ) ) { cout << V [ i ] << " \n" [ i == ( V . size ( ) - 1 ) ] ; } } int gcd ( int a , int b ) { return b ! = 0 ? gcd ( b , a % b ) : a ; } int lcm ( int a , int b ) { return a * b / gcd ( a , b ) ; } string toStrUp ( string str ) { char diff = 'A' - 'a' ; REP ( i , str . size ( ) ) str [ i ] += diff ; return str ; } map < int , int > prime_factor ( int n ) { map < int , int > ret ; for ( int i = 2 ; i * i <= n ; i ++ ) { while ( n % i == 0 ) { ret [ i ] ++ ; n / = i ; } } if ( n ! = 1 ) ret [ n ] = 1 ; return ret ; } bool is_prime ( int x ) { for ( int i = 2 ; i * i <= x ; i ++ ) { if ( x % i == 0 ) return false ; } return true ; } template < typename T > vector < T > convert_base ( T x , T b ) { vector < T > ret ; T t = 1 , k = abs ( b ) ; while ( x ) { ret . emplace_back ( ( x * t ) % k ) ; if ( ret . back ( ) < 0 ) ret . back ( ) += k ; x -= ret . back ( ) * t ; x / = k ; t *= b / k ; } if ( ret . empty ( ) ) ret . emplace_back ( 0 ) ; reverse ( begin ( ret ) , end ( ret ) ) ; return ret ; } template < class T > inline bool chmin ( T & a , T b ) { if ( a > b ) { a = b ; return true ; } return false ; } template < class T > inline bool chmax ( T & a , T b ) { if ( a < b ) { a = b ; return true ; } return false ; } signed main ( ) { fast ( ) ; int n , m , k ; string s ; int v , e , r ; in ( v , e , r ) ; WeightedGraph < int > G ( v ) ; REP ( i , e ) { int a , b , c ; in ( a , b , c ) ; G [ a ] . emplace_back ( b , c ) ; } for ( auto & dist : dijkstra ( G , r ) ) { if ( dist == numeric_limits < int > :: max ( ) ) out ( "INF" ) ; else out ( dist ) ; } }<CODESPLIT>-1.1360759735107422<CODESPLIT>5.712331771850586<CODESPLIT>-1.2333931922912598<CODESPLIT>-1.1896342039108276<CODESPLIT>-1.1021567583084106<CODESPLIT>-1.3605005741119385
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include<bits/stdc++.h> using namespace std ; #define INF 1000000000 vector < int > dijk ( int s , int v , vector < vector < pair < int , int > > > adjlist ) { priority_queue < pair < int , int > > wait ; vector < int > result ( v , INF ) ; result [ s ] = 0 ; wait . push ( make_pair ( 0 , s ) ) ; while ( ! wait . empty ( ) ) { int nowpoint = wait . top ( ) . second ; int nowcost = - wait . top ( ) . first ; wait . pop ( ) ; if ( result [ nowpoint ] < nowcost ) continue ; for ( int i = 0 ; i < adjlist [ nowpoint ] . size ( ) ; i ++ ) { int nextpoint = adjlist [ nowpoint ] [ i ] . second ; int nextcost = nowcost + adjlist [ nowpoint ] [ i ] . first ; if ( result [ nextpoint ] > nextcost ) { result [ nextpoint ] = nextcost ; wait . push ( make_pair ( - nextcost , nextpoint ) ) ; } } } return result ; } int main ( ) { int V , E , S ; cin > > V > > E > > S ; vector < vector < pair < int , int > > > adjlist ( V ) ; for ( int i = 0 ; i < E ; i ++ ) { int a , b , c ; cin > > a > > b > > c ; adjlist [ a ] . push_back ( make_pair ( c , b ) ) ; } vector < int > result ( V ) ; result = dijk ( S , V , adjlist ) ; for ( int i = 0 ; i < V ; i ++ ) { if ( result [ i ] == INF ) cout << "INF" << endl ; else cout << result [ i ] << endl ; } return 0 ; }<CODESPLIT>-0.8993357419967651<CODESPLIT>5.735179424285889<CODESPLIT>-1.2443020343780518<CODESPLIT>-1.2567546367645264<CODESPLIT>-1.1248500347137451<CODESPLIT>-1.3827123641967773
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> #define rep(i, n) for (int i = 0; i < (int)(n); i++) using namespace std ; using ll = long long ; using P = pair < int , int > ; const int INF = 1001001001 ; const int MOD = 1000000007 ; template < typename T > void print ( const T & v ) ; const int V = 100005 ; vector < P > G [ V ] ; ll dist [ V ] ; bool used [ V ] ; void dijkstra ( ll s ) { fill_n ( dist , V , INT_MAX ) ; fill_n ( used , V , false ) ; priority_queue < P , vector < P > , greater < P > > q ; q . push ( P ( 0 , s ) ) ; while ( ! q . empty ( ) ) { ll d , t ; tie ( d , t ) = q . top ( ) ; q . pop ( ) ; if ( used [ t ] ) continue ; used [ t ] = true ; dist [ t ] = d ; for ( P e : G [ t ] ) { if ( dist [ e . second ] <= d + e . first ) continue ; q . push ( P ( d + e . first , e . second ) ) ; } } } int main ( ) { int v , e , r ; cin > > v > > e > > r ; for ( int i = 0 ; i < e ; i ++ ) { int s , t , d ; cin > > s > > t > > d ; G [ s ] . push_back ( make_pair ( d , t ) ) ; } dijkstra ( r ) ; for ( int i = 0 ; i < v ; i ++ ) { if ( dist [ i ] == INT_MAX ) { cout << "INF" << endl ; } else { cout << dist [ i ] << endl ; } } return 0 ; } template < typename T > void print ( T const & v ) { for ( int i = 0 ; i < v . size ( ) ; i ++ ) { if ( i ) cout << ' ' ; cout << v [ i ] ; } cout << endl ; }<CODESPLIT>-1.1053251028060913<CODESPLIT>5.7452497482299805<CODESPLIT>-1.219663381576538<CODESPLIT>-1.2255744934082031<CODESPLIT>-1.1230082511901855<CODESPLIT>-1.3787238597869873
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <iostream> #include <limits> #include <queue> #include <vector> template < typename D > struct link { D destination ; int length ; } ; struct node { int name ; std :: vector < link < node * > > links ; int distance_from_root { std :: numeric_limits < int > :: max ( ) } ; } ; void solve ( std :: vector < node > & nodes , node & root ) { std :: queue < node * > queue ; root . distance_from_root = 0 ; queue . push ( & root ) ; while ( ! queue . empty ( ) ) { auto * target = queue . front ( ) ; queue . pop ( ) ; for ( const auto & link : target -> links ) { auto * neighbor = link . destination ; const auto d = target -> distance_from_root + link . length ; if ( neighbor -> distance_from_root <= d ) continue ; neighbor -> distance_from_root = d ; queue . push ( neighbor ) ; } } } std :: string distance_string ( int distance ) { return distance == std :: numeric_limits < int > :: max ( ) ? "INF" : std :: to_string ( distance ) ; } int main ( ) { int node_count , link_count , root_name ; std :: cin > > node_count > > link_count > > root_name ; std :: vector < node > nodes ( node_count ) ; for ( int i = 0 ; i < link_count ; ++ i ) { int s , t , d ; std :: cin > > s > > t > > d ; auto & n = nodes . at ( s ) ; n . name = s ; n . links . push_back ( link < node * > { & nodes . at ( t ) , d } ) ; } solve ( nodes , nodes . at ( root_name ) ) ; for ( const auto & n : nodes ) { std :: cout << distance_string ( n . distance_from_root ) << std :: endl ; } }<CODESPLIT>-1.0728604793548584<CODESPLIT>5.74102783203125<CODESPLIT>-1.2167288064956665<CODESPLIT>-1.2165696620941162<CODESPLIT>-1.0855436325073242<CODESPLIT>-1.3784860372543335
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> #define P pair<int,int> #define ll long long #define INF 1<<30 using namespace std ; ll V , E , r ; main ( ) { cin > > V > > E > > r ; vector < P > a [ V ] ; for ( int i = 0 ; i < E ; i ++ ) { ll b , c , d ; cin > > b > > c > > d ; a [ b ] . push_back ( make_pair ( c , d ) ) ; } priority_queue < P , vector < P > , greater < P > > q ; ll d [ V ] ; for ( int i = 0 ; i < V ; i ++ ) d [ i ] = INF ; q . push ( make_pair ( 0 , r ) ) ; d [ r ] = 0 ; while ( ! q . empty ( ) ) { ll e , f ; e = q . top ( ) . first ; f = q . top ( ) . second ; q . pop ( ) ; if ( d [ f ] < e ) continue ; for ( int i = 0 ; i < a [ f ] . size ( ) ; i ++ ) { P end = a [ f ] [ i ] ; if ( d [ end . first ] > d [ f ] + end . second ) { d [ end . first ] = d [ f ] + end . second ; q . push ( make_pair ( d [ end . first ] , end . first ) ) ; } } } for ( int i = 0 ; i < V ; i ++ ) { if ( d [ i ] == INF ) cout << "INF" << endl ; else cout << d [ i ] << endl ; } }<CODESPLIT>-1.1054778099060059<CODESPLIT>5.750763416290283<CODESPLIT>-1.2319400310516357<CODESPLIT>-1.2100411653518677<CODESPLIT>-1.0904908180236816<CODESPLIT>-1.3910645246505737
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include<iostream> #include <iomanip> #include<cstdio> #include<string> #include<cstring> #include<climits> #include<algorithm> #include<vector> #include<cmath> #include<map> #include<set> #include<stack> #include<queue> #include<tuple> #include<list> #define ll long long #define pii pair<int,int> #define pll pair<ll,ll> #define vii vector<int> #define vll vector<ll> #define lb lower_bound #define pb push_back #define mp make_pair #define rep(i,n) for(ll i=0;i<n;i++) #define rep2(i,a,b) for(ll i=a;i<b;i++) #define repr(i,n) for(ll i=n-1;i>=0;i--) #define all(x) x.begin(),x.end() #define INF (1 << 30) - 1 #define LLINF (1LL << 61) - 1 using namespace std ; const int MOD = 1000000007 ; const int MAX = 510000 ; struct edge { ll to , cost ; } ; ll n ; vector < edge > G [ 100010 ] ; ll d [ 100010 ] ; void dijkstra ( int s ) { priority_queue < pii , vector < pii > , greater < pii > > que ; fill ( d , d + n , LLINF ) ; d [ s ] = 0 ; que . push ( pii ( 0 , s ) ) ; while ( ! que . empty ( ) ) { pii p = que . top ( ) ; que . pop ( ) ; int v = p . second ; if ( d [ v ] < p . first ) continue ; rep ( i , G [ v ] . size ( ) ) { edge e = G [ v ] [ i ] ; if ( d [ e . to ] > d [ v ] + e . cost ) { d [ e . to ] = d [ v ] + e . cost ; que . push ( pii ( d [ e . to ] , e . to ) ) ; } } } } int main ( ) { cin . tie ( 0 ) ; ios :: sync_with_stdio ( false ) ; ll e , r ; cin > > n > > e > > r ; rep ( i , e ) { ll a , b , c ; cin > > a > > b > > c ; G [ a ] . pb ( { b , c } ) ; } dijkstra ( r ) ; rep ( i , n ) { if ( d [ i ] == LLINF ) cout << "INF" << endl ; else cout << d [ i ] << endl ; } return 0 ; }<CODESPLIT>-0.9906293749809265<CODESPLIT>5.731443405151367<CODESPLIT>-1.2514159679412842<CODESPLIT>-1.2215278148651123<CODESPLIT>-1.1273525953292847<CODESPLIT>-1.4449162483215332
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> #define whlie while #define pb push_back #define eb emplace_back #define fi first #define se second #define rep(i,N) for(int i = 0; i < (N); i++) #define repr(i,N) for(int i = (N) - 1; i >= 0; i--) #define rep1(i,N) for(int i = 1; i <= (N) ; i++) #define repr1(i,N) for(int i = (N) ; i > 0 ; i--) #define each(x,v) for(auto& x : v) #define all(v) (v).begin(),(v).end() #define sz(v) ((int)(v).size()) #define vrep(v,it) for(auto it = v.begin(); it != v.end(); it++) #define vrepr(v,it) for(auto it = v.rbegin(); it != v.rend(); it++) #define ini(...) int __VA_ARGS__; in(__VA_ARGS__) #define inl(...) ll __VA_ARGS__; in(__VA_ARGS__) #define ins(...) string __VA_ARGS__; in(__VA_ARGS__) using namespace std ; void solve ( ) ; using ll = long long ; using vl = vector < ll > ; using vi = vector < int > ; using vvi = vector < vector < int > > ; constexpr int inf = 1001001001 ; constexpr ll infLL = ( 1LL << 61 ) - 1 ; struct IoSetupNya { IoSetupNya ( ) { cin . tie ( nullptr ) ; ios :: sync_with_stdio ( false ) ; cout << fixed << setprecision ( 15 ) ; cerr << fixed << setprecision ( 7 ) ; } } iosetupnya ; template < typename T , typename U > inline bool amin ( T & x , U y ) { return ( y < x ) ? ( x = y , true ) : false ; } template < typename T , typename U > inline bool amax ( T & x , U y ) { return ( x < y ) ? ( x = y , true ) : false ; } template < typename T , typename U > ostream & operator << ( ostream & os , const pair < T , U > & p ) { os << p . first << " " << p . second ; return os ; } template < typename T , typename U > istream & operator > > ( istream & is , pair < T , U > & p ) { is > > p . first > > p . second ; return is ; } template < typename T > ostream & operator << ( ostream & os , const vector < T > & v ) { int s = ( int ) v . size ( ) ; rep ( i , s ) os << ( i ? " " : "" ) << v [ i ] ; return os ; } template < typename T > istream & operator > > ( istream & is , vector < T > & v ) { for ( auto & x : v ) is > > x ; return is ; } void in ( ) { } template < typename T , class . . . U > void in ( T & t , U & . . . u ) { cin > > t ; in ( u . . . ) ; } void out ( ) { cout << "\n" ; } template < typename T , class . . . U > void out ( const T & t , const U & . . . u ) { cout << t ; if ( sizeof . . . ( u ) ) cout << " " ; out ( u . . . ) ; } template < typename T > void die ( T x ) { out ( x ) ; exit ( 0 ) ; } #ifdef NyaanDebug #include "NyaanDebug.h" #define trc(...) do { cerr << #__VA_ARGS__ << " = "; dbg_out(__VA_ARGS__);} while(0) #define trca(v,N) do { cerr << #v << " = "; array_out(v , N);} while(0) #else #define trc(...) #define trca(...) int main ( ) { solve ( ) ; } #endif using P = pair < int , int > ; using vp = vector < P > ; constexpr int MOD = 1000000007 ; template < typename T > struct edge { int src , to ; T cost ; edge ( int to ) : src ( - 1 ) , to ( to ) , cost ( 0 ) { } edge ( int to , T cost ) : src ( - 1 ) , to ( to ) , cost ( cost ) { } edge ( int src , int to , T cost ) : src ( src ) , to ( to ) , cost ( cost ) { } edge & operator = ( const int & x ) { to = x ; return * this ; } operator int ( ) const { return to ; } } ; template < typename T > using Edges = vector < edge < T > > ; template < typename T > using WG = vector < Edges < T > > ; template < typename T > using UWG = vector < vector < int > > ; template < typename T > void dijkstra ( int s , int N , vector < T > & D , WG < T > & G ) { using P = pair < T , int > ; T INF = numeric_limits < T > :: max ( ) / 2 ; rep ( i , N ) D [ i ] = INF ; priority_queue < P , vector < P > , greater < P > > Q ; D [ s ] = 0 ; Q . emplace ( 0 , s ) ; while ( ! Q . empty ( ) ) { P p = Q . top ( ) ; Q . pop ( ) ; int v = p . se ; if ( D [ v ] < p . fi ) continue ; for ( auto & e : G [ v ] ) if ( amin ( D [ e ] , D [ v ] + e . cost ) ) Q . emplace ( D [ e ] , e ) ; } } void solve ( ) { ini ( V , E , S ) ; WG < int > g ( V ) ; rep ( i , E ) { ini ( s , t , d ) ; g [ s ] . eb ( t , d ) ; } vi d ( V ) ; dijkstra < int > ( S , V , d , g ) ; rep ( i , V ) { if ( d [ i ] >= inf ) out ( "INF" ) ; else out ( d [ i ] ) ; } }<CODESPLIT>-0.8221359848976135<CODESPLIT>5.75214958190918<CODESPLIT>-1.253007411956787<CODESPLIT>-1.2705318927764893<CODESPLIT>-1.130548357963562<CODESPLIT>-1.4820507764816284
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> using namespace std ; const int MAX = 100000 ; vector < pair < int , int > > adj [ MAX ] ; int n , m , s ; bool visited [ MAX ] ; int dist [ MAX ] ; int main ( ) { cin > > n > > m > > s ; for ( int i = 0 ; i < m ; i ++ ) { int src , dest , dist ; cin > > src > > dest > > dist ; adj [ src ] . push_back ( make_pair ( dest , dist ) ) ; } priority_queue < pair < int , int > , vector < pair < int , int > > , greater < pair < int , int > > > pq ; pq . push ( make_pair ( 0 , s ) ) ; while ( ! pq . empty ( ) ) { int d = pq . top ( ) . first , node = pq . top ( ) . second ; pq . pop ( ) ; if ( visited [ node ] ) continue ; visited [ node ] = true ; dist [ node ] = d ; for ( auto v : adj [ node ] ) { pq . push ( make_pair ( d + v . second , v . first ) ) ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( visited [ i ] ) cout << dist [ i ] << endl ; else cout << "INF" << endl ; } return 0 ; }<CODESPLIT>-1.1097922325134277<CODESPLIT>5.747625827789307<CODESPLIT>-1.2269407510757446<CODESPLIT>-1.2230069637298584<CODESPLIT>-1.1005407571792603<CODESPLIT>-1.3656944036483765
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include<iostream> #include<algorithm> #include<vector> #include<queue> #include<string> #include<iomanip> #include<sstream> #include<map> #include<cmath> using namespace std ; #define rep(i,n) for(int i = 0;i < n;i++) #define req(i,n) for(int i = 1;i <=n;i++) #define rrep(i,n) for(int i = n -1;i >= 0;i--) #define ALL(a) a.begin(),a.end() typedef long long ll ; typedef long double ld ; const ll MOD = 1000000007 ; const ll INF = 1LL << 60 ; int n , m , x , y , z , w , h , sum , ans ; template < typename A , size_t N , typename T > void Fill ( A ( & array ) [ N ] , const T & val ) { std :: fill ( ( T * ) array , ( T * ) ( array + N ) , val ) ; } struct edge { int to ; ll cost ; edge ( int to , ll cost ) : to ( to ) , cost ( cost ) { } } ; vector < vector < edge > > G ( 100000 ) ; using p = pair < ll , int > ; vector < ll > d ( 100000 , INF ) ; void dijkstra ( int s ) { priority_queue < p , vector < p > , greater < p > > pq ; d [ s ] = 0 ; pq . push ( { 0 , s } ) ; while ( ! pq . empty ( ) ) { p now = pq . top ( ) ; pq . pop ( ) ; int v = now . second ; if ( d [ v ] < now . first ) continue ; for ( edge e : G [ v ] ) { if ( d [ e . to ] > d [ v ] + e . cost ) { d [ e . to ] = d [ v ] + e . cost ; pq . push ( p ( d [ e . to ] , e . to ) ) ; } } } } int main ( void ) { cin > > n > > m > > w ; rep ( i , m ) { cin > > x > > y > > z ; G [ x ] . push_back ( { y , z } ) ; } dijkstra ( w ) ; rep ( i , n ) { if ( d [ i ] == INF ) cout << "INF" << endl ; else cout << d [ i ] << endl ; } }<CODESPLIT>-0.9396846890449524<CODESPLIT>5.755293846130371<CODESPLIT>-1.2506016492843628<CODESPLIT>-1.262421727180481<CODESPLIT>-1.1646804809570312<CODESPLIT>-1.4289969205856323
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> using namespace std ; template < typename T > struct Dijkstra { Dijkstra ( size_t size ) : size ( size ) , G ( size ) { } struct edge { edge ( int to , T cost ) : to ( to ) , cost ( cost ) { } int to ; T cost ; } ; using P = pair < T , int > ; const T inf = numeric_limits < T > :: max ( ) ; size_t size ; vector < vector < edge > > G ; vector < T > d ; void add_edge ( int u , int v , T c ) { G [ u ] . push_back ( edge ( v , c ) ) ; } void build ( int s ) { d . assign ( size , inf ) ; priority_queue < P , vector < P > , greater < P > > q ; d [ s ] = 0 ; q . push ( P ( 0 , s ) ) ; while ( ! q . empty ( ) ) { P p = q . top ( ) ; q . pop ( ) ; int v = p . second ; if ( d [ v ] < p . first ) continue ; for ( auto & e : G [ v ] ) if ( d [ e . to ] > p . first + e . cost ) { d [ e . to ] = p . first + e . cost ; q . push ( P ( d [ e . to ] , e . to ) ) ; } } } T operator [ ] ( int v ) { return d [ v ] ; } } ; int main ( ) { int V , E , r ; cin > > V > > E > > r ; Dijkstra < int > G ( V ) ; for ( int i = 0 ; i < E ; ++ i ) { int s , t , d ; cin > > s > > t > > d ; G . add_edge ( s , t , d ) ; } G . build ( r ) ; for ( int i = 0 ; i < V ; ++ i ) { if ( G [ i ] == G . inf ) { cout << "INF" << endl ; } else { cout << G [ i ] << endl ; } } }<CODESPLIT>-1.1577478647232056<CODESPLIT>5.7317352294921875<CODESPLIT>-1.2119275331497192<CODESPLIT>-1.1927978992462158<CODESPLIT>-1.089436411857605<CODESPLIT>-1.3859970569610596
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> using namespace std ; #define rep(i,n) for(int i=0; i<(n); i++) using ll = long long ; #define int long long using P = pair < int , int > ; vector < P > graph [ 110000 ] ; int dist [ 110000 ] ; const int INF = 1001001001001ll ; signed main ( ) { int v , e , r ; cin > > v > > e > > r ; rep ( i , e ) { int s , t , d ; cin > > s > > t > > d ; graph [ s ] . emplace_back ( t , d ) ; } rep ( i , 110000 ) dist [ i ] = INF ; priority_queue < P , vector < P > , greater < P > > q ; q . emplace ( 0 , r ) ; dist [ r ] = 0 ; while ( q . size ( ) ) { auto hoge = q . top ( ) ; q . pop ( ) ; int now = hoge . second , d = hoge . first ; if ( dist [ now ] < d ) continue ; for ( auto next : graph [ now ] ) { if ( dist [ next . first ] > dist [ now ] + next . second ) { dist [ next . first ] = dist [ now ] + next . second ; q . emplace ( dist [ next . first ] , next . first ) ; } } } rep ( i , v ) { if ( dist [ i ] == INF ) cout << "INF" << endl ; else cout << dist [ i ] << endl ; } return 0 ; }<CODESPLIT>-1.106123685836792<CODESPLIT>5.747570037841797<CODESPLIT>-1.2230618000030518<CODESPLIT>-1.2321083545684814<CODESPLIT>-1.0996826887130737<CODESPLIT>-1.3733553886413574
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include<iostream> #include<vector> #include<algorithm> #include<queue> #include<functional> using namespace std ; using ll = long long ; using pint = pair < int , int > ; int INF = 1 << 30 ; int main ( ) { int V , E , r ; cin > > V > > E > > r ; vector < vector < pint > > G ( V ) ; for ( int i = 0 ; i < E ; i ++ ) { int s , t , d ; cin > > s > > t > > d ; G [ s ] . push_back ( make_pair ( d , t ) ) ; } priority_queue < pint , vector < pint > , greater < pint > > q ; vector < int > dist ( V , INF ) ; dist [ r ] = 0 ; q . push ( make_pair ( 0 , r ) ) ; while ( ! q . empty ( ) ) { pint p = q . top ( ) ; int v = p . second ; q . pop ( ) ; for ( auto np : G [ v ] ) { int nw = np . first ; int nv = np . second ; if ( dist [ nv ] > dist [ v ] + nw ) { dist [ nv ] = dist [ v ] + nw ; q . push ( make_pair ( dist [ nv ] , nv ) ) ; } } } for ( int i = 0 ; i < V ; i ++ ) { if ( dist [ i ] == INF ) cout << "INF" << endl ; else cout << dist [ i ] << endl ; } return 0 ; }<CODESPLIT>-1.124657392501831<CODESPLIT>5.7404704093933105<CODESPLIT>-1.2356839179992676<CODESPLIT>-1.2335789203643799<CODESPLIT>-1.1040421724319458<CODESPLIT>-1.3687466382980347
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> #if LOCAL #include "dump.hpp" #else #define dump(...) #endif using namespace std ; using ll = long long ; const ll LINF = 0x1fffffffffffffff ; #define FOR(i,a,b) for(ll i=(a);i<(b);++i) #define REP(i,n) FOR(i,0,n) template < class T > bool chmax ( T & a , const T & b ) { if ( a < b ) { a = b ; return 1 ; } return 0 ; } template < class T > bool chmin ( T & a , const T & b ) { if ( b < a ) { a = b ; return 1 ; } return 0 ; } template < typename T > struct edge { int src , to ; T cost ; edge ( int _to , T _cost ) : src ( - 1 ) , to ( _to ) , cost ( _cost ) { } edge ( int _src , int _to , T _cost ) : src ( _src ) , to ( _to ) , cost ( _cost ) { } edge & operator = ( const int & x ) { to = x ; return * this ; } operator int ( ) const { return to ; } } ; template < typename T > struct node { vector < edge < T > > edges ; } ; template < typename T > using Edges = vector < edge < T > > ; template < typename T > using WeightedGraph = vector < node < T > > ; using UnWeightedGraph = vector < vector < int > > ; template < typename T > using Matrix = vector < vector < T > > ; template < typename T > vector < T > dijkstra ( const WeightedGraph < T > & g , int s , vector < int > & prev ) { const auto INF = numeric_limits < T > :: max ( ) ; vector < T > dist ( g . size ( ) , INF ) ; prev . assign ( g . size ( ) , - 1 ) ; using Pi = pair < T , int > ; priority_queue < Pi , vector < Pi > , greater < Pi > > que ; dist [ s ] = 0 ; que . emplace ( dist [ s ] , s ) ; while ( ! que . empty ( ) ) { T cost ; int idx ; tie ( cost , idx ) = que . top ( ) ; que . pop ( ) ; if ( dist [ idx ] < cost ) continue ; for ( auto & e : g [ idx ] . edges ) { auto next_cost = cost + e . cost ; if ( dist [ e . to ] <= next_cost ) continue ; dist [ e . to ] = next_cost ; prev [ e . to ] = idx ; que . emplace ( dist [ e . to ] , e . to ) ; } } return dist ; } vector < int > get_path ( int t , const vector < int > & prev ) { vector < int > path ; for ( ; t ! = - 1 ; t = prev [ t ] ) { path . push_back ( t ) ; } reverse ( path . begin ( ) , path . end ( ) ) ; return path ; } int main ( ) { ll V , E ; cin > > V > > E ; ll r ; cin > > r ; WeightedGraph < ll > graph ( V ) ; REP ( i , E ) { ll s , t , d ; cin > > s > > t > > d ; graph . at ( s ) . edges . emplace_back ( t , d ) ; } vector < int > prev ; auto ans = dijkstra ( graph , r , prev ) ; FOR ( i , 0 , ans . size ( ) ) { ll v = ans . at ( i ) ; if ( v == numeric_limits < ll > :: max ( ) ) { cout << "INF" << endl ; } else cout << v << endl ; } return 0 ; }<CODESPLIT>-0.9188005328178406<CODESPLIT>5.767367362976074<CODESPLIT>-1.238471269607544<CODESPLIT>-1.2692334651947021<CODESPLIT>-1.160300374031067<CODESPLIT>-1.43244206905365
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include<cstdio> #include<cstdlib> #include<string> #include<cmath> #include<algorithm> #include<queue> #include<vector> #include<functional> #include<string.h> #include<set> const int MAXN = 1e5 ; const int MAX_E = 5e5 ; const long long INF = ( ( long long ) 1 << 62 ) - 1 ; struct Edge { int vx ; long long w ; bool operator < ( const Edge & e ) { return w < e . w ; } } ; struct NodeInfo { int vx ; long long * d ; bool operator < ( const NodeInfo & node ) { return ( * d ) < * ( node . d ) ; } } ; std :: vector < Edge > graph [ MAXN ] ; long long dist [ MAXN ] ; int pre_vx [ MAXN ] ; int visit [ MAXN ] ; int V , E , r ; void init ( ) { int n = V ; while ( n -- ) { dist [ n ] = INF ; } memset ( pre_vx , - 1 , sizeof ( pre_vx ) ) ; memset ( visit , 0 , sizeof ( pre_vx ) ) ; } void input ( ) { scanf ( "%d%d%d" , & V , & E , & r ) ; for ( int i = 0 ; i < E ; i ++ ) { int s , t , w ; scanf ( "%d%d%d" , & s , & t , & w ) ; graph [ s ] . push_back ( { t , w } ) ; } } void dij_sp ( ) { dist [ r ] = 0 ; std :: priority_queue < std :: pair < long long , int > , std :: vector < std :: pair < long long , int > > , std :: greater < std :: pair < long long , int > > > pq ; pq . push ( std :: make_pair ( 0 , r ) ) ; while ( ! pq . empty ( ) ) { int u = pq . top ( ) . second ; pq . pop ( ) ; if ( visit [ u ] ) { continue ; } if ( dist [ u ] == INF ) { return ; } for ( std :: vector < Edge > :: iterator it = graph [ u ] . begin ( ) ; it ! = graph [ u ] . end ( ) ; it ++ ) { int v = it -> vx ; if ( visit [ v ] ) { continue ; } if ( dist [ v ] > dist [ u ] + it -> w ) { dist [ v ] = dist [ u ] + it -> w ; pq . push ( std :: make_pair ( dist [ v ] , v ) ) ; } } visit [ u ] = 1 ; } } void output ( ) { for ( int i = 0 ; i < V ; i ++ ) { if ( i == r ) { printf ( "0\n" ) ; } else { if ( dist [ i ] == INF ) { printf ( "INF\n" ) ; } else { printf ( "%lld\n" , dist [ i ] ) ; } } } } int main ( ) { input ( ) ; init ( ) ; dij_sp ( ) ; output ( ) ; return 0 ; }<CODESPLIT>-0.9462264180183411<CODESPLIT>5.73391580581665<CODESPLIT>-1.234743595123291<CODESPLIT>-1.2532533407211304<CODESPLIT>-1.1726032495498657<CODESPLIT>-1.3926371335983276
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include<bits/stdc++.h> #define INF 0x3f3f3f3f #define rep(i,n)for(int i=0;i<n;i++) using namespace std ; typedef pair < int , int > P ; vector < P > E [ 100000 ] ; int d [ 100000 ] ; int main ( ) { int v , e , r ; scanf ( "%d%d%d" , & v , & e , & r ) ; rep ( i , e ) { int s , t , d ; scanf ( "%d%d%d" , & s , & t , & d ) ; E [ s ] . push_back ( P ( t , d ) ) ; } memset ( d , 0x3f , sizeof ( d ) ) ; priority_queue < P , vector < P > , greater < P > > que ; d [ r ] = 0 ; que . push ( P ( 0 , r ) ) ; while ( ! que . empty ( ) ) { P p = que . top ( ) ; que . pop ( ) ; if ( p . first ! = d [ p . second ] ) continue ; for ( P u : E [ p . second ] ) { if ( d [ u . first ] > d [ p . second ] + u . second ) { d [ u . first ] = d [ p . second ] + u . second ; que . push ( P ( d [ u . first ] , u . first ) ) ; } } } rep ( i , v ) { if ( d [ i ] == INF ) puts ( "INF" ) ; else printf ( "%d\n" , d [ i ] ) ; } }<CODESPLIT>-1.0289528369903564<CODESPLIT>5.750344276428223<CODESPLIT>-1.2318263053894043<CODESPLIT>-1.237884283065796<CODESPLIT>-1.1483172178268433<CODESPLIT>-1.3940980434417725
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> using namespace std ; typedef long long ll ; #define int long long #define rep(i,n) for(int i=0;i<n;i++) #define MOD 1000000007 #define INF 1000000000000000 #define fi first #define se second #define all(v) v.begin(),v.end() int dx [ ] = { 0 , 1 , 0 , - 1 } , dy [ ] = { 1 , 0 , - 1 , 0 } ; #define pb push_back struct edge { int to , cost ; } ; typedef pair < int , int > P ; int n , m , r , d [ 111111 ] ; vector < edge > v [ 111111 ] ; void dijkstra ( int x ) { fill ( d , d + n , INF ) ; d [ x ] = 0 ; priority_queue < P , vector < P > , greater < P > > q ; q . push ( { x , 0 } ) ; while ( ! q . empty ( ) ) { P p = q . top ( ) ; q . pop ( ) ; for ( edge e : v [ p . first ] ) { if ( d [ e . to ] > d [ p . first ] + e . cost ) { d [ e . to ] = d [ p . first ] + e . cost ; q . push ( { e . to , d [ e . to ] } ) ; } } } } signed main ( ) { cin > > n > > m > > r ; rep ( i , m ) { int a , b , c ; cin > > a > > b > > c ; v [ a ] . pb ( { b , c } ) ; } dijkstra ( r ) ; rep ( i , n ) { if ( d [ i ] == INF ) puts ( "INF" ) ; else cout << d [ i ] << endl ; } return 0 ; }<CODESPLIT>-1.1562349796295166<CODESPLIT>5.7196574211120605<CODESPLIT>-1.2217528820037842<CODESPLIT>-1.207643747329712<CODESPLIT>-1.0989338159561157<CODESPLIT>-1.3855023384094238
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> using namespace std ; #define MAX_V 100000 #define INF 1e9 typedef pair < int , int > pii ; struct edge { int to , d ; } ; int V , E ; int weight [ MAX_V ] ; vector < edge > G [ MAX_V ] ; void dijkstra ( int r ) { priority_queue < pii , vector < pii > , greater < pii > > Q ; Q . push ( pii ( 0 , r ) ) ; weight [ r ] = 0 ; while ( ! Q . empty ( ) ) { pii p = Q . top ( ) ; Q . pop ( ) ; int v = p . second ; if ( weight [ v ] < p . first ) { continue ; } for ( int i = 0 ; i < ( int ) G [ v ] . size ( ) ; i ++ ) { edge & e = G [ v ] [ i ] ; if ( weight [ v ] + e . d < weight [ e . to ] ) { weight [ e . to ] = weight [ v ] + e . d ; Q . push ( pii ( weight [ e . to ] , e . to ) ) ; } } } } void init ( ) { for ( int i = 0 ; i < MAX_V ; i ++ ) { G [ i ] . clear ( ) ; weight [ i ] = INF ; } } int main ( ) { int r , s , t , d ; init ( ) ; cin > > V > > E > > r ; for ( int i = 0 ; i < E ; i ++ ) { cin > > s > > t > > d ; G [ s ] . push_back ( ( edge ) { t , d } ) ; } dijkstra ( r ) ; for ( int i = 0 ; i < V ; i ++ ) { if ( weight [ i ] == INF ) { cout << "INF" << endl ; } else { cout << weight [ i ] << endl ; } } return 0 ; }<CODESPLIT>-1.1090348958969116<CODESPLIT>5.7366862297058105<CODESPLIT>-1.2319543361663818<CODESPLIT>-1.2084792852401733<CODESPLIT>-1.120764136314392<CODESPLIT>-1.3665560483932495
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> using namespace std ; using ll = long long ; using vll = vector < ll > ; using vvll = vector < vll > ; using vc = vector < char > ; using vvc = vector < vc > ; using pll = pair < ll , ll > ; using vpll = vector < pll > ; const ll INF = 1LL << 60 ; const ll MOD = 1e9 + 7 ; #define rep(i, n) for (ll i = 0; i < (n); i++) #define debug(x) cerr << #x << ": " << x << endl; template < typename T1 , typename T2 > inline void chmin ( T1 & a , T2 b ) { if ( a > b ) a = b ; } template < typename T1 , typename T2 > inline void chmax ( T1 & a , T2 b ) { if ( a < b ) a = b ; } template < typename T > struct edge { int src , to ; T cost ; edge ( int to , T cost ) : src ( - 1 ) , to ( to ) , cost ( cost ) { } edge ( int src , int to , T cost ) : src ( src ) , to ( to ) , cost ( cost ) { } edge & operator = ( const int & x ) { to = x ; return * this ; } operator int ( ) const { return to ; } } ; template < typename T > using Edges = vector < edge < T > > ; template < typename T > using WeightedGraph = vector < Edges < T > > ; using UnWeightedGraph = vector < vector < int > > ; template < typename T > using Matrix = vector < vector < T > > ; template < typename T > vector < T > dijkstra ( WeightedGraph < T > & g , int s ) { const auto INF = numeric_limits < T > :: max ( ) ; vector < T > dist ( g . size ( ) , INF ) ; using Pi = pair < T , int > ; priority_queue < Pi , vector < Pi > , greater < Pi > > que ; dist [ s ] = 0 ; que . emplace ( dist [ s ] , s ) ; while ( ! que . empty ( ) ) { T cost ; int idx ; tie ( cost , idx ) = que . top ( ) ; que . pop ( ) ; if ( dist [ idx ] < cost ) continue ; for ( auto & e : g [ idx ] ) { auto next_cost = cost + e . cost ; if ( dist [ e . to ] <= next_cost ) continue ; dist [ e . to ] = next_cost ; que . emplace ( dist [ e . to ] , e . to ) ; } } return dist ; } int main ( ) { ll V , E , r ; cin > > V > > E > > r ; WeightedGraph < ll > g ( V ) ; rep ( i , E ) { ll s , t , d ; cin > > s > > t > > d ; g [ s ] . emplace_back ( t , d ) ; } for ( auto & dist : dijkstra ( g , r ) ) { if ( dist == numeric_limits < ll > :: max ( ) ) cout << "INF" << endl ; else cout << dist << endl ; } }<CODESPLIT>-1.017794132232666<CODESPLIT>5.735507011413574<CODESPLIT>-1.233320951461792<CODESPLIT>-1.254942536354065<CODESPLIT>-1.1509374380111694<CODESPLIT>-1.3925546407699585
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> using namespace std ; template < typename T > struct Edge { int to ; T cost ; } ; using Graph = vector < vector < Edge < long long > > > ; const long long INF = ( 1LL << 60 ) ; template < typename T > void dijkstra ( const Graph & G , int s , vector < T > & dis , vector < int > & prev ) { using P = pair < T , int > ; int N = G . size ( ) ; dis . resize ( N , INF ) ; prev . resize ( N , - 1 ) ; priority_queue < P , vector < P > , greater < P > > pq ; dis [ s ] = 0 ; pq . emplace ( dis [ s ] , s ) ; while ( ! pq . empty ( ) ) { P p = pq . top ( ) ; pq . pop ( ) ; int v = p . second ; if ( dis [ v ] < p . first ) { continue ; } for ( auto & e : G [ v ] ) { if ( dis [ e . to ] > dis [ v ] + e . cost ) { dis [ e . to ] = dis [ v ] + e . cost ; prev [ e . to ] = v ; pq . emplace ( dis [ e . to ] , e . to ) ; } } } } vector < int > get_path ( const vector < int > & prev , int t ) { vector < int > path ; for ( int cur = t ; cur ! = - 1 ; cur = prev [ cur ] ) { path . push_back ( cur ) ; } reverse ( path . begin ( ) , path . end ( ) ) ; return path ; } int main ( ) { int V , E , r ; cin > > V > > E > > r ; Graph G ( V ) ; for ( int i = 0 ; i < E ; i ++ ) { int a , b , c ; cin > > a > > b > > c ; G [ a ] . push_back ( { b , c } ) ; } vector < long long > dis ; vector < int > prev ; dijkstra ( G , r , dis , prev ) ; for ( int i = 0 ; i < V ; i ++ ) { if ( dis [ i ] ! = INF ) { cout << dis [ i ] << endl ; } else { cout << "INF" << endl ; } } return 0 ; }<CODESPLIT>-1.116136074066162<CODESPLIT>5.7300519943237305<CODESPLIT>-1.2268983125686646<CODESPLIT>-1.2213234901428223<CODESPLIT>-1.1007779836654663<CODESPLIT>-1.362134337425232
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <algorithm> #include <cmath> #include <cstdio> #include <deque> #include <iomanip> #include <iostream> #include <map> #include <numeric> #include <queue> #include <set> #include <stack> #include <string> #include <vector> using namespace std ; typedef long long ll ; #define MOD 1000000007 vector < pair < ll , int > > g [ 100000 ] ; vector < ll > dijkstra ( int num , int start ) { priority_queue < pair < ll , int > , vector < pair < ll , int > > , greater < pair < ll , int > > > que ; vector < ll > dp ( num , 1e18 ) ; dp [ start ] = 0 ; que . push ( make_pair ( 0 , start ) ) ; while ( ! que . empty ( ) ) { pair < ll , int > v = que . top ( ) ; que . pop ( ) ; if ( dp [ v . second ] < v . first ) continue ; for ( auto u : g [ v . second ] ) { if ( dp [ v . second ] + u . first < dp [ u . second ] ) { dp [ u . second ] = dp [ v . second ] + u . first ; que . push ( make_pair ( dp [ u . second ] , u . second ) ) ; } } } return dp ; } int main ( ) { int v , e , r ; cin > > v > > e > > r ; for ( int i = 0 ; i < e ; ++ i ) { int s , t , d ; cin > > s > > t > > d ; g [ s ] . push_back ( make_pair ( d , t ) ) ; } vector < ll > ans = dijkstra ( v , r ) ; for ( int i = 0 ; i < v ; ++ i ) { if ( ans [ i ] == 1e18 ) { cout << "INF" << endl ; } else { cout << ans [ i ] << endl ; } } return 0 ; }<CODESPLIT>-1.150769829750061<CODESPLIT>5.736120700836182<CODESPLIT>-1.2258366346359253<CODESPLIT>-1.212660789489746<CODESPLIT>-1.112020492553711<CODESPLIT>-1.3749909400939941
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include<cstdio> #include<iostream> #include<algorithm> #include<queue> using namespace std ; const int INF = 2147483647 ; const int maxn = 100000 ; const int maxm = 500000 ; int n , m , s ; int fir [ maxn ] , nxt [ maxm ] , to [ maxm ] , val [ maxm ] , cnt ; void add_edge ( int u , int v , int w ) { nxt [ ++ cnt ] = fir [ u ] ; fir [ u ] = cnt ; to [ cnt ] = v ; val [ cnt ] = w ; } int dis [ maxn ] , inq [ maxn ] ; void SPFA ( int s ) { for ( int i = 0 ; i < n ; i ++ ) dis [ i ] = INF ; dis [ s ] = 0 ; queue < int > Q ; Q . push ( s ) ; while ( ! Q . empty ( ) ) { int u = Q . front ( ) ; Q . pop ( ) ; for ( int e = fir [ u ] ; e ; e = nxt [ e ] ) { int v = to [ e ] , w = val [ e ] ; if ( dis [ u ] + w < dis [ v ] ) { dis [ v ] = dis [ u ] + w ; if ( ! inq [ v ] ) Q . push ( v ) ; } } } } int main ( ) { scanf ( "%d%d%d" , & n , & m , & s ) ; for ( int u , v , w , i = 0 ; i < m ; i ++ ) { scanf ( "%d%d%d" , & u , & v , & w ) ; add_edge ( u , v , w ) ; } SPFA ( s ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( dis [ i ] == INF ) { printf ( "INF\n" ) ; } else { printf ( "%d\n" , dis [ i ] ) ; } } return 0 ; }<CODESPLIT>-0.7660775780677795<CODESPLIT>5.7166948318481445<CODESPLIT>-1.2621936798095703<CODESPLIT>-1.298099398612976<CODESPLIT>-1.2131057977676392<CODESPLIT>-1.4076296091079712
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> using namespace std ; typedef long long ll ; typedef long double ld ; typedef pair < ll , ll > P ; #define rep(i,n) for(int i=0;i<(int)(n);i++) #define repr(i,n) for(int i=n;i>=0;i--) #define FOR(i,m,n) for(int i=m;i<(int)(n);i++) #define INF 99999999999999 #define MAX_V 100010 struct vertex { vertex ( ll arg_to , ll arg_cost ) { to = arg_to ; cost = arg_cost ; } ll to , cost ; } ; ll V , E , r ; vector < vertex > G [ MAX_V ] ; ll d [ MAX_V ] ; void dijksra ( ll s ) { priority_queue < P , vector < P > , greater < P > > que ; fill ( d , d + V , INF ) ; d [ s ] = 0 ; que . push ( P ( 0 , s ) ) ; while ( ! que . empty ( ) ) { P p = que . top ( ) ; que . pop ( ) ; ll v = p . second ; if ( d [ v ] < p . first ) continue ; for ( ll i = 0 ; i < G [ v ] . size ( ) ; i ++ ) { vertex e = G [ v ] [ i ] ; if ( d [ e . to ] > d [ v ] + e . cost ) { d [ e . to ] = d [ v ] + e . cost ; que . push ( P ( d [ e . to ] , e . to ) ) ; } } } } int main ( ) { cin > > V > > E > > r ; rep ( i , E ) { ll s , t , d ; cin > > s > > t > > d ; G [ s ] . push_back ( vertex ( t , d ) ) ; } dijksra ( r ) ; rep ( i , V ) { if ( d [ i ] == INF ) cout << "INF" << endl ; else cout << d [ i ] << endl ; } return 0 ; }<CODESPLIT>-1.014538288116455<CODESPLIT>5.75665283203125<CODESPLIT>-1.2222540378570557<CODESPLIT>-1.238379716873169<CODESPLIT>-1.1183761358261108<CODESPLIT>-1.4073430299758911
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include "bits/stdc++.h" using namespace std ; using ll = long long ; template < typename T > using V = std :: vector < T > ; using Vi = V < int > ; using VVi = V < V < int > > ; using Vl = V < ll > ; using VVl = V < V < ll > > ; using Vs = V < string > ; template < typename T1 , typename T2 > using P = std :: pair < T1 , T2 > ; using Pii = P < int , int > ; using Pll = P < ll , ll > ; using Pdd = P < double , double > ; template < typename T1 , typename T2 > using M = std :: map < T1 , T2 > ; using Mii = M < int , int > ; using Msi = M < string , int > ; #define REP(i,n) for(int i=0;i<(int)(n);++i) #define REP2(i,s,e) for(int i=(int)(s);i<(int)(e);++i) #define RREP(i,s,e) for(int i=(int)(s);i>=(int)(e);--i) #define FOR(i,c) for(__typeof((c).begin())i=(c).begin(),ie=(c).end();i!=ie;++i) #define ALL(c) (c).begin(), (c).end() const double PI = acos ( - 1 ) ; const ll MOD = 1e9+7 ; int n , m , r ; string s ; int main ( ) { cin > > n > > m > > r ; V < V < Pii > > edges ( n ) ; REP ( i , m ) { int s , t , d ; cin > > s > > t > > d ; edges [ s ] . push_back ( { d , t } ) ; } Vi d ( n , 1e9 ) ; priority_queue < Pii , V < Pii > , greater < Pii > > q ; q . push ( { 0 , r } ) ; d [ r ] = 0 ; while ( ! q . empty ( ) ) { int cost = q . top ( ) . first , node = q . top ( ) . second ; q . pop ( ) ; if ( cost > d [ node ] ) continue ; FOR ( i , edges [ node ] ) { int c = cost + i -> first , v = i -> second ; if ( d [ v ] > c ) { d [ v ] = c ; q . push ( { c , v } ) ; } } } FOR ( i , d ) { if ( * i == 1e9 ) { std :: cout << "INF" << '\n' ; } else { std :: cout << * i << '\n' ; } } return 0 ; }<CODESPLIT>-1.005065679550171<CODESPLIT>5.700525283813477<CODESPLIT>-1.2333920001983643<CODESPLIT>-1.207991361618042<CODESPLIT>-1.1078027486801147<CODESPLIT>-1.4029558897018433
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include<bits/stdc++.h> using namespace std ; typedef long long int ll ; typedef pair < ll , ll > pint ; const int MAX = 510000 ; const int MOD = 1000000007 ; #define rep(i, n) for(ll i = 0; i < (n); i++) #define Rep(i, n) for(ll i = 1; i < (n); i++) #define ALL(a)  (a).begin(),(a).end() #define IOS ios::sync_with_stdio(0); cin.tie(0); cout.tie(0); #define PI 3.14159265358979323846 ll fac [ MAX ] , finv [ MAX ] , inv [ MAX ] ; template < class T > inline bool chmin ( T & a , T b ) { if ( a > b ) { a = b ; return true ; } return false ; } template < class T > inline bool chmax ( T & a , T b ) { if ( a < b ) { a = b ; return true ; } return false ; } void COMinit ( ) { fac [ 0 ] = fac [ 1 ] = 1 ; finv [ 0 ] = finv [ 1 ] = 1 ; inv [ 1 ] = 1 ; for ( ll i = 2 ; i < MAX ; i ++ ) { fac [ i ] = fac [ i - 1 ] * i % MOD ; inv [ i ] = MOD - inv [ MOD % i ] * ( MOD / i ) % MOD ; finv [ i ] = finv [ i - 1 ] * inv [ i ] % MOD ; } } ll Len ( ll n ) { ll s = 0 ; while ( n ! = 0 ) s ++ , n / = 10 ; return s ; } ll Sint ( ll n ) { ll m = 0 , s = 0 , a = n ; while ( a ! = 0 ) s ++ , a / = 10 ; for ( ll i = s - 1 ; i >= 0 ; i -- ) m += n / ( ( ll ) pow ( 10 , i ) ) - ( n / ( ( ll ) pow ( 10 , i + 1 ) ) ) * 10 ; return m ; } ll Svec ( vector < ll > v ) { ll n = 0 ; for ( ll i = 0 ; i < v . size ( ) ; i ++ ) n += v [ i ] ; return n ; } ll GCD ( ll a , ll b ) { return b ? GCD ( b , a % b ) : a ; } ll LCM ( ll a , ll b ) { return a / GCD ( a , b ) * b ; } ll Factorial ( ll n ) { ll m = 1 ; while ( n >= 1 ) m *= n , n -- ; return m ; } void runlength ( string s , vector < pair < char , ll > > & p ) { ll x = 1 ; if ( s . size ( ) == 1 ) { p . push_back ( pair < char , ll > ( s [ 0 ] , 1 ) ) ; } for ( ll i = 0 ; i < s . size ( ) - 1 ; i ++ ) { if ( s [ i ] == s [ i + 1 ] ) { x ++ ; if ( i == s . size ( ) - 2 ) { p . push_back ( pair < char , ll > ( s [ i ] , x ) ) ; } } else { p . push_back ( pair < char , ll > ( s [ i ] , x ) ) ; x = 1 ; if ( i == s . size ( ) - 2 ) { p . push_back ( pair < char , ll > ( s [ s . size ( ) - 1 ] , x ) ) ; } } } } ll COM ( ll n , ll k ) { if ( n < k ) return 0 ; if ( n < 0 || k < 0 ) return 0 ; return fac [ n ] * ( finv [ k ] * finv [ n - k ] % MOD ) % MOD ; } string Toupper ( string s ) { string ans = "" ; rep ( i , s . size ( ) ) { if ( 'a' <= s [ i ] && s [ i ] <= 'z' ) ans += ( char ) s [ i ] - 32 ; else ans += s [ i ] ; } return ans ; } string Tolower ( string s ) { string ans = "" ; rep ( i , s . size ( ) ) { if ( 'A' <= s [ i ] && s [ i ] <= 'Z' ) ans += ( char ) s [ i ] + 32 ; else ans += s [ i ] ; } return ans ; } const int MAX_N = 100010 ; vector < bool > sieve_of_eratosthenes ( ) { vector < bool > isPrime ( MAX_N + 1 , true ) ; for ( int i = 2 ; i <= MAX_N ; i ++ ) { if ( isPrime [ i ] ) { for ( int j = 2 * i ; j <= MAX_N ; j += i ) { isPrime [ j ] = false ; } } } return isPrime ; } vector < pint > prime_factorize ( ll n ) { vector < pint > ans ; for ( ll p = 2 ; p <= sqrt ( n ) ; p ++ ) { if ( n % p ! = 0 ) continue ; ll cnt = 0 ; while ( n % p == 0 ) { n / = p ; cnt ++ ; } ans . push_back ( make_pair ( p , cnt ) ) ; } if ( n ! = 1 ) ans . push_back ( make_pair ( n , 1 ) ) ; return ans ; } const int MAX_V = 100010 ; struct edge { ll to , cost ; } ; typedef pair < ll , ll > pint ; ll n ; ll INF = 1e12 ; vector < edge > graph [ MAX_V ] ; ll dist [ MAX_V ] ; void dijkstra ( ll s ) { priority_queue < pint , vector < pint > , greater < pint > > que ; fill ( dist , dist + n , INF ) ; dist [ s ] = 0 ; que . push ( pint ( 0 , s ) ) ; while ( ! que . empty ( ) ) { auto p = que . top ( ) ; que . pop ( ) ; ll v = p . second ; if ( dist [ v ] < p . first ) continue ; for ( auto e : graph [ v ] ) { if ( dist [ e . to ] > dist [ v ] + e . cost ) { dist [ e . to ] = dist [ v ] + e . cost ; que . push ( pint ( dist [ e . to ] , e . to ) ) ; } } } } int main ( ) { IOS ; ll m , r ; cin > > n > > m > > r ; rep ( i , m ) { ll a , b , c ; cin > > a > > b > > c ; graph [ a ] . push_back ( edge { b , c } ) ; } dijkstra ( r ) ; rep ( i , n ) { if ( dist [ i ] == INF ) cout << "INF" << endl ; else cout << dist [ i ] << endl ; } }<CODESPLIT>-1.0379600524902344<CODESPLIT>5.763427734375<CODESPLIT>-1.235586404800415<CODESPLIT>-1.2179083824157715<CODESPLIT>-1.1316921710968018<CODESPLIT>-1.4192839860916138
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include<stdio.h> #include<assert.h> namespace beet { template < typename T > struct Vector { int sz , cap ; T * data ; Vector ( ) : sz ( 0 ) , cap ( 1 ) { data = new T [ cap ] ; } Vector ( int sz ) : sz ( sz ) , cap ( sz << 1 ) { data = new T [ cap ] ; } Vector ( int sz , T t ) : sz ( sz ) , cap ( sz << 1 ) { data = new T [ cap ] ; for ( int i = 0 ; i < sz ; i ++ ) data [ i ] = t ; } ~ Vector ( ) { delete [ ] data ; } void resolve ( ) { T * tmp = new T [ cap ] ; for ( int i = 0 ; i < sz ; i ++ ) tmp [ i ] = data [ i ] ; delete [ ] data ; data = tmp ; } void push_back ( T x ) { if ( sz >= cap ) { cap << = 1 ; assert ( sz < cap ) ; resolve ( ) ; } data [ sz ++ ] = x ; } void pop_back ( ) { sz -- ; } int size ( ) const { return sz ; } const T operator [ ] ( int x ) const { return data [ x ] ; } T & operator [ ] ( int x ) { assert ( 0 <= x && x < sz ) ; return data [ x ] ; } } ; template < typename T > void swap ( T & a , T & b ) { T x = a ; a = b ; b = x ; } template < typename T > struct PriorityQueue { Vector < T > heap ; PriorityQueue ( ) : heap ( 1 ) { } void push ( T t ) { heap . push_back ( t ) ; int v = heap . size ( ) - 1 ; while ( v > > 1 ) { int p = v > > 1 ; if ( heap [ v ] < heap [ p ] ) swap ( heap [ v ] , heap [ p ] ) ; v = p ; } } T top ( ) const { return heap [ 1 ] ; } void dfs ( int v ) { int l = ( v << 1 ) | 0 ; int r = ( v << 1 ) | 1 ; int nx = v ; if ( l < heap . size ( ) && heap [ l ] < heap [ nx ] ) nx = l ; if ( r < heap . size ( ) && heap [ r ] < heap [ nx ] ) nx = r ; if ( nx == v ) return ; swap ( heap [ v ] , heap [ nx ] ) ; dfs ( nx ) ; } void pop ( ) { assert ( heap . size ( ) > 1 ) ; swap ( heap [ 1 ] , heap [ heap . size ( ) - 1 ] ) ; heap . pop_back ( ) ; dfs ( 1 ) ; } bool empty ( ) const { assert ( heap . size ( ) >= 1 ) ; return heap . size ( ) == 1 ; } } ; } using namespace beet ; const int INF = 1e9 ; struct Node { int v , cost ; Node ( ) { } Node ( int v , int cost ) : v ( v ) , cost ( cost ) { } bool operator < ( const Node & a ) const { return cost < a . cost ; } } ; struct Edge { int to , cost ; Edge ( ) { } Edge ( int to , int cost ) : to ( to ) , cost ( cost ) { } } ; int main ( ) { int V , E , r ; scanf ( "%d %d %d" , & V , & E , & r ) ; Vector < Vector < Edge > > G ( V ) ; for ( int i = 0 ; i < E ; i ++ ) { int s , t , d ; scanf ( "%d %d %d" , & s , & t , & d ) ; G [ s ] . push_back ( Edge ( t , d ) ) ; } PriorityQueue < Node > pq ; Vector < int > dist ( V , INF ) ; dist [ r ] = 0 ; pq . push ( Node ( r , dist [ r ] ) ) ; while ( ! pq . empty ( ) ) { Node res = pq . top ( ) ; pq . pop ( ) ; int v = res . v ; if ( dist [ v ] < res . cost ) continue ; for ( int i = 0 ; i < G [ v ] . size ( ) ; i ++ ) { int u = G [ v ] [ i ] . to , d = G [ v ] [ i ] . cost ; if ( dist [ v ] + d >= dist [ u ] ) continue ; dist [ u ] = dist [ v ] + d ; pq . push ( Node ( u , dist [ u ] ) ) ; } } for ( int i = 0 ; i < V ; i ++ ) { if ( dist [ i ] < INF ) printf ( "%d\n" , dist [ i ] ) ; else printf ( "INF\n" ) ; } return 0 ; }<CODESPLIT>-0.7193707823753357<CODESPLIT>5.736051559448242<CODESPLIT>-1.2739195823669434<CODESPLIT>-1.2734615802764893<CODESPLIT>-1.176777958869934<CODESPLIT>-1.471376657485962
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#pragma GCC target("avx") #include <vector> #include <algorithm> template < class T > struct radix_heap { using key_type = unsigned ; std :: vector < std :: pair < key_type , T > > bucket [ 33 ] ; key_type size , last ; radix_heap ( ) : size ( 0 ) , last ( 0 ) { } bool empty ( ) const { return size == 0 ; } inline int getbit ( int a ) { return a ? 32 - __builtin_clz ( a ) : 0 ; } void push ( key_type key , const T & value ) { size ++ ; bucket [ getbit ( key ^ last ) ] . emplace_back ( key , value ) ; } std :: pair < key_type , T > pop ( ) { if ( bucket [ 0 ] . empty ( ) ) { int idx = 1 ; while ( bucket [ idx ] . empty ( ) ) idx ++ ; last = std :: min_element ( std :: begin ( bucket [ idx ] ) , end ( bucket [ idx ] ) ) -> first ; for ( auto & p : bucket [ idx ] ) bucket [ getbit ( p . first ^ last ) ] . emplace_back ( p ) ; bucket [ idx ] . clear ( ) ; } size -- ; auto ret = bucket [ 0 ] . back ( ) ; bucket [ 0 ] . pop_back ( ) ; return ret ; } } ; using namespace std ; template < class T , class Compare > struct pairing_heap { struct node { T val ; node * head ; node * next ; node ( ) : head ( nullptr ) , next ( nullptr ) { } node ( const T & v ) : val ( v ) , head ( nullptr ) , next ( nullptr ) { } } ; static size_t ni ; static node n [ 505050 ] ; size_t sz ; node * root ; Compare comp ; pairing_heap ( ) : sz ( 0 ) , root ( nullptr ) { } node * merge ( node * x , node * y ) { if ( ! y ) return x ; if ( ! x ) return y ; if ( comp ( y -> val , x -> val ) ) swap ( x , y ) ; y -> next = x -> head ; x -> head = y ; return x ; } node * mergeList ( node * x ) { node * nn = nullptr ; while ( x ) { node * a = x ; node * b = nullptr ; x = x -> next ; a -> next = nullptr ; if ( x ) { b = x ; x = x -> next ; b -> next = nullptr ; } a = merge ( a , b ) ; a -> next = nn ; nn = a ; } while ( nn ) { node * j = nn ; nn = nn -> next ; x = merge ( j , x ) ; } return x ; } T top ( ) { return root -> val ; } void pop ( ) { -- sz ; node * te = root ; root = mergeList ( root -> head ) ; } void push ( const T & x ) { ++ sz ; n [ ni ] . val = x ; root = merge ( & n [ ni ++ ] , root ) ; } size_t size ( ) { return sz ; } bool empty ( ) const { return sz == 0 ; } void meld ( pairing_heap < T , Compare > & h ) { root = merge ( root , h . root ) ; h . root = nullptr ; h . sz = 0 ; } } ; #include <vector> #include <queue> template < class T , class Comp > typename pairing_heap < T , Comp > :: node pairing_heap < T , Comp > :: n [ 505050 ] ; template < class T , class Comp > std :: size_t pairing_heap < T , Comp > :: ni = 0 ; template < class V , class W , class Delta , class Index > std :: vector < W > dijkstra ( std :: size_t N , W inf , V s , Delta delta , Index index ) { std :: vector < W > dist ( N , inf ) ; using P = std :: pair < W , V > ; radix_heap < V > que ; que . push ( dist [ index ( s ) ] = W ( ) , s ) ; while ( ! que . empty ( ) ) { auto p = que . pop ( ) ; W d = p . first ; V v = p . second ; if ( dist [ index ( v ) ] < d ) continue ; delta ( v , [ & ] ( V t , W weight ) { if ( dist [ index ( t ) ] > dist [ index ( v ) ] + weight ) { que . push ( dist [ index ( t ) ] = dist [ index ( v ) ] + weight , t ) ; } } ) ; } return dist ; } #include <vector> #include <queue> template < class V , class W , class Delta , class Index > std :: vector < W > dijkstra2 ( std :: size_t N , W inf , V s , Delta delta , Index index ) { std :: vector < W > dist ( N , inf ) ; using P = std :: pair < W , V > ; pairing_heap < P , std :: less < P > > que ; que . push ( { dist [ index ( s ) ] = W ( ) , s } ) ; while ( ! que . empty ( ) ) { W d = que . top ( ) . first ; V v = que . top ( ) . second ; que . pop ( ) ; if ( dist [ index ( v ) ] < d ) continue ; delta ( v , [ & ] ( V t , W weight ) { if ( dist [ index ( t ) ] > dist [ index ( v ) ] + weight ) { que . push ( { dist [ index ( t ) ] = dist [ index ( v ) ] + weight , t } ) ; } } ) ; } return dist ; } #include <iostream> int main ( ) { std :: cin . tie ( nullptr ) ; std :: ios :: sync_with_stdio ( false ) ; int N , M , R ; std :: cin > > N > > M > > R ; std :: vector < std :: vector < std :: pair < int , unsigned > > > G ( N ) ; for ( int i = 0 ; i < M ; i ++ ) { int s , t ; unsigned d ; std :: cin > > s > > t > > d ; G [ s ] . emplace_back ( t , d ) ; } auto res = dijkstra2 ( N , unsigned ( 1e9 + 1 ) , R , [ & ] ( int v , auto func ) { for ( const auto & e : G [ v ] ) { func ( e . first , e . second ) ; } } , [ & ] ( int v ) { return v ; } ) ; for ( int i = 0 ; i < N ; i ++ ) { if ( res [ i ] == unsigned ( 1e9 + 1 ) ) std :: cout << "INF\n" ; else std :: cout << res [ i ] << "\n" ; } }<CODESPLIT>-1.0281718969345093<CODESPLIT>5.736534595489502<CODESPLIT>-1.2362594604492188<CODESPLIT>-1.2197387218475342<CODESPLIT>-1.1259351968765259<CODESPLIT>-1.4079707860946655
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <iostream> #include <vector> #include <queue> #include <utility> #include <math.h> #include <functional> using namespace std ; typedef long long ll ; int v , e , r ; struct edge { int cost ; int to ; } ; vector < edge > edges [ 100001 ] ; int main ( ) { cin > > v > > e > > r ; for ( int i = 0 ; i < e ; i ++ ) { int s , t , d ; cin > > s > > t > > d ; edge pre = { d , t } ; edges [ s ] . push_back ( pre ) ; } ll ans [ 100001 ] ; for ( int i = 0 ; i < 100001 ; i ++ ) ans [ i ] = 2001001001 ; ans [ r ] = 0 ; typedef pair < ll , ll > P ; priority_queue < P , vector < P > , greater < P > > pq ; pq . push ( P ( 0 , r ) ) ; while ( ! pq . empty ( ) ) { P miria = pq . top ( ) ; pq . pop ( ) ; r = miria . second ; if ( ans [ r ] < miria . first ) { continue ; } for ( int i = 0 ; i < edges [ r ] . size ( ) ; i ++ ) { if ( ans [ edges [ r ] [ i ] . to ] > ans [ r ] + edges [ r ] [ i ] . cost ) { pq . push ( P ( ans [ r ] + edges [ r ] [ i ] . cost , edges [ r ] [ i ] . to ) ) ; ans [ edges [ r ] [ i ] . to ] = ans [ r ] + edges [ r ] [ i ] . cost ; } } } for ( int i = 0 ; i < v ; i ++ ) { if ( ans [ i ] < 2001001000 ) cout << ans [ i ] << endl ; else cout << "INF" << endl ; } return 0 ; }<CODESPLIT>-1.069685935974121<CODESPLIT>5.748048782348633<CODESPLIT>-1.2364031076431274<CODESPLIT>-1.2393412590026855<CODESPLIT>-1.1303973197937012<CODESPLIT>-1.3897861242294312
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> #define rep(i, n) for (int i = 0; i < n; i++) using namespace std ; using ll = long long ; const ll INF = 1001001001 ; int main ( ) { int V , e ; ll r ; cin > > V > > e > > r ; pair < int , int > bridges [ e ] ; ll cost [ e ] ; vector < ll > d ( V , INF ) ; d [ r ] = 0 ; rep ( i , e ) { int s , t ; ll d ; cin > > s > > t > > d ; bridges [ i ] . first = s ; bridges [ i ] . second = t ; cost [ i ] = d ; } rep ( i , V ) { bool update = false ; rep ( j , e ) { int u = bridges [ j ] . first , v = bridges [ j ] . second ; if ( d [ v ] > d [ u ] + cost [ j ] ) { d [ v ] = d [ u ] + cost [ j ] ; update = true ; } } if ( ! update ) break ; } rep ( i , V ) { if ( d [ i ] == INF ) cout << "INF" << endl ; else cout << d [ i ] << endl ; } return 0 ; }<CODESPLIT>-0.982258677482605<CODESPLIT>5.753673553466797<CODESPLIT>-1.2373884916305542<CODESPLIT>-1.2385683059692383<CODESPLIT>-1.125860333442688<CODESPLIT>-1.4189448356628418
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#define _CRT_SECURE_NO_WARNINGS #pragma GCC target("avx") #pragma GCC optimize("O3") #include <algorithm> #include <bitset> #include <cassert> #include <cfloat> #include <climits> #include <cmath> #include <complex> #include <ctime> #include <deque> #include <fstream> #include <functional> #include <iomanip> #include <iostream> #include <iterator> #include <list> #include <map> #include <memory> #include <queue> #include <random> #include <set> #include <stack> #include <string> #include <string.h> #include <unordered_map> #include <unordered_set> #include <utility> #include <vector> #define rep(i,n) for(int i=0;i<(lint)(n);i++) #define REP(i,n) for(int i=1;i<=(lint)(n);i++) #define all(V) V.begin(),V.end() #define stackReplaceBegin(size)\<CODESPLIT>-0.8769317269325256<CODESPLIT>5.70875358581543<CODESPLIT>-1.2959036827087402<CODESPLIT>-1.214862585067749<CODESPLIT>-1.143801212310791<CODESPLIT>-1.4132393598556519
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include<iostream> #include<cmath> #include<algorithm> #include<string> #include<vector> #include<stack> #include<queue> #include<set> #include<map> #include<iomanip> #include<bitset> using namespace std ; typedef long long ll ; typedef pair < ll , ll > P ; typedef pair < ll , P > P1 ; typedef pair < P , P > P2 ; #define pu push #define pb push_back #define mp make_pair #define eps 1e-7 #define INF 1000000000 #define fi first #define sc second #define rep(i,x) for(ll i=0;i<x;i++) #define repn(i,x) for(ll i=1;i<=x;i++) #define SORT(x) sort(x.begin(),x.end()) #define ERASE(x) x.erase(unique(x.begin(),x.end()),x.end()) #define POSL(x,v) (lower_bound(x.begin(),x.end(),v)-x.begin()) #define POSU(x,v) (upper_bound(x.begin(),x.end(),v)-x.begin()) const int MAX = 510000 ; const int MOD = 1000000007 ; struct Edge { ll to ; ll cost ; Edge ( ll t , ll w ) : to ( t ) , cost ( w ) { } } ; ll V , d [ MAX ] ; vector < Edge > G [ MAX ] ; void dijkstra ( ll s ) { fill ( d , d + V , INF ) ; d [ s ] = 0 ; priority_queue < P , vector < P > , greater < P > > que ; que . push ( P ( 0 , s ) ) ; while ( ! que . empty ( ) ) { P p = que . top ( ) ; que . pop ( ) ; ll v = p . second ; if ( d [ v ] < p . first ) { continue ; } for ( auto e : G [ v ] ) { if ( d [ e . to ] > d [ v ] + e . cost ) { d [ e . to ] = d [ v ] + e . cost ; que . push ( P ( d [ e . to ] , e . to ) ) ; } } } } int main ( ) { ll M ; cin > > V > > M ; ll r ; cin > > r ; rep ( i , M ) { ll a , b , c ; cin > > a > > b > > c ; G [ a ] . pb ( Edge ( b , c ) ) ; } dijkstra ( r ) ; rep ( i , V ) { if ( d [ i ] == INF ) cout << "INF" << endl ; else cout << d [ i ] << endl ; } }<CODESPLIT>-1.0499451160430908<CODESPLIT>5.746408462524414<CODESPLIT>-1.2352004051208496<CODESPLIT>-1.2188165187835693<CODESPLIT>-1.1290069818496704<CODESPLIT>-1.4272626638412476
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> using namespace std ; #define rep(i,n) for (int i = 0;i < (int)(n); ++i) template < class T > inline bool chmax ( T & a , T b ) { if ( a < b ) { a = b ; return 1 ; } return 0 ; } template < class T > inline bool chmin ( T & a , T b ) { if ( a > b ) { a = b ; return 1 ; } return 0 ; } typedef long long ll ; const int mod = 1e9+7 ; const int INF = numeric_limits < int > :: max ( ) ; const double PI = acos ( - 1.0 ) ; struct edge { int to ; int cost ; edge ( int t , int c ) : to ( t ) , cost ( c ) { } } ; typedef pair < int , int > P ; int main ( ) { int V , E , r ; cin > > V > > E > > r ; vector < edge > G [ V ] ; for ( int i = 0 ; i < E ; ++ i ) { int s , t , d ; cin > > s > > t > > d ; G [ s ] . push_back ( edge ( t , d ) ) ; } vector < int > d ( V , INF ) ; d [ r ] = 0 ; priority_queue < P , vector < P > , greater < P > > queue ; queue . push ( P ( 0 , r ) ) ; while ( ! queue . empty ( ) ) { P u = queue . top ( ) ; queue . pop ( ) ; int v = u . second ; if ( d [ v ] < u . first ) continue ; for ( int i = 0 ; i < G [ v ] . size ( ) ; ++ i ) { edge e = G [ v ] [ i ] ; if ( d [ e . to ] > d [ v ] + e . cost ) { d [ e . to ] = d [ v ] + e . cost ; queue . push ( P ( d [ e . to ] , e . to ) ) ; } } } for ( int i = 0 ; i < V ; ++ i ) { if ( d [ i ] == INF ) cout << "INF" << endl ; else cout << d [ i ] << endl ; } }<CODESPLIT>-0.9086939692497253<CODESPLIT>5.7428460121154785<CODESPLIT>-1.2451542615890503<CODESPLIT>-1.2528711557388306<CODESPLIT>-1.1698516607284546<CODESPLIT>-1.409031629562378
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <cstdio> #include <iostream> #include <vector> #include <queue> #include <tuple> #define REP(i,n) for (int i=0;i<(n);++i) using namespace std ; using ll = long long ; enum value_class_type { finite_class , pos_inf_class , neg_inf_class } ; template < class T > struct non_standard { value_class_type value_class ; T value ; non_standard ( T value ) : value_class ( value_class_type :: finite_class ) , value ( value ) { } non_standard ( value_class_type value_class , T value ) : value_class ( value_class ) , value ( value ) { } inline bool is_finite ( ) const { return value_class == value_class_type :: finite_class ; } inline bool is_pos_inf ( ) const { return value_class == value_class_type :: pos_inf_class ; } inline bool is_neg_inf ( ) const { return value_class == value_class_type :: neg_inf_class ; } static inline non_standard pos_inf ( ) { return non_standard ( value_class_type :: pos_inf_class , 0 ) ; } static inline non_standard neg_inf ( ) { return non_standard ( value_class_type :: neg_inf_class , 0 ) ; } friend std :: ostream & operator << ( std :: ostream & os , const non_standard x ) { if ( x . is_finite ( ) ) { os << x . value ; } else if ( x . is_pos_inf ( ) ) { os << "INF" ; } else if ( x . is_neg_inf ( ) ) { os << "-INF" ; } return os ; } } ; struct edge { typedef size_t weight_type ; size_t m_to ; edge ( size_t to ) : m_to ( to ) { } inline size_t to ( ) const { return m_to ; } inline weight_type weight ( ) const { return 1 ; } friend std :: ostream & operator << ( std :: ostream & os , const edge & e ) { os << "{ to: " << e . m_to << " }" ; return os ; } } ; template < typename Weight > struct weighted_edge : public edge { typedef Weight weight_type ; weight_type m_weight ; weighted_edge ( size_t to , weight_type weight ) : edge ( to ) , m_weight ( weight ) { } inline weight_type weight ( ) const { return m_weight ; } } ; template < class Edge > struct graph { typedef Edge edge_type ; size_t m_n_vertices ; vector < vector < edge_type > > m_edges ; graph ( size_t n_vertices ) : m_n_vertices ( n_vertices ) , m_edges ( n_vertices ) { } inline size_t n_vertices ( ) const { return m_n_vertices ; } inline void make_edge ( size_t from , size_t to , typename edge_type :: weight_type weight ) { m_edges [ from ] . emplace_back ( edge_type ( to , weight ) ) ; } inline void make_edge ( size_t from , size_t to ) { m_edges [ from ] . emplace_back ( edge ( to ) ) ; } inline void make_edge ( size_t from , const edge_type & e ) { m_edges [ from ] . emplace_back ( e ) ; } inline vector < edge_type > edges_from ( size_t v ) const { return m_edges [ v ] ; } } ; template < class Graph > vector < non_standard < typename Graph :: edge_type :: weight_type > > dijkstra ( const Graph & g , size_t start ) { using Edge = typename Graph :: edge_type ; using Weight = typename Edge :: weight_type ; using ExtendedWeight = non_standard < Weight > ; using P = pair < Weight , size_t > ; vector < ExtendedWeight > dp ( g . n_vertices ( ) , ExtendedWeight :: pos_inf ( ) ) ; priority_queue < P , vector < P > , greater < P > > q ; dp [ start ] = ExtendedWeight ( 0 ) ; q . emplace ( dp [ start ] . value , start ) ; while ( ! q . empty ( ) ) { Weight w0 ; size_t v0 ; tie ( w0 , v0 ) = q . top ( ) ; q . pop ( ) ; if ( dp [ v0 ] . value < w0 ) continue ; for ( const Edge & e : g . edges_from ( v0 ) ) { size_t v1 = e . to ( ) ; Weight w1 = w0 + e . weight ( ) ; if ( dp [ v1 ] . is_pos_inf ( ) || dp [ v1 ] . value > w1 ) { dp [ v1 ] = w1 ; q . emplace ( dp [ v1 ] . value , v1 ) ; } } } return dp ; } int main ( ) { cin . tie ( 0 ) ; ios :: sync_with_stdio ( false ) ; using Edge = weighted_edge < ll > ; using Graph = graph < Edge > ; int V , E , r ; cin > > V > > E > > r ; Graph g ( V ) ; REP ( _ , E ) { int s , t , d ; cin > > s > > t > > d ; g . make_edge ( s , t , d ) ; } auto dp = dijkstra ( g , r ) ; REP ( i , V ) { cout << dp [ i ] << '\n' ; } cout << flush ; return 0 ; }<CODESPLIT>-1.015127182006836<CODESPLIT>5.7409491539001465<CODESPLIT>-1.2423574924468994<CODESPLIT>-1.215583324432373<CODESPLIT>-1.156389594078064<CODESPLIT>-1.4441841840744019
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <iostream> #include <algorithm> #include <vector> #include <queue> using namespace std ; typedef long long ll ; #define rep(i,s,n)for(ll i=s;i<n;i++) #define repe(i,s,n)for(ll i=s;i<=n;i++) static const ll MOD = 1e9 + 7 ; static const ll INF = ( ll ) 1 << 62 ; static const ll MAX_N = 100001 ; static const ll MAX_M = 200001 ; ll V ; struct edge { ll to , cost ; } ; vector < edge > G [ MAX_N ] ; ll d [ MAX_N ] ; typedef pair < ll , ll > P ; priority_queue < P , vector < P > , greater < P > > que ; void dijkstra ( ll s ) { fill ( d , d + V , INF ) ; d [ s ] = 0 ; que . push ( P ( 0 , s ) ) ; while ( ! que . empty ( ) ) { P p = que . top ( ) ; que . pop ( ) ; ll v = p . second ; if ( p . first > d [ v ] ) continue ; rep ( i , 0 , G [ v ] . size ( ) ) { edge e = G [ v ] [ i ] ; if ( d [ e . to ] > d [ v ] + e . cost ) { d [ e . to ] = d [ v ] + e . cost ; que . push ( P ( d [ e . to ] , e . to ) ) ; } } } } int main ( ) { ll E , r ; cin > > V > > E > > r ; rep ( i , 0 , E ) { ll s , t , d ; cin > > s > > t > > d ; G [ s ] . push_back ( edge { t , d } ) ; } dijkstra ( r ) ; rep ( i , 0 , V ) { if ( d [ i ] == INF ) cout << "INF" << endl ; else cout << d [ i ] << endl ; } return 0 ; }<CODESPLIT>-1.0356345176696777<CODESPLIT>5.745582580566406<CODESPLIT>-1.2342414855957031<CODESPLIT>-1.2202239036560059<CODESPLIT>-1.1507660150527954<CODESPLIT>-1.4050453901290894
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> #define ALL(a)  (a).begin(),(a).end() #define sz(x) int(x.size()) using namespace std ; typedef long long ll ; typedef pair < int , int > P ; typedef pair < long long , long long > Pll ; typedef vector < int > vi ; typedef vector < vector < int > > vvi ; typedef vector < long long > vll ; typedef vector < vector < long long > > vvll ; template < typename T > inline bool chmax ( T & a , T b ) { if ( a < b ) { a = b ; return 1 ; } return 0 ; } template < typename T > inline bool chmin ( T & a , T b ) { if ( a > b ) { a = b ; return 1 ; } return 0 ; } const long long INF = 1LL << 60 ; const int INT_INF = 1 << 30 ; const double PI = acos ( - 1.0 ) ; #define MOD 1000000007LL #define endl "\n" struct edge { ll from , to , cost ; edge ( ) { } edge ( ll t , ll c ) { to = t ; cost = c ; } edge ( ll f , ll t , ll c ) { from = f ; to = t ; cost = c ; } } ; int main ( ) { ios :: sync_with_stdio ( false ) ; cin . tie ( nullptr ) ; int N , M , r ; cin > > N > > M > > r ; vector < vector < edge > > G ( N , vector < edge > ( 0 ) ) ; while ( M -- ) { int s , t , d ; cin > > s > > t > > d ; G . at ( s ) . push_back ( edge ( t , d ) ) ; } priority_queue < P , vector < P > , greater < P > > que ; que . push ( P ( 0 , r ) ) ; vi ans ( N , INT_INF ) ; while ( ! que . empty ( ) ) { int v = que . top ( ) . second ; int c = que . top ( ) . first ; que . pop ( ) ; if ( ans . at ( v ) < c ) continue ; ans . at ( v ) = c ; for ( int i = 0 ; i < sz ( G . at ( v ) ) ; i ++ ) { int next = G . at ( v ) . at ( i ) . to ; int cost = G . at ( v ) . at ( i ) . cost ; que . push ( P ( c + cost , next ) ) ; } } for ( auto x : ans ) { if ( x == INT_INF ) cout << "INF" << endl ; else cout << x << endl ; } }<CODESPLIT>-1.0227973461151123<CODESPLIT>5.734331130981445<CODESPLIT>-1.2352581024169922<CODESPLIT>-1.2285685539245605<CODESPLIT>-1.1296674013137817<CODESPLIT>-1.4001260995864868
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <iostream> #include <queue> #include <vector> struct Edge { int dst ; long long cost ; Edge ( ) { } Edge ( int x , long long y ) : dst ( x ) , cost ( y ) { } } ; std :: vector < long long > dijkstra ( int sv , std :: vector < std :: vector < Edge > > & G ) { const long long LINF = 1000000000000000018LL ; int n = ( int ) G . size ( ) ; std :: vector < long long > dist ( n , LINF ) ; dist [ sv ] = 0 ; typedef std :: pair < long long , int > PLI ; std :: priority_queue < PLI , std :: vector < PLI > , std :: greater < PLI > > que ; que . push ( std :: make_pair ( 0LL , sv ) ) ; while ( ! que . empty ( ) ) { PLI now = que . top ( ) ; que . pop ( ) ; long long cur_d = now . first ; long long cur_v = now . second ; if ( dist [ cur_v ] < cur_d ) { continue ; } for ( int i = 0 ; i < ( int ) G [ cur_v ] . size ( ) ; i ++ ) { int next_v = G [ cur_v ] [ i ] . dst ; long long cost = G [ cur_v ] [ i ] . cost ; if ( dist [ cur_v ] + cost < dist [ next_v ] ) { dist [ next_v ] = dist [ cur_v ] + cost ; que . push ( std :: make_pair ( dist [ next_v ] , next_v ) ) ; } } } return dist ; } int main ( ) { const long long LINF = 1000000000000000018LL ; int v , e , r ; std :: cin > > v > > e > > r ; std :: vector < std :: vector < Edge > > g ( v ) ; for ( int i = 0 ; i < e ; i ++ ) { int s , t , d ; std :: cin > > s > > t > > d ; g [ s ] . push_back ( Edge ( t , d ) ) ; } std :: vector < long long > dist = dijkstra ( r , g ) ; for ( int i = 0 ; i < v ; i ++ ) { if ( dist [ i ] == LINF ) { std :: cout << "INF" << std :: endl ; } else { std :: cout << dist [ i ] << std :: endl ; } } return 0 ; }<CODESPLIT>-1.0756398439407349<CODESPLIT>5.737547397613525<CODESPLIT>-1.213902235031128<CODESPLIT>-1.235384464263916<CODESPLIT>-1.127623200416565<CODESPLIT>-1.3901368379592896
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> #define rep(i, n) for (int i = 0; i < (n); ++i) using namespace std ; using ll = long long ; using P = pair < int , int > ; ll N , M , r ; vector < ll > dijkstra ( int start , vector < vector < vector < ll > > > & Graph ) { vector < ll > dist ( N , 10e13 ) ; priority_queue < P , vector < P > , greater < P > > pq ; dist . at ( start ) = 0 ; pq . emplace ( dist . at ( start ) , start ) ; while ( ! pq . empty ( ) ) { P p = pq . top ( ) ; pq . pop ( ) ; int cur = p . second ; if ( dist . at ( cur ) < p . first ) continue ; for ( auto & x : Graph . at ( cur ) ) { if ( dist . at ( x [ 0 ] ) > dist . at ( cur ) + x [ 1 ] ) { dist . at ( x [ 0 ] ) = dist . at ( cur ) + x [ 1 ] ; pq . emplace ( dist . at ( x [ 0 ] ) , x [ 0 ] ) ; } } } return dist ; } int main ( ) { cin > > N > > M > > r ; vector < vector < vector < ll > > > Graph ( N ) ; for ( int i = 0 ; i < M ; ++ i ) { ll a , b , c ; cin > > a > > b > > c ; Graph [ a ] . push_back ( { b , c } ) ; } vector < ll > ans = dijkstra ( r , Graph ) ; rep ( i , N ) { if ( ans [ i ] > 10e12 ) cout << "INF" << endl ; else cout << ans [ i ] << endl ; } }<CODESPLIT>-1.1074193716049194<CODESPLIT>5.727539539337158<CODESPLIT>-1.2311112880706787<CODESPLIT>-1.2141244411468506<CODESPLIT>-1.0993174314498901<CODESPLIT>-1.362815022468567
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> using namespace std ; typedef long long ll ; typedef pair < int , int > P ; constexpr int INF = 1001001001 ; constexpr int MOD = 1000000007 ; struct Edge { int to ; int cost ; } ; vector < Edge > g [ 200000 ] ; int d [ 200000 ] ; void dijkstra ( int s ) { d [ s ] = 0 ; priority_queue < P , vector < P > , greater < P > > pq ; pq . push ( P ( d [ s ] , s ) ) ; while ( ! pq . empty ( ) ) { int v_cost = pq . top ( ) . first ; int v = pq . top ( ) . second ; pq . pop ( ) ; if ( d [ v ] < v_cost ) continue ; for ( int i = 0 ; i < g [ v ] . size ( ) ; i ++ ) { int c = g [ v ] [ i ] . to ; int c_cost = g [ v ] [ i ] . cost ; int cost = v_cost + c_cost ; if ( d [ c ] > cost ) { d [ c ] = cost ; pq . push ( P ( cost , c ) ) ; } } } } int main ( ) { cin . tie ( nullptr ) ; ios :: sync_with_stdio ( false ) ; int V , E , r ; cin > > V > > E > > r ; fill ( d , d + V , INF ) ; for ( int i = 0 ; i < E ; i ++ ) { int s , t , cost ; cin > > s > > t > > cost ; Edge edge = { t , cost } ; g [ s ] . emplace_back ( edge ) ; } dijkstra ( r ) ; for ( int i = 0 ; i < V ; i ++ ) { if ( d [ i ] == INF ) { cout << "INF" << endl ; } else { cout << d [ i ] << endl ; } } return 0 ; }<CODESPLIT>-1.106959342956543<CODESPLIT>5.740190505981445<CODESPLIT>-1.2242538928985596<CODESPLIT>-1.226380467414856<CODESPLIT>-1.1256910562515259<CODESPLIT>-1.352293848991394
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include<bits/stdc++.h> #define MAX 100010 #define inf 1<<30 #define linf 1e16 #define eps (1e-8) #define mod 1000000007 #define pi acos(-1) #define phi (1.0+sqrt(5))/2.0 #define f first #define s second #define mp make_pair #define pb push_back #define all(a) (a).begin(),(a).end() #define pd(a) printf("%.10f\n",(double)(a)) #define FOR(i,a,b) for(int i=(a);i<(b);i++) #define RFOR(i,a,b) for(int i=(a)-1;(b)<=i;i--) #define equals(a,b) (fabs((a)-(b))<eps) using namespace std ; typedef long long ll ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < int , double > pid ; typedef pair < double , int > pdi ; typedef vector < int > vi ; typedef vector < pii > vpi ; const int dx [ 8 ] = { 1 , 0 , - 1 , 0 , 1 , 1 , - 1 , - 1 } ; const int dy [ 8 ] = { 0 , 1 , 0 , - 1 , 1 , - 1 , 1 , - 1 } ; int v , e , r ; vector < pii > g [ MAX ] ; void dijkstra ( ) { int d [ MAX ] ; priority_queue < pii , vector < pii > , greater < pii > > pq ; fill ( d , d + MAX , inf ) ; d [ r ] = 0 ; pq . push ( mp ( 0 , r ) ) ; while ( pq . size ( ) ) { pii u = pq . top ( ) ; pq . pop ( ) ; if ( d [ u . s ] < u . f ) continue ; FOR ( i , 0 , g [ u . s ] . size ( ) ) { int next = g [ u . s ] [ i ] . f ; int cost = d [ u . s ] + g [ u . s ] [ i ] . s ; if ( cost < d [ next ] ) { d [ next ] = cost ; pq . push ( mp ( cost , next ) ) ; } } } FOR ( i , 0 , v ) { if ( d [ i ] == inf ) printf ( "INF\n" ) ; else printf ( "%d\n" , d [ i ] ) ; } return ; } int main ( ) { scanf ( "%d%d%d" , & v , & e , & r ) ; FOR ( i , 0 , e ) { int a , b , c ; scanf ( "%d%d%d" , & a , & b , & c ) ; g [ a ] . pb ( mp ( b , c ) ) ; } dijkstra ( ) ; return 0 ; }<CODESPLIT>-0.8742896914482117<CODESPLIT>5.737771987915039<CODESPLIT>-1.2589044570922852<CODESPLIT>-1.2223217487335205<CODESPLIT>-1.145363688468933<CODESPLIT>-1.457018256187439
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include<bits/stdc++.h> #define to first #define wgt second  using namespace std ; const int MAXN = 100100 ; typedef pair < int , int > pii ; typedef vector < pii > vec ; typedef vector < vec > Graph ; Graph G ( MAXN ) ; int n , d [ MAXN ] ; void SPFA ( int s ) { queue < int > que ; fill ( d , d + n , INT_MAX ) ; d [ s ] = 0 ; que . push ( s ) ; while ( ! que . empty ( ) ) { int u = que . front ( ) ; que . pop ( ) ; for ( int i = 0 ; i < G [ u ] . size ( ) ; i ++ ) if ( d [ G [ u ] [ i ] . to ] > d [ u ] + G [ u ] [ i ] . wgt ) { d [ G [ u ] [ i ] . to ] = d [ u ] + G [ u ] [ i ] . wgt ; que . push ( G [ u ] [ i ] . to ) ; } } } int main ( ) { int e , r ; scanf ( "%d %d %d" , & n , & e , & r ) ; for ( int i = 0 ; i < e ; i ++ ) { int s , t , d ; scanf ( "%d%d%d" , & s , & t , & d ) ; G [ s ] . push_back ( make_pair ( t , d ) ) ; } SPFA ( r ) ; for ( int i = 0 ; i < n ; i ++ ) if ( d [ i ] == INT_MAX ) printf ( "INF\n" ) ; else printf ( "%d\n" , d [ i ] ) ; return 0 ; }<CODESPLIT>-0.9689895510673523<CODESPLIT>5.739182472229004<CODESPLIT>-1.2189714908599854<CODESPLIT>-1.2215042114257812<CODESPLIT>-1.1327394247055054<CODESPLIT>-1.3818836212158203
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <iostream> #include <cstdio> using namespace std ; int V , E , R , S [ 500010 ] , T [ 500010 ] , D [ 500010 ] ; int C [ 100010 ] ; const int inf = 10000 * 100000+100 ; int main ( ) { cin > > V > > E > > R ; for ( int i = 0 ; i < E ; ++ i ) { cin > > S [ i ] > > T [ i ] > > D [ i ] ; } for ( int i = 0 ; i < V ; ++ i ) { if ( i ! = R ) { C [ i ] = inf ; } else { C [ i ] = 0 ; } } while ( true ) { bool update = false ; for ( int i = 0 ; i < E ; ++ i ) { int s = S [ i ] , t = T [ i ] , d = D [ i ] ; if ( C [ s ] < inf && ( C [ s ] + d < C [ t ] ) ) { C [ t ] = C [ s ] + d ; update = true ; } } if ( ! update ) break ; } for ( int i = 0 ; i < V ; ++ i ) { if ( inf == C [ i ] ) { cout << "INF" << endl ; } else { cout << C [ i ] << endl ; } } }<CODESPLIT>-0.7799389958381653<CODESPLIT>5.741763591766357<CODESPLIT>-1.2775439023971558<CODESPLIT>-1.2701091766357422<CODESPLIT>-1.1979533433914185<CODESPLIT>-1.4387699365615845
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <iostream> #include <vector> #include <utility> #include <climits> #define REP(i,n) for(int i=0; i<n; ++i) #define INF LONG_MAX using namespace std ; long V , E , r ; vector < vector < pair < long , long > > > to ; vector < long > path ; void bellman_ford ( ) { path . resize ( V , INF ) ; path [ r ] = 0 ; bool flag = true ; while ( flag ) { flag = false ; REP ( i , V ) { REP ( j , to [ i ] . size ( ) ) { long f = i ; auto t = to [ i ] [ j ] ; if ( path [ f ] < INF && path [ t . first ] > path [ f ] + t . second ) { path [ t . first ] = path [ f ] + t . second ; flag = true ; } } } } } int main ( void ) { std :: cin > > V > > E > > r ; to . resize ( V ) ; long s , t , d ; REP ( i , E ) { std :: cin > > s > > t > > d ; to [ s ] . push_back ( make_pair ( t , d ) ) ; } bellman_ford ( ) ; for ( auto l : path ) { if ( l == INF ) { std :: cout << "INF" << std :: endl ; } else { std :: cout << l << std :: endl ; } } }<CODESPLIT>-0.873691737651825<CODESPLIT>5.740206718444824<CODESPLIT>-1.2639708518981934<CODESPLIT>-1.263999342918396<CODESPLIT>-1.173096776008606<CODESPLIT>-1.4203585386276245
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <iostream> #include <vector> #include <queue> #include <algorithm> #include <utility> using namespace std ; const int Inf = 10000 * 100000 + 100 ; int main ( ) { int V , E , R ; cin > > V > > E > > R ; vector < int > s ( E ) , t ( E ) , d ( E ) ; vector < vector < int > > edge ( V ) ; for ( int i = 0 ; i < E ; i ++ ) { cin > > s [ i ] > > t [ i ] > > d [ i ] ; edge [ s [ i ] ] . push_back ( i ) ; } vector < int > cost ( V , Inf ) ; cost [ R ] = 0 ; priority_queue < pair < int , int > , vector < pair < int , int > > , greater < pair < int , int > > > q ; q . push ( { 0 , R } ) ; vector < bool > fin ( V , false ) ; while ( ! q . empty ( ) ) { auto npair = q . top ( ) ; int nd = npair . first , nu = npair . second ; q . pop ( ) ; if ( fin [ nu ] ) continue ; fin [ nu ] = true ; cost [ nu ] = nd ; for ( auto i : edge [ nu ] ) { if ( ! fin [ t [ i ] ] ) { int nv = t [ i ] ; if ( cost [ nu ] + d [ i ] < cost [ nv ] ) { cost [ nv ] = cost [ nu ] + d [ i ] ; q . push ( { cost [ nv ] , nv } ) ; } } } } for ( int i = 0 ; i < V ; i ++ ) { if ( cost [ i ] == Inf ) cout << "INF" ; else cout << cost [ i ] ; cout << endl ; } }<CODESPLIT>-1.1224231719970703<CODESPLIT>5.732860088348389<CODESPLIT>-1.2354004383087158<CODESPLIT>-1.2170624732971191<CODESPLIT>-1.1038178205490112<CODESPLIT>-1.3755971193313599
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> #include <math.h> using namespace std ; long long inf = 1000000007 ; long long modpow ( long long n , long long p , long long mod ) ; int main ( ) { long long n , m , r ; cin > > n > > m > > r ; vector < vector < pair < long long , long long > > > kankei ( n ) ; vector < bool > done ( n , false ) ; vector < long long > dis ( n , inf * 100 ) ; for ( long long i = 0 ; i < m ; i ++ ) { long long a , b , c ; cin > > a > > b > > c ; kankei . at ( a ) . push_back ( make_pair ( b , c ) ) ; } priority_queue < pair < long long , long long > , vector < pair < long long , long long > > , greater < pair < long long , long long > > > que ; que . push ( make_pair ( 0 , r ) ) ; while ( ! que . empty ( ) ) { long long nowpos = que . top ( ) . second ; long long nowdis = que . top ( ) . first ; que . pop ( ) ; if ( done . at ( nowpos ) ) continue ; done . at ( nowpos ) = true ; dis . at ( nowpos ) = nowdis ; for ( auto next : kankei . at ( nowpos ) ) { que . push ( make_pair ( nowdis + next . second , next . first ) ) ; } } for ( long long i = 0 ; i < n ; i ++ ) { if ( done . at ( i ) ) { cout << dis . at ( i ) << endl ; } else { cout << "INF" << endl ; } } return 0 ; } long long modpow ( long long n , long long p , long long mod ) { if ( p == 0 ) return 1 ; if ( p % 2 == 0 ) return ( modpow ( n , p / 2 , mod ) * modpow ( n , p / 2 , mod ) ) % mod ; if ( p % 2 == 1 ) return ( modpow ( n , p - 1 , mod ) * n ) % mod ; cerr << "ERROR" << endl ; return 1 ; }<CODESPLIT>-1.090765357017517<CODESPLIT>5.744626045227051<CODESPLIT>-1.2224154472351074<CODESPLIT>-1.2255582809448242<CODESPLIT>-1.0991278886795044<CODESPLIT>-1.3750702142715454
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <iostream> #include <cstdlib> #include <vector> #include <algorithm> #include <map> #include <string> #include <queue> #include <set> using namespace std ; typedef long long lint ; using Weight = lint ; struct Edge { int src , dst ; Weight weight ; Edge ( ) : src ( 0 ) , dst ( 0 ) , weight ( 0 ) { } Edge ( int s , int d , Weight w ) : src ( s ) , dst ( d ) , weight ( w ) { } } ; using Edges = vector < Edge > ; using Graph = vector < Edges > ; using Array = vector < Weight > ; using Matrix = vector < Array > ; const Weight INF = numeric_limits < Weight > :: max ( ) / 8 ; void add_edge ( Graph & g , int a , int b , Weight w ) { g [ a ] . push_back ( Edge ( a , b , w ) ) ; g [ b ] . push_back ( Edge ( b , a , w ) ) ; } void add_arc ( Graph & g , int a , int b , Weight w ) { g [ a ] . push_back ( Edge ( a , b , w ) ) ; } vector < Weight > dijkstra ( const Graph & g , int s ) { using state = tuple < Weight , int > ; priority_queue < state > q ; vector < Weight > dist ( g . size ( ) , INF ) ; dist [ s ] = 0 ; q . emplace ( 0 , s ) ; while ( q . size ( ) ) { Weight d ; int v ; tie ( d , v ) = q . top ( ) ; q . pop ( ) ; d *= - 1 ; if ( dist [ v ] < d ) continue ; for ( auto & e : g [ v ] ) { if ( dist [ e . dst ] > dist [ v ] + e . weight ) { dist [ e . dst ] = dist [ v ] + e . weight ; q . emplace ( - dist [ e . dst ] , e . dst ) ; } } } return dist ; } int main ( ) { int v , e , r ; int s , t ; Weight d ; Graph g ; vector < Weight > dist ; cin > > v > > e > > r ; g . resize ( v ) ; for ( int i = 0 ; i < e ; ++ i ) { cin > > s > > t > > d ; add_arc ( g , s , t , d ) ; } dist = dijkstra ( g , r ) ; for ( int i = 0 ; i < ( int ) dist . size ( ) ; ++ i ) { if ( dist [ i ] ! = INF ) { cout << dist [ i ] << endl ; } else { cout << "INF" << endl ; } } return 0 ; }<CODESPLIT>-1.091148018836975<CODESPLIT>5.7256669998168945<CODESPLIT>-1.2242975234985352<CODESPLIT>-1.2381274700164795<CODESPLIT>-1.1506681442260742<CODESPLIT>-1.4014960527420044
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> using namespace std ; #define INF (INT_MAX/2) #define PI (2*acos(0.0)) #define EPS (1e-8) #define REP(i,a,b) for(int i=(a); i<(b);++i) #define rep(i,n) REP(i,0,n) typedef long long ll ; typedef unsigned long long ull ; typedef pair < int , int > pii ; typedef pair < ll , ll > pll ; typedef int Cost ; struct Edge { int src , dst ; Cost cst ; Edge ( int s , int d , Cost c ) : src ( s ) , dst ( d ) , cst ( c ) { } } ; typedef vector < Edge > Edges ; typedef vector < Edges > Graph ; typedef vector < Cost > Array ; typedef vector < Array > Matrix ; int dx [ 8 ] = { 0 , 1 , 0 , - 1 , 1 , - 1 , 1 , - 1 } ; int dy [ 8 ] = { 1 , 0 , - 1 , 0 , 1 , - 1 , - 1 , 1 } ; vector < Cost > dijkstra ( const Graph & g , int s ) { const Cost inf = numeric_limits < Cost > :: max ( ) / 2 ; typedef tuple < Cost , int > State ; priority_queue < State > q ; vector < Cost > dist ( g . size ( ) , inf ) ; dist [ s ] = 0 ; q . emplace ( 0 , s ) ; while ( q . size ( ) ) { Cost c ; int v ; tie ( c , v ) = q . top ( ) ; q . pop ( ) ; c *= - 1 ; if ( dist [ v ] < c ) continue ; for ( auto & e : g [ v ] ) { if ( dist [ e . dst ] > dist [ v ] + e . cst ) { dist [ e . dst ] = dist [ v ] + e . cst ; q . emplace ( - dist [ e . dst ] , e . dst ) ; } } } return dist ; } int main ( void ) { ios_base :: sync_with_stdio ( false ) ; cin . tie ( 0 ) ; int v , e , r ; int s , t , d ; cin > > v > > e > > r ; Graph g ( v ) ; for ( int i = 0 ; i < e ; i ++ ) { cin > > s > > t > > d ; g [ s ] . push_back ( Edge ( s , t , d ) ) ; } vector < Cost > c = dijkstra ( g , r ) ; for ( int i = 0 ; i < ( int ) c . size ( ) ; i ++ ) { if ( c [ i ] == numeric_limits < Cost > :: max ( ) / 2 ) cout << "INF" << endl ; else cout << c [ i ] << endl ; } return 0 ; }<CODESPLIT>-1.0652703046798706<CODESPLIT>5.7383646965026855<CODESPLIT>-1.2212042808532715<CODESPLIT>-1.2385342121124268<CODESPLIT>-1.1195858716964722<CODESPLIT>-1.414589524269104
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> #include <iomanip> #include <math.h> #include <unistd.h> #include <stdio.h> #define rep(i,x) for(ll i = 0;i<x;i++) #define all(a) (a).begin(),(a).end() #define vecin(a) rep(i,a.size())cin >> a[i] #define vecout(a) rep(i,a.size())cout << a[i] << " ";cout << "\n" #define vecvec(a) vector<vector<(a)>> using ll = long long ; using ld = long double ; using namespace std ; using dou = double ; const ll inf = 2147483647 ; const ll INF = 1LL << 60 ; const ld pi = 3.14159265358 ; const ll mod = 1000000007 ; typedef pair < ll , ll > P ; using graph = vector < vector < ll > > ; template < class T > inline bool chmax ( T & a , T b ) { if ( a < b ) { a = b ; return true ; } return false ; } template < class T > inline bool chmin ( T & a , T b ) { if ( a > b ) { a = b ; return true ; } return false ; } template < class T > inline bool change ( T a , T b ) { if ( a > b ) { swap ( a , b ) ; return true ; } return false ; } ll gcd ( ll a , ll b ) { if ( a < b ) swap ( a , b ) ; if ( a % b == 0 ) return b ; else return gcd ( b , a % b ) ; } bool isp ( ll n ) { bool res = true ; if ( n == 1 ) return false ; else { for ( ll i = 2 ; i * i <= n ; i ++ ) { if ( n % i == 0 ) { res = false ; break ; } } return res ; } } const ll cmax = 1000000 ; ll fac [ cmax ] , finv [ cmax ] , inv [ cmax ] ; void COMinit ( ) { fac [ 0 ] = fac [ 1 ] = 1 ; finv [ 0 ] = finv [ 1 ] = 1 ; inv [ 1 ] = 1 ; for ( ll i = 2 ; i < cmax ; i ++ ) { fac [ i ] = fac [ i - 1 ] * i % mod ; inv [ i ] = mod - inv [ mod % i ] * ( mod / i ) % mod ; finv [ i ] = finv [ i - 1 ] * inv [ i ] % mod ; } } ll nCk ( ll n , ll k ) { if ( n < k ) return 0 ; if ( n < 0 || k < 0 ) return 0 ; return fac [ n ] * ( finv [ k ] * finv [ n - k ] % mod ) % mod ; } ll modpow ( ll n , ll m , ll MOD ) { ll res = 1 ; while ( m ) { if ( m & 1 ) res = ( res * n ) % MOD ; m > >= 1 ; n *= n ; n % = MOD ; } return res ; } int main ( ) { ios :: sync_with_stdio ( false ) ; cin . tie ( 0 ) ; ll N , M , r ; cin > > N > > M > > r ; struct edge { ll to , cost ; } ; vector < edge > G [ 100005 ] ; ll a , b , c ; rep ( i , M ) { cin > > a > > b > > c ; G [ a ] . push_back ( { b , c } ) ; } vector < ll > dist ( N , INF ) ; dist [ r ] = 0 ; priority_queue < P , vector < P > , greater < P > > que ; que . push ( P ( 0 , r ) ) ; while ( que . size ( ) ) { P p = que . top ( ) ; que . pop ( ) ; if ( dist [ p . second ] < p . first ) continue ; for ( auto x : G [ p . second ] ) { if ( dist [ x . to ] > dist [ p . second ] + x . cost ) { dist [ x . to ] = dist [ p . second ] + x . cost ; que . push ( P ( dist [ x . to ] , x . to ) ) ; } } } rep ( i , N ) { if ( dist [ i ] == INF ) { cout << "INF\n" ; } else cout << dist [ i ] << "\n" ; } }<CODESPLIT>-1.0882622003555298<CODESPLIT>5.732855319976807<CODESPLIT>-1.2160604000091553<CODESPLIT>-1.2369060516357422<CODESPLIT>-1.1048321723937988<CODESPLIT>-1.406485676765442
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <bits/stdc++.h>  using namespace std ; #define rep(i,n) for(int (i) = 0; (i) < (n); ++(i)) const int INF_32 = - 1 + ( 1 << 30 ) ; template < class Abel > struct D_Graph { int V , E ; bool ** exist ; vector < vector < pair < int , Abel > > > adj ; vector < vector < pair < int , Abel > > > adj_inv ; D_Graph ( int V_size = 0 ) { init ( V_size ) ; } void init ( int V_size ) { V = V_size , E = 0 ; adj . clear ( ) ; adj_inv . clear ( ) ; adj . resize ( V + 1 ) ; adj_inv . resize ( V + 1 ) ; adj [ 0 ] . resize ( V ) ; for ( int i = 1 ; i <= V ; ++ i ) { adj [ 0 ] [ i - 1 ] = { i , 0 } ; } } int deg_out ( int v ) { return adj [ v ] . size ( ) ; } int deg_in ( int v ) { return adj_inv [ v ] . size ( ) ; } bool is_leaf ( int v ) { return deg_out ( v ) == 0 ; } bool is_root ( int v ) { return deg_in ( v ) == 0 ; } void add_edge ( int from , int to , Abel cost = 1 ) { adj [ from ] . push_back ( { to , cost } ) ; adj_inv [ to ] . push_back ( { from , cost } ) ; ++ E ; } void sort_edge ( ) { for ( int i = 0 ; i <= V ; ++ i ) sort_edge ( i ) ; } void sort_edge ( int v ) { sort ( begin ( adj [ v ] ) , end ( adj [ v ] ) ) ; sort ( begin ( adj_inv [ v ] ) , end ( adj_inv [ v ] ) ) ; } void dijkstra ( vector < Abel > & dist , int src , Abel dist_max = INF_32 ) { dist . clear ( ) ; dist . resize ( V + 1 ) ; fill ( begin ( dist ) , end ( dist ) , dist_max ) ; priority_queue < pair < Abel , int > , vector < pair < Abel , int > > , greater < pair < Abel , int > > > que ; que . push ( { 0 , src } ) ; while ( ! que . empty ( ) ) { int d = que . top ( ) . first ; int v = que . top ( ) . second ; que . pop ( ) ; if ( dist [ v ] <= d ) continue ; dist [ v ] = d ; for ( auto e : adj [ v ] ) que . push ( { e . second + d , e . first } ) ; } } } ; int main ( ) { ios :: sync_with_stdio ( false ) ; cin . tie ( 0 ) ; int V , E , r ; cin > > V > > E > > r ; D_Graph < int > G ( V ) ; int s , t , d ; rep ( i , E ) { cin > > s > > t > > d ; G . add_edge ( ++ s , ++ t , d ) ; } vector < int > dist ; G . dijkstra ( dist , ++ r ) ; rep ( i , V ) { if ( dist [ i + 1 ] < INF_32 ) cout << dist [ i + 1 ] << '\n' ; else cout << "INF\n" ; } }<CODESPLIT>-1.0168224573135376<CODESPLIT>5.752004623413086<CODESPLIT>-1.2282648086547852<CODESPLIT>-1.2340023517608643<CODESPLIT>-1.1191107034683228<CODESPLIT>-1.394524335861206
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include<bits/stdc++.h> using namespace std ; struct Dijkstra { struct edge { int to ; long long cost ; edge ( int to , long long cost ) : to ( to ) , cost ( cost ) { } } ; typedef pair < long long , int > P ; const long long INF = 1LL << 60 ; int v ; int s ; vector < vector < edge > > g ; vector < long long > dist ; priority_queue < P , vector < P > , greater < P > > que ; Dijkstra ( int v , int s ) : v ( v ) , s ( s ) , g ( v ) , dist ( v , INF ) { dist [ s ] = 0 ; que . push ( P ( 0 , s ) ) ; } void add_edge ( int start , int to , long long cost ) { g [ start ] . emplace_back ( to , cost ) ; } void build ( ) { while ( ! que . empty ( ) ) { P p = que . top ( ) ; que . pop ( ) ; int current = p . second ; if ( dist [ current ] < p . first ) continue ; for ( edge & e : g [ current ] ) { if ( dist [ e . to ] > dist [ current ] + e . cost ) { dist [ e . to ] = dist [ current ] + e . cost ; que . push ( P ( dist [ e . to ] , e . to ) ) ; } } } } long long shortest_path_value ( int t ) { return dist [ t ] ; } } ; int main ( ) { int V , E , r ; cin > > V > > E > > r ; Dijkstra dijkstra ( V , r ) ; for ( int i = 0 ; i < E ; ++ i ) { int s , t , d ; cin > > s > > t > > d ; dijkstra . add_edge ( s , t , d ) ; } dijkstra . build ( ) ; for ( int i = 0 ; i < V ; ++ i ) { long long val = dijkstra . shortest_path_value ( i ) ; if ( val == dijkstra . INF ) cout << "INF" << endl ; else cout << val << endl ; } }<CODESPLIT>-1.1320762634277344<CODESPLIT>5.729672908782959<CODESPLIT>-1.2083194255828857<CODESPLIT>-1.2231059074401855<CODESPLIT>-1.1103456020355225<CODESPLIT>-1.3971248865127563
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <iostream> #include <algorithm> #include <vector> #include <queue> using namespace std ; const long long LINF = 1000000000000000018ll ; struct Edge { int dst ; long long cost ; Edge ( ) { } Edge ( int x , int y ) : dst ( x ) , cost ( y ) { } } ; vector < vector < Edge > > graph ; vector < long long > dijkstra ( int start_v , int v ) { vector < long long > dist ( v , 1000000000000000018ll ) ; dist [ start_v ] = 0 ; priority_queue < pair < long long , int > , vector < pair < long long , int > > , greater < pair < long long , int > > > q ; q . push ( make_pair ( 0 , start_v ) ) ; while ( ! q . empty ( ) ) { pair < long long , int > t = q . top ( ) ; q . pop ( ) ; int cur_v = t . second ; for ( auto nxt : graph [ cur_v ] ) { int next_v = nxt . dst ; long long cost = nxt . cost ; if ( dist [ next_v ] > dist [ cur_v ] + cost ) { dist [ next_v ] = dist [ cur_v ] + cost ; q . push ( make_pair ( dist [ next_v ] , next_v ) ) ; } } } return dist ; } int main ( ) { int v , e , r ; cin > > v > > e > > r ; graph . assign ( v , vector < Edge > ( ) ) ; for ( int i = 0 ; i < e ; i ++ ) { int s , t , d ; cin > > s > > t > > d ; graph [ s ] . push_back ( Edge ( t , d ) ) ; } vector < long long > dist = dijkstra ( r , v ) ; for ( int i = 0 ; i < v ; i ++ ) { if ( dist [ i ] == LINF ) { cout << "INF" << "\n" ; } else { cout << dist [ i ] << "\n" ; } } return 0 ; }<CODESPLIT>-1.1383483409881592<CODESPLIT>5.7352375984191895<CODESPLIT>-1.2181079387664795<CODESPLIT>-1.2277904748916626<CODESPLIT>-1.0955866575241089<CODESPLIT>-1.3756113052368164
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <iostream> #include <algorithm> #include <map> #include <vector> using namespace std ; typedef long long ll ; #define INF 2147483647 struct edge { int to , cost ; } ; int V , E ; vector < edge > G [ 100010 ] ; multimap < int , int > l ; ll d [ 500010 ] ; void dijkstra ( int s ) { fill ( d , d + V , INF ) ; d [ s ] = 0 ; l . insert ( make_pair ( 0 , s ) ) ; while ( l . size ( ) > 0 ) { int p = l . begin ( ) -> first ; int v = l . begin ( ) -> second ; l . erase ( l . begin ( ) ) ; if ( d [ v ] < p ) continue ; for ( int i = 0 ; i < G [ v ] . size ( ) ; i ++ ) { edge e = G [ v ] [ i ] ; if ( d [ e . to ] > d [ v ] + e . cost ) { d [ e . to ] = d [ v ] + e . cost ; l . insert ( make_pair ( d [ e . to ] , e . to ) ) ; } } } } int main ( ) { int r ; cin > > V > > E > > r ; for ( int i = 0 ; i < E ; i ++ ) { edge e ; int from ; cin > > from > > e . to > > e . cost ; G [ from ] . push_back ( e ) ; } dijkstra ( r ) ; for ( int i = 0 ; i < V ; i ++ ) { if ( d [ i ] ! = INF ) cout << d [ i ] << endl ; else cout << "INF" << endl ; } return 0 ; }<CODESPLIT>-0.9995415806770325<CODESPLIT>5.739418983459473<CODESPLIT>-1.2273914813995361<CODESPLIT>-1.2340188026428223<CODESPLIT>-1.1417940855026245<CODESPLIT>-1.3745490312576294
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#pragma region header #include <bits/stdc++.h> using namespace std ; #define int long long #define rep(i, n) for (int i = 0; i < (int)(n); i++) #define rep1(i, n) for (int i = 1; i <= (int)(n); i++) #define rev(i, n) for(int i = (int)(n - 1); i >= 0; i--) #define rev1(i, n) for(int i = (int)(n); i > 0; i--) #define pb push_back #define all(v) (v).begin(), (v).end() #define resort(v) sort((v).rbegin(), (v).rend()) #define vi vector<int> #define vvi vector<vector<int>> #define vc vector<char> #define vvc vector<vector<char>> #define vb vector<bool> #define vvb vector<vector<bool>> using ll = long long ; using P = pair < int , int > ; int dx [ ] = { 1 , 0 , - 1 , 0 } ; int dy [ ] = { 0 , 1 , 0 , - 1 } ; constexpr ll mod = 1e9+7 ; constexpr int inf = INT32_MAX / 2 ; constexpr ll INF = LLONG_MAX / 2 ; constexpr long double eps = DBL_EPSILON ; constexpr long double pi = 3.141592653589793238462643383279 ; template < class T > inline bool chmin ( T & a , T b ) { if ( a > b ) { a = b ; return true ; } return false ; } template < class T > inline bool chmax ( T & a , T b ) { if ( a < b ) { a = b ; return true ; } return false ; } ll fact ( int i ) { if ( i == 0 ) return 1 ; return ( fact ( i - 1 ) ) * i % mod ; } ll gcd ( ll a , ll b ) { if ( b == 0 ) return a ; return gcd ( b , a % b ) ; } ll lcm ( ll a , ll b ) { return a * b / gcd ( a , b ) ; } int keta ( ll n ) { if ( n == 0 ) return 1 ; int count = 0 ; while ( n ! = 0 ) { n / = 10 ; count ++ ; } return count ; } ll ketasum ( ll n ) { ll sum = 0 ; while ( n ! = 0 ) { sum += n % 10 ; n / = 10 ; } return sum ; } bool isprime ( int n ) { if ( n == 1 ) return false ; if ( n == 2 ) return true ; for ( int i = 2 ; i <= sqrt ( n ) ; i ++ ) { if ( n % i == 0 ) return false ; } return true ; } #pragma endregion struct edge { int to , cost ; } ; int v , e , r ; int dist [ 100100 ] ; vector < vector < edge > > g ( 100100 ) ; void dijkstra ( int s ) { priority_queue < P , vector < P > , greater < P > > pri ; fill ( dist , dist + v , inf ) ; pri . push ( { 0 , s } ) ; dist [ s ] = 0 ; while ( ! pri . empty ( ) ) { P p = pri . top ( ) ; pri . pop ( ) ; int v = p . second ; if ( dist [ v ] < p . first ) continue ; for ( auto e : g [ v ] ) { if ( chmin ( dist [ e . to ] , dist [ v ] + e . cost ) ) pri . push ( { dist [ e . to ] , e . to } ) ; } } } signed main ( ) { cin > > v > > e > > r ; rep ( i , e ) { int a , b , cost ; cin > > a > > b > > cost ; edge e = { b , cost } ; g [ a ] . pb ( e ) ; } dijkstra ( r ) ; rep ( i , v ) { if ( dist [ i ] == inf ) puts ( "INF" ) ; else cout << dist [ i ] << endl ; } return 0 ; }<CODESPLIT>-0.8436987400054932<CODESPLIT>5.744490623474121<CODESPLIT>-1.2530832290649414<CODESPLIT>-1.2559163570404053<CODESPLIT>-1.1309176683425903<CODESPLIT>-1.4170029163360596
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include "bits/stdc++.h" using namespace std ; struct Edge { long long to ; long long cost ; } ; using Graph = vector < vector < Edge > > ; using P = pair < long , int > ; const long long INF = 1LL << 60 ; void dijkstra ( const Graph & G , int s , vector < long long > & dis ) { int N = G . size ( ) ; dis . resize ( N , INF ) ; priority_queue < P , vector < P > , greater < P > > pq ; dis [ s ] = 0 ; pq . emplace ( dis [ s ] , s ) ; while ( ! pq . empty ( ) ) { P p = pq . top ( ) ; pq . pop ( ) ; int v = p . second ; if ( dis [ v ] < p . first ) { continue ; } for ( auto & e : G [ v ] ) { if ( dis [ e . to ] > dis [ v ] + e . cost ) { dis [ e . to ] = dis [ v ] + e . cost ; pq . emplace ( dis [ e . to ] , e . to ) ; } } } } int main ( ) { Graph G ( 100020 ) ; int v , e , r ; cin > > v > > e > > r ; for ( int i = 0 ; i < e ; i ++ ) { long long int s , t , d ; cin > > s > > t > > d ; Edge edge = Edge { t , d } ; G [ s ] . push_back ( edge ) ; } vector < long long int > dis ( 100020 , INF ) ; dijkstra ( G , r , dis ) ; for ( int i = 0 ; i < v ; i ++ ) { if ( dis [ i ] == INF ) { cout << "INF" << endl ; } else { cout << dis [ i ] << endl ; } } }<CODESPLIT>-1.066425085067749<CODESPLIT>5.722319602966309<CODESPLIT>-1.2303894758224487<CODESPLIT>-1.2392563819885254<CODESPLIT>-1.122794508934021<CODESPLIT>-1.3581055402755737
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> using namespace std ; #define FOR(i,a,b) for(int i=(a);i<(b);++i) #define rep(i,n)   FOR(i,0,n) #define pb push_back #define mp make_pair typedef long long ll ; typedef pair < int , int > pint ; vector < pint > vp [ 500001 ] ; int d [ 100001 ] ; int inf = 1000100010 ; int v ; int dijkstra ( int st ) { priority_queue < pint , vector < pint > , greater < pint > > pq ; rep ( i , v ) d [ i ] = inf ; d [ st ] = 0 ; pq . push ( make_pair ( 0 , st ) ) ; while ( ! pq . empty ( ) ) { pint pi = pq . top ( ) ; pq . pop ( ) ; int t = pi . second ; for ( vector < pint > :: iterator it = vp [ t ] . begin ( ) ; it ! = vp [ t ] . end ( ) ; ++ it ) { if ( d [ it -> second ] > d [ t ] + it -> first ) { d [ it -> second ] = d [ t ] + it -> first ; pq . push ( make_pair ( d [ it -> second ] , it -> second ) ) ; } } } } int main ( ) { int e , r , s , t , ds ; cin > > v > > e > > r ; rep ( i , e ) { cin > > s > > t > > ds ; vp [ s ] . pb ( mp ( ds , t ) ) ; } dijkstra ( r ) ; rep ( i , v ) { if ( d [ i ] < inf ) cout << d [ i ] << endl ; else cout << "INF" << endl ; } return 0 ; }<CODESPLIT>-1.0880136489868164<CODESPLIT>5.748217582702637<CODESPLIT>-1.2217433452606201<CODESPLIT>-1.2453242540359497<CODESPLIT>-1.1026240587234497<CODESPLIT>-1.3937329053878784
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include<bits/stdc++.h> using namespace std ; typedef long long ll ; typedef pair < ll , ll > Pi ; #define rep(i,n) for(int i=0;i<(n);i++) #define rep2(i,n) for(int i=1;i<=(n);i++) #define rep3(i,i0,n) for(int i=i0;i<(n);i++) #define pb push_back #define mod 1000000007 const ll INF = 1LL << 60 ; template < class T > bool chmax ( T & a , const T & b ) { if ( a < b ) { a = b ; return 1 ; } return 0 ; } template < class T > bool chmin ( T & a , const T & b ) { if ( b < a ) { a = b ; return 1 ; } return 0 ; } ll gcd ( ll a , ll b ) { return b ? gcd ( b , a % b ) : a ; } ll lcm ( ll a , ll b ) { return a / gcd ( a , b ) * b ; } #define all(x) x.begin(), x.end() #define mp make_pair bool compare ( Pi a , Pi b ) { if ( a . first ! = b . first ) { return a . first < b . first ; } else { return a . second < b . second ; } } ll V , E , r ; vector < vector < pair < ll , ll > > > G ( 100010 ) ; vector < ll > d ( 100010 , INF ) ; void dijkstra ( ) { d [ r ] = 0 ; priority_queue < Pi > pque ; pque . push ( mp ( 0 , r ) ) ; while ( ! pque . empty ( ) ) { Pi p = pque . top ( ) ; pque . pop ( ) ; ll pos = p . second , cost = - p . first ; if ( cost > d [ pos ] ) continue ; rep ( i , G [ pos ] . size ( ) ) { ll to = G [ pos ] [ i ] . first ; ll newcost = cost + G [ pos ] [ i ] . second ; if ( newcost < d [ to ] ) { d [ to ] = newcost ; pque . push ( mp ( - d [ to ] , to ) ) ; } } } } bool In_map ( ll y , ll x , ll h , ll w ) { if ( y < 0 || x < 0 || y >= h || x >= w ) { return 0 ; } else { return 1 ; } } const vector < ll > dx { 1 , 0 , - 1 , 0 } ; const vector < ll > dy { 0 , 1 , 0 , - 1 } ; int main ( ) { cin > > V > > E > > r ; rep ( i , E ) { ll a , b , c ; cin > > a > > b > > c ; G [ a ] . pb ( make_pair ( b , c ) ) ; } dijkstra ( ) ; rep ( i , V ) { if ( d [ i ] == INF ) { cout << "INF" << endl ; } else { cout << d [ i ] << endl ; } } return 0 ; }<CODESPLIT>-0.8421217203140259<CODESPLIT>5.76318359375<CODESPLIT>-1.2505731582641602<CODESPLIT>-1.2520949840545654<CODESPLIT>-1.1746336221694946<CODESPLIT>-1.4455927610397339
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <iostream> #include <vector> #include <list> #include <tuple> #include <unordered_set> #include <queue> using namespace std ; constexpr int INF = 1 << 30 ; using P = pair < int , int > ; class Graph { private : const int N , M ; vector < int > d ; vector < tuple < int , int , int > > E ; vector < list < P > > List ; unordered_set < int > S ; priority_queue < P , vector < P > , greater < P > > Q ; public : Graph ( int n , int m ) : N ( n ) , M ( m ) , d ( n , INF ) , List ( n ) { } void InputEdge ( int s , int t , int d ) { E . push_back ( make_tuple ( s , t , d ) ) ; List [ s ] . push_back ( make_pair ( t , d ) ) ; } void BellmanFord ( int r ) ; void Dijkstra ( int r ) ; } ; void Graph :: BellmanFord ( int r ) { d [ r ] = 0 ; for ( int i = 0 ; i < N - 1 ; i ++ ) { bool update = false ; for ( int j = 0 ; j < M ; j ++ ) { int u = get < 0 > ( E [ j ] ) , v = get < 1 > ( E [ j ] ) , w = get < 2 > ( E [ j ] ) ; if ( d [ v ] > d [ u ] + w ) { d [ v ] = d [ u ] + w ; update = true ; } } if ( ! update ) break ; } for ( int i = 0 ; i < N ; i ++ ) { if ( d [ i ] == INF ) cout << "INF" << endl ; else cout << d [ i ] << endl ; } } void Graph :: Dijkstra ( int r ) { d [ r ] = 0 ; for ( int i = 0 ; i < N ; i ++ ) Q . push ( make_pair ( 0 , r ) ) ; while ( ! Q . empty ( ) ) { int u = Q . top ( ) . second ; Q . pop ( ) ; if ( S . find ( u ) ! = S . end ( ) ) continue ; S . insert ( u ) ; for ( auto i = List [ u ] . begin ( ) ; i ! = List [ u ] . end ( ) ; ++ i ) { int v = ( * i ) . first ; if ( S . find ( v ) ! = S . end ( ) ) continue ; else { int w = ( * i ) . second ; if ( d [ v ] > d [ u ] + w ) { d [ v ] = d [ u ] + w ; Q . push ( make_pair ( d [ v ] , v ) ) ; } } } } for ( int i = 0 ; i < N ; i ++ ) { if ( d [ i ] == INF ) cout << "INF" << endl ; else cout << d [ i ] << endl ; } } int main ( ) { int n , m , r ; cin > > n > > m > > r ; Graph G ( n , m ) ; for ( int i = 0 ; i < m ; i ++ ) { int s , t , d ; cin > > s > > t > > d ; G . InputEdge ( s , t , d ) ; } G . Dijkstra ( r ) ; }<CODESPLIT>-1.0550915002822876<CODESPLIT>5.726744651794434<CODESPLIT>-1.2267189025878906<CODESPLIT>-1.2235356569290161<CODESPLIT>-1.1398670673370361<CODESPLIT>-1.4003769159317017
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> using namespace std ; const int INF = 1000000007 ; typedef long long ll ; typedef pair < int , int > pr ; struct edge { int to ; int cost ; edge ( ) { } ~ edge ( ) { } edge ( int a , int b ) : to ( a ) , cost ( b ) { } } ; struct state { int pos ; int cost ; state ( ) { } ~ state ( ) { } state ( int a , int b ) : pos ( a ) , cost ( b ) { } bool operator < ( const state & b ) const { return cost > b . cost ; } } ; typedef vector < vector < edge > > graph ; vector < int > d ; void dijkstra ( int src , graph & G ) { d . resize ( G . size ( ) ) ; fill ( d . begin ( ) , d . end ( ) , INF ) ; d [ src ] = 0 ; priority_queue < state > que ; que . push ( state ( src , 0 ) ) ; while ( ! que . empty ( ) ) { state s = que . top ( ) ; que . pop ( ) ; int pos = s . pos ; if ( d [ pos ] < s . cost ) continue ; for ( int i = 0 ; i < G [ pos ] . size ( ) ; i ++ ) { int nxt = G [ pos ] [ i ] . to , e_cost = G [ pos ] [ i ] . cost ; if ( s . cost + e_cost < d [ nxt ] ) { d [ nxt ] = s . cost + e_cost ; que . push ( state ( nxt , d [ nxt ] ) ) ; } } } } int main ( ) { int V , E , r ; scanf ( "%d%d%d" , & V , & E , & r ) ; graph G ( V ) ; for ( int i = 0 ; i < E ; i ++ ) { int s , t , d ; scanf ( "%d%d%d" , & s , & t , & d ) ; G [ s ] . push_back ( edge ( t , d ) ) ; } dijkstra ( r , G ) ; for ( int i = 0 ; i < G . size ( ) ; i ++ ) { if ( d [ i ] == INF ) { puts ( "INF" ) ; } else { printf ( "%d\n" , d [ i ] ) ; } } return 0 ; }<CODESPLIT>-1.109389305114746<CODESPLIT>5.732452392578125<CODESPLIT>-1.2167043685913086<CODESPLIT>-1.2201859951019287<CODESPLIT>-1.0968652963638306<CODESPLIT>-1.3880943059921265
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> #define debug(x) cerr << #x << ": " << x << '\n'; using namespace std ; using ll = long long ; using P = pair < int , int > ; const int INF = ( int ) 1e9 ; template < typename T > class edge { public : int src , to ; T cost ; edge ( int to , T cost ) : src ( - 1 ) , to ( to ) , cost ( cost ) { } edge ( int src , int to , T cost ) : src ( src ) , to ( to ) , cost ( cost ) { } } ; template < typename T > using Edges = vector < edge < T > > ; template < typename T > using AdjacencyList = vector < Edges < T > > ; template < typename T > using Matrix = vector < vector < T > > ; template < typename T > vector < T > dijkstra ( AdjacencyList < T > & g , int s ) { const auto INF = numeric_limits < T > :: max ( ) ; vector < T > dist ( g . size ( ) , INF ) ; using Pr = pair < T , int > ; priority_queue < Pr , vector < Pr > , greater < Pr > > que ; dist [ s ] = 0 ; que . emplace ( dist [ s ] , s ) ; while ( not que . empty ( ) ) { T cost ; int v ; tie ( cost , v ) = que . top ( ) ; que . pop ( ) ; if ( dist [ v ] < cost ) continue ; for ( auto & e : g [ v ] ) { if ( dist [ e . to ] > dist [ v ] + e . cost ) { dist [ e . to ] = dist [ v ] + e . cost ; que . emplace ( dist [ e . to ] , e . to ) ; } } } return dist ; } int main ( void ) { int V , E , R ; scanf ( "%d %d %d" , & V , & E , & R ) ; AdjacencyList < int > g ( V ) ; for ( int i = 0 ; i < E ; i ++ ) { int a , b , c ; scanf ( "%d %d %d" , & a , & b , & c ) ; g [ a ] . emplace_back ( b , c ) ; } for ( auto & dist : dijkstra ( g , R ) ) { if ( dist == numeric_limits < int > :: max ( ) ) puts ( "INF" ) ; else printf ( "%d\n" , dist ) ; } return 0 ; }<CODESPLIT>-1.1129651069641113<CODESPLIT>5.728275299072266<CODESPLIT>-1.2321217060089111<CODESPLIT>-1.2088239192962646<CODESPLIT>-1.1093634366989136<CODESPLIT>-1.3971534967422485
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include<iostream> using namespace std ; #include<cstdio> #include<vector> #include<utility> #include<queue> typedef vector < pair < int , int > > adj ; struct current_cost { int index , cost ; bool operator < ( const current_cost & cur ) const { return cost > cur . cost ; } } ; current_cost init ( int i , int c ) { current_cost cur ; cur . index = i , cur . cost = c ; return cur ; } int main ( ) { int i , j , k , n , m , r , next , cost ; scanf ( "%d %d %d" , & n , & m , & r ) ; adj * adlist ; adlist = new adj [ n ] ; for ( int k = 0 ; k < m ; k ++ ) { scanf ( "%d %d %d" , & j , & next , & cost ) ; adlist [ j ] . push_back ( make_pair ( next , cost ) ) ; } int * d ; d = new int [ n ] ; for ( i = 0 ; i < n ; i ++ ) { d [ i ] = - 1 ; } d [ r ] = 0 ; priority_queue < current_cost > C ; current_cost cur = init ( r , 0 ) ; C . push ( cur ) ; int size ; bool * check ; check = new bool [ n ] ; for ( i = 0 ; i < n ; i ++ ) { check [ i ] = false ; } while ( ! C . empty ( ) ) { cur = C . top ( ) ; C . pop ( ) ; i = cur . index ; if ( check [ i ] ) continue ; check [ i ] = true ; size = adlist [ i ] . size ( ) ; for ( int j = 0 ; j < size ; j ++ ) { int k = adlist [ i ] [ j ] . first ; if ( d [ k ] < 0 || d [ i ] + adlist [ i ] [ j ] . second < d [ k ] ) { d [ k ] = d [ i ] + adlist [ i ] [ j ] . second ; C . push ( init ( k , d [ k ] ) ) ; } } } ; for ( i = 0 ; i < n ; i ++ ) { ( check [ i ] ? printf ( "%d\n" , d [ i ] ) : printf ( "INF\n" ) ) ; } return 0 ; }<CODESPLIT>-0.9297361969947815<CODESPLIT>5.7440900802612305<CODESPLIT>-1.242922306060791<CODESPLIT>-1.2843780517578125<CODESPLIT>-1.167761206626892<CODESPLIT>-1.4112988710403442
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <iostream> #include <vector> #include <queue> using namespace std ; struct E { int t ; int d ; E ( int _t , int _d ) { t = _t ; d = _d ; } } ; struct V { int cost = - 1 ; vector < E > es ; } ; typedef vector < V > G ; typedef pair < int , int > P ; int main ( int argc , char * argv [ ] ) { int v , e , r ; cin > > v > > e > > r ; G graph ( v ) ; for ( int i = 0 ; i < e ; i ++ ) { int s , t , d ; cin > > s > > t > > d ; graph [ s ] . es . push_back ( E ( t , d ) ) ; } priority_queue < P > q ; q . push ( P ( r , 0 ) ) ; graph [ r ] . cost = 0 ; while ( ! q . empty ( ) ) { P next = q . top ( ) ; q . pop ( ) ; int v = next . first ; int hereCost = next . second ; for ( auto e : graph [ v ] . es ) { int cost = e . d ; int newCost = hereCost + cost ; int oldCost = graph [ e . t ] . cost ; if ( newCost < oldCost || oldCost == - 1 ) { graph [ e . t ] . cost = newCost ; q . push ( P ( e . t , newCost ) ) ; } } } for ( auto v : graph ) { int d = v . cost ; if ( d == - 1 ) { cout << "INF" << endl ; } else { cout << d << endl ; } } return 0 ; }<CODESPLIT>-1.0872523784637451<CODESPLIT>5.751747131347656<CODESPLIT>-1.2189558744430542<CODESPLIT>-1.223052740097046<CODESPLIT>-1.1106139421463013<CODESPLIT>-1.39142644405365
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include<bits/stdc++.h> using namespace std ; #define ver first #define val second const int M = 1e5 ; const int INF = 1e9 ; vector < pair < int , int > > g [ M ] ; set < pair < int , int > > edge ; int n , m , dis [ M ] , b ; bool mark [ M ] ; void input ( ) { cin > > n > > m > > b ; for ( int i = 0 ; i < m ; i ++ ) { int u , v , w ; cin > > u > > v > > w ; g [ u ] . push_back ( make_pair ( v , w ) ) ; } } void update ( int v ) { mark [ v ] = true ; for ( int i = 0 ; i < g [ v ] . size ( ) ; i ++ ) if ( ! mark [ g [ v ] [ i ] . ver ] && dis [ v ] + g [ v ] [ i ] . val < dis [ g [ v ] [ i ] . ver ] ) { edge . erase ( make_pair ( dis [ g [ v ] [ i ] . ver ] , g [ v ] [ i ] . ver ) ) ; dis [ g [ v ] [ i ] . ver ] = dis [ v ] + g [ v ] [ i ] . val ; edge . insert ( make_pair ( dis [ g [ v ] [ i ] . ver ] , g [ v ] [ i ] . ver ) ) ; } } void dijkstra ( int v ) { fill ( dis , dis + n + 1 , INF ) ; dis [ v ] = 0 ; update ( v ) ; for ( int i = 1 ; i < n ; i ++ ) { pair < int , int > e = * edge . begin ( ) ; update ( e . second ) ; edge . erase ( e ) ; } } int main ( ) { input ( ) ; dijkstra ( b ) ; for ( int i = 0 ; i < n ; i ++ ) if ( dis [ i ] == INF ) cout << "INF" << endl ; else cout << dis [ i ] << endl ; return 0 ; }<CODESPLIT>-1.0058202743530273<CODESPLIT>5.758837699890137<CODESPLIT>-1.2502906322479248<CODESPLIT>-1.242757797241211<CODESPLIT>-1.132489562034607<CODESPLIT>-1.4036611318588257
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include<bits/stdc++.h> using namespace std ; using ll = long long ; const ll INF = 1LL << 60 ; struct Edge { int to ; ll w ; Edge ( int to , ll w ) : to ( to ) , w ( w ) { } } ; using Graph = vector < vector < Edge > > ; template < class T > bool chmin ( T & a , T b ) { if ( a > b ) { a = b ; return true ; } else return false ; } void dijkstra ( const Graph & G , vector < ll > & dist , int s ) { dist [ s ] = 0 ; priority_queue < pair < ll , int > , vector < pair < ll , int > > , greater < pair < ll , int > > > que ; que . push ( make_pair ( dist [ s ] , s ) ) ; while ( ! que . empty ( ) ) { int v = que . top ( ) . second ; ll d = que . top ( ) . first ; que . pop ( ) ; if ( d > dist [ v ] ) continue ; for ( auto e : G [ v ] ) { if ( chmin ( dist [ e . to ] , dist [ v ] + e . w ) ) { que . push ( make_pair ( dist [ e . to ] , e . to ) ) ; } } } } int main ( ) { int V , E , r ; cin > > V > > E > > r ; Graph G ( V ) ; for ( int i = 0 ; i < E ; i ++ ) { int s , t ; ll d ; cin > > s > > t > > d ; G [ s ] . push_back ( Edge ( t , d ) ) ; } vector < ll > dist ( V , INF ) ; dijkstra ( G , dist , r ) ; for ( int i = 0 ; i < V ; i ++ ) { if ( dist [ i ] == INF ) cout << "INF" << endl ; else cout << dist [ i ] << endl ; } return 0 ; }<CODESPLIT>-1.121665120124817<CODESPLIT>5.729780197143555<CODESPLIT>-1.2273764610290527<CODESPLIT>-1.2129958868026733<CODESPLIT>-1.1139702796936035<CODESPLIT>-1.372876524925232
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <iostream> #include <string> #include <vector> #include <queue> #include <map> #include <set> typedef long long ll ; const ll MOD = 1e9 + 7 ; const long long INF = 1LL << 60 ; const double PI = 3.14159265358979323846 ; const int NMAX = 100005 ; using namespace std ; ll fact [ 3000001 ] ; ll invfact [ 3000001 ] ; int main ( ) { ll v , e , r ; cin > > v > > e > > r ; vector < pair < int , ll > > edge [ v + 1 ] ; for ( int i = 0 ; i < e ; i ++ ) { ll s , t , d ; cin > > s > > t > > d ; edge [ s ] . push_back ( make_pair ( t , d ) ) ; } vector < ll > ans ( v + 1 , INF ) ; priority_queue < pair < ll , ll > , vector < pair < ll , ll > > , greater < pair < ll , ll > > > q ; q . push ( make_pair ( 0 , r ) ) ; while ( q . size ( ) > 0 ) { auto tmp = q . top ( ) ; q . pop ( ) ; ll w = tmp . first ; ll p = tmp . second ; if ( ans [ p ] == INF ) ans [ p ] = w ; else continue ; for ( int i = 0 ; i < edge [ p ] . size ( ) ; i ++ ) { q . push ( make_pair ( w + edge [ p ] [ i ] . second , edge [ p ] [ i ] . first ) ) ; } } for ( int i = 0 ; i < v ; i ++ ) { if ( ans [ i ] == INF ) { cout << "INF" << endl ; } else { cout << ans [ i ] << endl ; } } return 0 ; }<CODESPLIT>-1.0350863933563232<CODESPLIT>5.751216411590576<CODESPLIT>-1.2372503280639648<CODESPLIT>-1.2311569452285767<CODESPLIT>-1.1537437438964844<CODESPLIT>-1.394850254058838
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> using namespace std ; #define rep(i,k,n) for(int i=k;i<n;i++) #define INF INT_MAX #define P pair<int, int> struct edge { int to ; int cost ; } ; int main ( ) { int v , e , r ; cin > > v > > e > > r ; vector < vector < edge > > G ( v ) ; rep ( i , 0 , e ) { int s , t , d ; cin > > s > > t > > d ; edge tmp ; tmp . to = t ; tmp . cost = d ; G [ s ] . push_back ( tmp ) ; } vector < int > dis ( v , INF ) ; vector < bool > visited ( v , false ) ; dis [ r ] = 0 ; priority_queue < P , vector < P > , greater < P > > pq ; pq . push ( make_pair ( dis [ r ] , r ) ) ; while ( ! pq . empty ( ) ) { P tmp = pq . top ( ) ; pq . pop ( ) ; int cur = tmp . second ; if ( dis [ cur ] < tmp . first ) continue ; visited [ cur ] = true ; rep ( i , 0 , G [ cur ] . size ( ) ) { if ( dis [ G [ cur ] [ i ] . to ] > dis [ cur ] + G [ cur ] [ i ] . cost ) { dis [ G [ cur ] [ i ] . to ] = dis [ cur ] + G [ cur ] [ i ] . cost ; pq . push ( make_pair ( dis [ G [ cur ] [ i ] . to ] , G [ cur ] [ i ] . to ) ) ; } } } rep ( i , 0 , v ) { if ( dis [ i ] == INF ) cout << "INF" << endl ; else cout << dis [ i ] << endl ; } return 0 ; }<CODESPLIT>-1.0919933319091797<CODESPLIT>5.749380588531494<CODESPLIT>-1.233793020248413<CODESPLIT>-1.2200080156326294<CODESPLIT>-1.097318172454834<CODESPLIT>-1.3879057168960571
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> using namespace std ; #define MAX_V 100001 const long long INF = 1LL << 60 ; static int V , E , r ; static vector < pair < int , long long > > graph [ MAX_V ] ; static long long dist [ MAX_V ] ; void bfs ( ) { priority_queue < pair < long long , int > , vector < pair < long long , int > > , greater < pair < long long , int > > > pq ; for ( int i = 0 ; i < MAX_V ; ++ i ) dist [ i ] = INF ; dist [ r ] = 0 ; pq . push ( make_pair ( 0 , r ) ) ; while ( ! pq . empty ( ) ) { long long cD = pq . top ( ) . first ; int cV = pq . top ( ) . second ; pq . pop ( ) ; if ( dist [ cV ] < cD ) continue ; for ( int i = 0 ; i < graph [ cV ] . size ( ) ; ++ i ) { int nV = graph [ cV ] [ i ] . first ; long long nD = cD + graph [ cV ] [ i ] . second ; if ( dist [ nV ] > nD ) { dist [ nV ] = nD ; pq . push ( make_pair ( nD , nV ) ) ; } } } } int main ( ) { scanf ( "%d %d %d" , & V , & E , & r ) ; for ( int i = 0 ; i < E ; ++ i ) { int s , t ; long long w ; scanf ( "%d %d %lld" , & s , & t , & w ) ; graph [ s ] . push_back ( make_pair ( t , w ) ) ; } bfs ( ) ; for ( int i = 0 ; i < V ; ++ i ) { if ( dist [ i ] < INF ) printf ( "%lld\n" , dist [ i ] ) ; else printf ( "%s\n" , "INF" ) ; } return 0 ; }<CODESPLIT>-1.0190972089767456<CODESPLIT>5.742794036865234<CODESPLIT>-1.2434935569763184<CODESPLIT>-1.256086826324463<CODESPLIT>-1.135170578956604<CODESPLIT>-1.3656941652297974
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> using namespace std ; template < class T > bool chmin ( T & a , const T & b ) { if ( b < a ) { a = b ; return 1 ; } return 0 ; } #define rep(i, n) for (int i = 0; i < (int)(n); i++) const long long INF = 1LL << 60 ; using Graph = vector < vector < pair < int , long long > > > ; vector < long long > dijkstra ( const Graph & G , int N , int s ) { vector < long long > dist ( N , INF ) ; priority_queue < pair < long long , int > > pq ; dist [ s ] = 0 ; pq . emplace ( - dist [ s ] , s ) ; while ( ! pq . empty ( ) ) { int v = pq . top ( ) . second ; pq . pop ( ) ; for ( auto p : G [ v ] ) { if ( chmin ( dist [ p . first ] , dist [ v ] + p . second ) ) pq . emplace ( - dist [ p . first ] , p . first ) ; } } return dist ; } int main ( ) { int N , M , r ; cin > > N > > M > > r ; Graph G ( N ) ; rep ( i , M ) { int s , t , d ; cin > > s > > t > > d ; G [ s ] . emplace_back ( t , d ) ; } vector < long long > dist = dijkstra ( G , N , r ) ; for ( auto ans : dist ) { if ( ans == INF ) cout << "INF" << endl ; else cout << ans << endl ; } }<CODESPLIT>-1.0368618965148926<CODESPLIT>5.747821807861328<CODESPLIT>-1.2287781238555908<CODESPLIT>-1.2461941242218018<CODESPLIT>-1.1305488348007202<CODESPLIT>-1.3820923566818237
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> using namespace std ; typedef long long lint ; #define INF (lint)(3e18) #define P pair<int,int> struct Edge { lint to ; lint cost ; } ; void dijkstra ( const vector < vector < Edge > > & G , lint s , vector < lint > & dis ) { lint N = G . size ( ) ; dis . resize ( N , INF ) ; priority_queue < P , vector < P > , greater < P > > pq ; dis [ s ] = 0 ; pq . push ( { dis [ s ] , s } ) ; while ( ! pq . empty ( ) ) { P p = pq . top ( ) ; pq . pop ( ) ; int v = p . second ; if ( dis [ v ] < p . first ) { continue ; } for ( auto & e : G [ v ] ) { if ( dis [ e . to ] > dis [ v ] + e . cost ) { dis [ e . to ] = dis [ v ] + e . cost ; pq . push ( { dis [ e . to ] , e . to } ) ; } } } return ; } int main ( void ) { lint v , e , r ; cin > > v > > e > > r ; vector < vector < Edge > > a ( v ) ; for ( int i = 0 ; i < e ; i ++ ) { lint x , y , z ; cin > > x > > y > > z ; a [ x ] . push_back ( { y , z } ) ; } vector < lint > b ( v , INF ) ; dijkstra ( a , r , b ) ; for ( int i = 0 ; i < v ; i ++ ) { if ( b [ i ] ! = INF ) printf ( "%lld\n" , b [ i ] ) ; else cout << "INF" << endl ; } return 0 ; }<CODESPLIT>-1.089040756225586<CODESPLIT>5.726816177368164<CODESPLIT>-1.2307045459747314<CODESPLIT>-1.2171800136566162<CODESPLIT>-1.118906021118164<CODESPLIT>-1.3652594089508057
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> using namespace std ; typedef unsigned long long int ull ; typedef unsigned int ui ; const ull INF = 2e11 ; ui V , E ; vector < vector < pair < ui , ui > > > GraphInfo ; bool Visited [ 100000 ] ; ull Distance [ 100000 ] ; void solve ( ui startId ) { ui size , curId , nextId ; pair < ui , ui > nodeInfo ; priority_queue < pair < ui , ui > , vector < pair < ui , ui > > , greater < pair < ui , ui > > > nodeList ; memset ( Visited , false , sizeof ( Visited ) ) ; fill ( Distance , Distance + 100000 , INF ) ; Distance [ startId ] = 0 ; nodeList . push ( { 0 , startId } ) ; while ( ! nodeList . empty ( ) ) { nodeInfo = nodeList . top ( ) ; nodeList . pop ( ) ; curId = nodeInfo . second ; if ( Visited [ curId ] ) { continue ; } Visited [ curId ] = true ; size = GraphInfo [ curId ] . size ( ) ; for ( ui i = 0 ; i < size ; ++ i ) { nextId = GraphInfo [ curId ] [ i ] . first ; Distance [ nextId ] = min ( Distance [ nextId ] , Distance [ curId ] + GraphInfo [ curId ] [ i ] . second ) ; nodeList . push ( { Distance [ nextId ] , nextId } ) ; } } for ( ui i = 0 ; i < V ; ++ i ) { if ( Distance [ i ] == INF ) { cout << "INF" << endl ; } else { cout << Distance [ i ] << endl ; } } } int main ( ) { ui s , t , d , r ; ios :: sync_with_stdio ( false ) ; cin . tie ( NULL ) ; cout . tie ( NULL ) ; GraphInfo . clear ( ) ; cin > > V > > E > > r ; GraphInfo . resize ( V ) ; for ( ui i = 0 ; i < E ; ++ i ) { cin > > s > > t > > d ; GraphInfo [ s ] . push_back ( { t , d } ) ; } solve ( r ) ; return 0 ; }<CODESPLIT>-1.123935580253601<CODESPLIT>5.71536111831665<CODESPLIT>-1.2169357538223267<CODESPLIT>-1.2476627826690674<CODESPLIT>-1.1008679866790771<CODESPLIT>-1.3637174367904663
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include<iostream> #include<vector> #include<cstdio> #include<string> #include<algorithm> #include <queue> #define REP(i, n) for(int i = 0; i < n; i++) #define REPR(i, n) for(int i = n; i >= 0; i--) #define FOR(i, m, n) for(int i = m; i < n; i++) #define INF 2e9 #define ALL(v) v.begin(), v.end() using namespace std ; typedef long long ll ; const int max_n = 100000 ; const int max_m = 100000 ; using namespace std ; typedef pair < int , int > P ; const int maxv = 100000 ; const ll inf = 1LL << 60 ; struct edge { int to ; ll cost ; edge ( int a , ll b ) { to = a ; cost = b ; } } ; template < class Abel > struct Dijkstra { priority_queue < P , vector < P > , greater < P > > que ; vector < vector < edge > > G ; vector < ll > d ; vector < int > prev ; Dijkstra ( ) { G . resize ( maxv ) ; d . resize ( maxv , inf ) ; prev . resize ( maxv ) ; } void dijkstra ( int s ) { d [ s ] = 0 ; que . push ( P ( 0 , s ) ) ; while ( ! ( que . empty ( ) ) ) { P p = que . top ( ) ; que . pop ( ) ; int v = p . second ; if ( d [ v ] < p . first ) continue ; for ( int i = 0 ; i < G [ v ] . size ( ) ; i ++ ) { edge e = G [ v ] [ i ] ; if ( d [ e . to ] > d [ v ] + e . cost ) { d [ e . to ] = d [ v ] + e . cost ; prev [ e . to ] = v ; que . push ( P ( d [ e . to ] , e . to ) ) ; } } } } } ; int main ( ) { ios_base :: sync_with_stdio ( false ) ; int V , E , r ; cin > > V > > E > > r ; Dijkstra < ll > dij ; REP ( i , E ) { int s , t ; ll d ; cin > > s > > t > > d ; dij . G [ s ] . push_back ( edge ( t , d ) ) ; } dij . dijkstra ( r ) ; REP ( i , V ) { if ( dij . d [ i ] == inf ) cout << "INF" << endl ; else cout << dij . d [ i ] << endl ; } }<CODESPLIT>-0.9564476609230042<CODESPLIT>5.7615156173706055<CODESPLIT>-1.2343629598617554<CODESPLIT>-1.250211238861084<CODESPLIT>-1.148750901222229<CODESPLIT>-1.4265679121017456
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> using namespace std ; using ll = long long ; #define INF 1LL<<60  using Node = long long ; using Distance = long long ; using Weight = long long ; using Edge = pair < Node , Weight > ; using Graph = vector < vector < Edge > > ; ll V , E , r ; Graph G ; vector < Distance > dist ; void dijkstra ( Node start ) { priority_queue < pair < Distance , Node > , vector < pair < Distance , Node > > , greater < pair < Distance , Node > > > que ; dist . resize ( V , INF ) ; dist [ r ] = 0 ; que . push ( { 0 , start } ) ; while ( ! que . empty ( ) ) { Distance nowDist ; Node nowNode ; tie ( nowDist , nowNode ) = que . top ( ) ; que . pop ( ) ; if ( nowDist > dist [ nowNode ] ) continue ; for ( Edge next : G [ nowNode ] ) { Node nextDir = next . first ; Weight nextWeight = next . second ; if ( dist [ nextDir ] <= dist [ nowNode ] + nextWeight ) continue ; dist [ nextDir ] = dist [ nowNode ] + nextWeight ; que . push ( { dist [ nextDir ] , nextDir } ) ; } } } int main ( ) { cin > > V > > E > > r ; G . resize ( V ) ; for ( int i = 0 ; i < E ; i ++ ) { int s , t , d ; cin > > s > > t > > d ; G [ s ] . push_back ( { t , d } ) ; } dijkstra ( r ) ; for ( ll x : dist ) { if ( x == INF ) { cout << "INF" << endl ; } else { cout << x << endl ; } } }<CODESPLIT>-1.1350734233856201<CODESPLIT>5.702389717102051<CODESPLIT>-1.216249704360962<CODESPLIT>-1.2180883884429932<CODESPLIT>-1.0954138040542603<CODESPLIT>-1.3593889474868774
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <cstdio> #include <vector> #include <algorithm> #include <queue> #include <map> using namespace std ; typedef pair < int , int > P ; #define INF 1145141919810 struct edge { int to , cost ; } ; vector < edge > G [ 100010 ] ; long long d [ 100010 ] ; int main ( ) { int v , e , r ; scanf ( "%d" , & v ) ; scanf ( "%d" , & e ) ; scanf ( "%d" , & r ) ; for ( int i = 0 ; i < e ; i ++ ) { int s , t , d ; scanf ( "%d" , & s ) ; scanf ( "%d" , & t ) ; scanf ( "%d" , & d ) ; edge e ; e . to = t ; e . cost = d ; G [ s ] . push_back ( e ) ; } fill ( d , d + v , INF ) ; d [ r ] = 0 ; priority_queue < P , vector < P > , greater < P > > q ; q . push ( P ( 0 , r ) ) ; while ( ! q . empty ( ) ) { P p = q . top ( ) ; q . pop ( ) ; int v = p . second ; if ( d [ v ] < p . first ) { continue ; } for ( int i = 0 , size = G [ v ] . size ( ) ; i < size ; i ++ ) { edge e = G [ v ] [ i ] ; if ( d [ e . to ] > d [ v ] + e . cost ) { d [ e . to ] = d [ v ] + e . cost ; q . push ( P ( d [ e . to ] , e . to ) ) ; } } } for ( int i = 0 ; i < v ; i ++ ) { if ( d [ i ] == INF ) { printf ( "INF\n" ) ; } else { printf ( "%lld\n" , d [ i ] ) ; } } }<CODESPLIT>-1.0339152812957764<CODESPLIT>5.754157066345215<CODESPLIT>-1.2369577884674072<CODESPLIT>-1.2444655895233154<CODESPLIT>-1.14669668674469<CODESPLIT>-1.4103959798812866
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <iostream> #include <algorithm> #include <string> #include <vector> #include <stack> #include <queue> #include <set> #include <bitset> #include <map> #include <tuple> #include <unordered_set> #include <unordered_map> #include <list> #include <numeric> #include <utility> #include <iterator> #include <cstdio> #include <cmath> #include <cstdlib> #include <cstring> #include <climits> #include <ctime> #include <cassert> #include <random> #include <cstring> #define rep(i,n) for(int i=0;i<int(n);i++) #define all(x) (x).begin(),x.end() #define pb push_back using namespace std ; using ll = long long ; const ll mod = 1000000007 ; int dx [ 4 ] = { 1 , 0 , - 1 , 0 } ; int dy [ 4 ] = { 0 , 1 , 0 , - 1 } ; int ddx [ 8 ] = { - 1 , - 1 , 0 , 1 , 1 , 1 , 0 , - 1 } ; int ddy [ 8 ] = { 0 , 1 , 1 , 1 , 0 , - 1 , - 1 , - 1 } ; ll INF = 100000000000 ; struct Edge { int to ; ll cost ; } ; using P = pair < ll , ll > ; int main ( ) { ll s , V , E ; cin > > V > > E > > s ; vector < Edge > G [ V ] ; for ( int i = 0 ; i < E ; i ++ ) { int s , t , d ; cin > > s > > t > > d ; G [ s ] . push_back ( { t , d } ) ; } priority_queue < P , vector < P > , greater < P > > que ; ll d [ V ] ; for ( int i = 0 ; i < V ; i ++ ) { d [ i ] = INF ; } d [ s ] = 0 ; que . push ( P ( 0 , s ) ) ; while ( que . size ( ) ) { P p = que . top ( ) ; que . pop ( ) ; ll cost = p . first ; int v = p . second ; if ( d [ v ] < cost ) continue ; for ( int i = 0 ; i < G [ v ] . size ( ) ; i ++ ) { Edge e = G [ v ] [ i ] ; if ( d [ e . to ] > d [ v ] + e . cost ) { d [ e . to ] = d [ v ] + e . cost ; que . push ( P ( d [ e . to ] , e . to ) ) ; } } } for ( int i = 0 ; i < V ; i ++ ) { if ( d [ i ] == INF ) { cout << "INF" << endl ; } else { cout << d [ i ] << endl ; } } return 0 ; }<CODESPLIT>-0.953736424446106<CODESPLIT>5.723276615142822<CODESPLIT>-1.273404598236084<CODESPLIT>-1.2494456768035889<CODESPLIT>-1.1429153680801392<CODESPLIT>-1.4496670961380005
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include<iostream> #include<vector> #include<algorithm> using namespace std ; #define MV 100000 #define INF 1e9 struct edge { int to , cost ; } ; vector < edge > G [ MV ] ; bool used [ MV ] ; int V , E ; int d [ MV + 1 ] ; void bellmanford ( int s ) { fill ( d , d + MV , INF ) ; d [ s ] = 0 ; int c = 0 ; bool upd = false ; while ( true ) { upd = false ; for ( int i = 0 ; i < V ; i ++ ) { for ( int j = 0 ; j < G [ i ] . size ( ) ; j ++ ) { edge e = G [ i ] [ j ] ; if ( d [ i ] ! = INF && d [ e . to ] > d [ i ] + e . cost ) { d [ e . to ] = d [ i ] + e . cost ; upd = true ; } } } if ( ! upd ) break ; if ( c == V - 1 ) return ; c ++ ; } } int main ( ) { d [ MV ] = INF + 10 ; int first ; cin > > V > > E > > first ; for ( int i = 0 ; i < E ; i ++ ) { int f , t ; edge e ; cin > > f > > e . to > > e . cost ; G [ f ] . push_back ( e ) ; t = e . to ; } bellmanford ( first ) ; for ( int i = 0 ; i < V ; i ++ ) { if ( d [ i ] == INF ) { cout << "INF" << endl ; } else { cout << d [ i ] << endl ; } } }<CODESPLIT>-0.7713059186935425<CODESPLIT>5.732473373413086<CODESPLIT>-1.273339033126831<CODESPLIT>-1.265628695487976<CODESPLIT>-1.1955150365829468<CODESPLIT>-1.4527239799499512
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> using namespace std ; #define rep(i, n) for(int i = 0; i < n; i++) #define rep2(i, x, n) for(int i = x; i <= n; i++) #define rep3(i, x, n) for(int i = x; i >= n; i--) #define elif else if #define sp(x) fixed << setprecision(x) #define pb push_back #define eb emplace_back #define all(x) x.begin(), x.end() #define sz(x) (int)x.size() using ll = long long ; using ld = long double ; using pii = pair < int , int > ; using pil = pair < int , ll > ; using pli = pair < ll , int > ; using pll = pair < ll , ll > ; const ll MOD = 1e9+7 ; const int inf = ( 1 << 30 ) - 1 ; const ll INF = ( 1LL << 60 ) - 1 ; const ld EPS = 1e-10 ; template < typename T > bool chmax ( T & x , const T & y ) { return ( x < y ) ? ( x = y , true ) : false ; } ; template < typename T > bool chmin ( T & x , const T & y ) { return ( x > y ) ? ( x = y , true ) : false ; } ; template < typename T > struct Weighted_Graph { struct edge { int to ; T cost ; edge ( int to , T cost ) : to ( to ) , cost ( cost ) { } } ; vector < vector < edge > > es ; vector < T > d ; const T INF_T ; const int n ; Weighted_Graph ( int n ) : n ( n ) , INF_T ( numeric_limits < T > :: max ( ) ) { es . resize ( n ) , d . resize ( n ) ; } void add_edge ( int from , int to , T cost , bool directed = false ) { es [ from ] . eb ( to , cost ) ; if ( ! directed ) es [ to ] . eb ( from , cost ) ; } void dijkstra ( int s ) { fill ( all ( d ) , INF_T ) ; using P = pair < T , int > ; priority_queue < P , vector < P > , greater < P > > que ; que . emplace ( d [ s ] = 0 , s ) ; while ( ! que . empty ( ) ) { T p ; int i ; tie ( p , i ) = que . top ( ) ; que . pop ( ) ; if ( p > d [ i ] ) continue ; for ( auto & e : es [ i ] ) { if ( chmin ( d [ e . to ] , d [ i ] + e . cost ) ) que . emplace ( d [ e . to ] , e . to ) ; } } } } ; int main ( ) { int V , E , s ; cin > > V > > E > > s ; Weighted_Graph < int > G ( V ) ; rep ( i , E ) { int u , v , c ; cin > > u > > v > > c ; G . add_edge ( u , v , c , true ) ; } G . dijkstra ( s ) ; rep ( i , V ) { if ( G . d [ i ] >= inf ) cout << "INF" << endl ; else cout << G . d [ i ] << endl ; } }<CODESPLIT>-1.025240421295166<CODESPLIT>5.749955177307129<CODESPLIT>-1.22601318359375<CODESPLIT>-1.240854263305664<CODESPLIT>-1.1029305458068848<CODESPLIT>-1.432989239692688
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include<bits/stdc++.h> #define int long long #define INF INT_MAX #define P pair<int,int> using namespace std ; int d [ 100000 ] ; vector < P > f [ 500000 ] { } ; signed main ( ) { int a , b , c ; cin > > a > > b > > c ; fill ( d , d + a + 1 , INF ) ; d [ c ] = 0 ; priority_queue < P , vector < P > , greater < P > > Q ; Q . push ( P ( 0 , c ) ) ; for ( int h = 0 ; h < b ; h ++ ) { int i , j , k ; scanf ( "%lld%lld%lld" , & i , & j , & k ) ; f [ i ] . push_back ( P ( k , j ) ) ; } while ( Q . empty ( ) == false ) { P o = Q . top ( ) ; Q . pop ( ) ; int u = o . second ; if ( d [ u ] < o . first ) continue ; for ( int x = 0 ; x < f [ u ] . size ( ) ; x ++ ) { P l = f [ u ] [ x ] ; if ( d [ l . second ] > d [ u ] + l . first ) { d [ l . second ] = d [ u ] + l . first ; Q . push ( P ( d [ l . second ] , l . second ) ) ; } } } for ( int y = 0 ; y < a ; y ++ ) { if ( d [ y ] ! = INF ) printf ( "%lld\n" , d [ y ] ) ; else printf ( "INF\n" ) ; } }<CODESPLIT>-1.0882747173309326<CODESPLIT>5.75177526473999<CODESPLIT>-1.2383232116699219<CODESPLIT>-1.2133822441101074<CODESPLIT>-1.1164577007293701<CODESPLIT>-1.390151023864746
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include<bits/stdc++.h> using namespace std ; #define rep(i,n) for(int i=0; i<(n); i++) #define FOR(i,x,n) for(int i=x; i<(n); i++) #define ALL(n) begin(n),end(n) #define MOD 1000000007 typedef long long ll ; typedef unsigned int ui ; typedef unsigned long long ull ; typedef pair < int , int > P ; int V , E , st ; void BellmanFord ( vector < P > G [ ] , ll dist [ ] , int st ) { rep ( i , V ) dist [ i ] = INT64_MAX ; dist [ st ] = 0 ; bool update = true ; while ( update ) { update = false ; rep ( i , V ) { if ( dist [ i ] == INT64_MAX ) continue ; for ( auto e : G [ i ] ) { if ( dist [ e . second ] > dist [ i ] + e . first ) { dist [ e . second ] = dist [ i ] + e . first ; update = true ; } } } } return ; } void dijkstra ( vector < P > G [ ] , bool vis [ ] , ll dist [ ] , int st ) { priority_queue < P , vector < P > , greater < P > > min_heap ; min_heap . push ( { 0 , st } ) ; rep ( i , V ) vis [ i ] = false ; rep ( i , V ) dist [ i ] = INT64_MAX ; dist [ st ] = 0 ; int frm , d ; while ( ! min_heap . empty ( ) ) { tie ( d , frm ) = min_heap . top ( ) ; min_heap . pop ( ) ; if ( vis [ frm ] ) continue ; vis [ frm ] = true ; dist [ frm ] = d ; for ( P e : G [ frm ] ) { if ( dist [ e . second ] > d + e . first ) min_heap . push ( { d + e . first , e . second } ) ; } } } int main ( ) { cin > > V > > E > > st ; ll dist [ V ] ; bool vis [ V ] ; P edge ; vector < P > G [ V ] ; int frm , to , cst ; rep ( i , E ) { scanf ( "%d %d %d" , & frm , & to , & cst ) ; G [ frm ] . push_back ( { cst , to } ) ; } BellmanFord ( G , dist , st ) ; rep ( i , V ) { if ( dist [ i ] == INT64_MAX ) printf ( "INF\n" ) ; else printf ( "%lld\n" , dist [ i ] ) ; } }<CODESPLIT>-0.8992322087287903<CODESPLIT>5.763138294219971<CODESPLIT>-1.2392873764038086<CODESPLIT>-1.2669285535812378<CODESPLIT>-1.1556942462921143<CODESPLIT>-1.4215244054794312
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <iostream> #include <functional> #include <memory> #include <cassert> template < class T , class E , class Compare = std :: less < T > > struct skew_heap { using F = std :: function < T ( T , E ) > ; using G = std :: function < E ( E , E ) > ; using value_type = T ; using operator_type = E ; using size_type = std :: size_t ; private : const Compare c ; const F f ; const G g ; const operator_type ie ; size_type sz ; struct node { public : value_type val ; operator_type add ; std :: unique_ptr < node > left , right ; node ( const value_type & x , const operator_type & e ) : val ( x ) , add ( e ) , left ( nullptr ) , right ( nullptr ) { } } ; using node_ptr = std :: unique_ptr < node > ; node_ptr root ; node_ptr propagate ( node_ptr x ) { if ( not x ) return ( std :: move ( x ) ) ; if ( ( x -> add ) == ie ) return ( std :: move ( x ) ) ; if ( x -> left ) { ( x -> left -> add ) = g ( x -> left -> add , x -> add ) ; } if ( x -> right ) { ( x -> right -> add ) = g ( x -> right -> add , x -> add ) ; } ( x -> val ) = f ( x -> val , x -> add ) ; ( x -> add ) = ie ; return ( std :: move ( x ) ) ; } node_ptr meld ( node_ptr a , node_ptr b ) { a = propagate ( std :: move ( a ) ) ; b = propagate ( std :: move ( b ) ) ; if ( not a ) return ( std :: move ( b ) ) ; if ( not b ) return ( std :: move ( a ) ) ; if ( c ( ( a -> val ) , ( b -> val ) ) ) a . swap ( b ) ; ( a -> right ) = meld ( std :: move ( a -> right ) , std :: move ( b ) ) ; ( a -> right ) . swap ( a -> left ) ; return ( std :: move ( a ) ) ; } public : skew_heap ( const F & f , const G & g , const operator_type & ie ) : f ( f ) , g ( g ) , c ( ) , ie ( ie ) , sz ( 0 ) , root ( nullptr ) { } skew_heap ( skew_heap && rhs ) noexcept : f ( rhs . f ) , g ( rhs . g ) , c ( rhs . c ) , ie ( rhs . ie ) , sz ( rhs . sz ) , root ( std :: move ( rhs . root ) ) { } constexpr int size ( ) const noexcept { return ( sz ) ; } constexpr bool empty ( ) const noexcept { return ( sz == 0 ) ; } value_type top ( ) { assert ( not empty ( ) ) ; return ( root -> add == ie ? root -> val : f ( root -> val , root -> add ) ) ; } void pop ( ) { assert ( not empty ( ) ) ; root = propagate ( std :: move ( root ) ) ; sz -- ; root = meld ( std :: move ( root -> left ) , std :: move ( root -> right ) ) ; } void push ( const value_type & x ) { root = propagate ( std :: move ( root ) ) ; sz ++ ; root = meld ( std :: move ( root ) , std :: make_unique < node > ( node ( x , ie ) ) ) ; } void add ( const operator_type & x ) { if ( root ) ( root -> add ) = g ( root -> add , x ) ; } void meld ( skew_heap & rhs ) { ( this -> sz ) += ( rhs . sz ) ; rhs . sz = 0 ; ( this -> root ) = meld ( std :: move ( this -> root ) , std :: move ( rhs . root ) ) ; rhs . root = nullptr ; } } ; #include <bits/stdc++.h> using namespace std ; using skewheap = skew_heap < pair < int , int > , int , greater < pair < int , int > > > ; const int INF = ( 1 << 30 ) ; int main ( ) { int n , m , r ; cin > > n > > m > > r ; vector < skewheap > edges ; auto f = [ ] ( pair < int , int > p , int b ) { p . first += b ; return p ; } ; auto g = [ ] ( int a , int b ) { return ( a + b ) ; } ; for ( int i = 0 ; i < n ; i ++ ) edges . push_back ( skewheap ( f , g , 0 ) ) ; for ( int i = 0 ; i < m ; i ++ ) { int a , b , c ; cin > > a > > b > > c ; edges [ a ] . push ( make_pair ( c , b ) ) ; } vector < int > dist ( n , INF ) ; dist [ r ] = 0 ; skewheap sh ( f , g , 0 ) ; sh . meld ( edges [ r ] ) ; while ( not sh . empty ( ) ) { int cost , v ; tie ( cost , v ) = sh . top ( ) ; sh . pop ( ) ; if ( dist [ v ] > cost ) { dist [ v ] = cost ; edges [ v ] . add ( dist [ v ] ) ; sh . meld ( edges [ v ] ) ; } } for ( int i = 0 ; i < n ; i ++ ) { if ( dist [ i ] == INF ) { cout << "INF" << '\n' ; } else { cout << dist [ i ] << '\n' ; } } return 0 ; }<CODESPLIT>-1.0467958450317383<CODESPLIT>5.734009742736816<CODESPLIT>-1.2224165201187134<CODESPLIT>-1.2064127922058105<CODESPLIT>-1.1496895551681519<CODESPLIT>-1.40364670753479
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> #define rep(i, n) for (int i = 0; i < int(n); i++) #define rrep(i, n) for (int i = int(n) - 1; i >= 0; i--) #define reps(i, n) for (int i = 1; i <= int(n); i++) #define rreps(i, n) for (int i = int(n); i >= 1; i--) #define repc(i, n) for (int i = 0; i <= int(n); i++) #define rrepc(i, n) for (int i = int(n); i >= 0; i--) #define repi(i, a, b) for (int i = int(a); i < int(b); i++) #define repic(i, a, b) for (int i = int(a); i <= int(b); i++) #define each(x, y) for (auto &x : y) #define all(a) (a).begin(), (a).end() #define bit(b) (1ll << (b)) #define uniq(v) (v).erase(unique(all(v)), (v).end()) #define rsort(v) sort(all(v)); reverse(all(v)) using namespace std ; using i32 = int ; using i64 = long long ; using f80 = long double ; using vi32 = vector < i32 > ; using vi64 = vector < i64 > ; using vf80 = vector < f80 > ; using vstr = vector < string > ; inline void yes ( ) { cout << "Yes" << '\n' ; exit ( 0 ) ; } inline void no ( ) { cout << "No" << '\n' ; exit ( 0 ) ; } inline i64 gcd ( i64 a , i64 b ) { if ( min ( a , b ) == 0 ) return max ( a , b ) ; if ( a % b == 0 ) return b ; return gcd ( b , a % b ) ; } inline i64 lcm ( i64 a , i64 b ) { return a / gcd ( a , b ) * b ; } void solve ( ) ; int main ( ) { ios :: sync_with_stdio ( 0 ) ; cin . tie ( 0 ) ; cout << fixed << setprecision ( 16 ) ; solve ( ) ; return 0 ; } template < typename T > class pqasc : public priority_queue < T , vector < T > , greater < T > > { } ; template < typename T > class pqdesc : public priority_queue < T , vector < T > , less < T > > { } ; template < typename T > inline void amax ( T & x , T y ) { if ( x < y ) x = y ; } template < typename T > inline void amin ( T & x , T y ) { if ( x > y ) x = y ; } template < typename T > inline T power ( T x , i64 n ) { T r = 1 ; while ( n > 0 ) { if ( n & 1 ) r *= x ; x *= x ; n > >= 1 ; } return r ; } template < typename T > istream & operator > > ( istream & is , vector < T > & v ) { for ( auto & x : v ) is > > x ; return is ; } template < typename T > ostream & operator << ( ostream & os , const vector < T > & v ) { rep ( i , v . size ( ) ) { if ( i ) os << ' ' ; os << v [ i ] ; } return os ; } template < typename T > struct WeightedGraph { struct Edge { int to ; T cost ; } ; vector < vector < Edge > > edges ; int n ; WeightedGraph ( int n ) : n ( n ) { edges = vector < vector < Edge > > ( n ) ; } void add_edge ( int from , int to , T cost = 0 ) { edges [ from ] . push_back ( ( Edge ) { to , cost } ) ; } vector < Edge > & operator [ ] ( int x ) { return edges [ x ] ; } } ; template < typename T > vector < T > dijkstra ( WeightedGraph < T > & g , int s ) { const T INF = numeric_limits < T > :: max ( ) ; vector < T > dist ( g . n , INF ) ; pqasc < pair < T , int > > q ; vector < bool > used ( g . n ) ; dist [ s ] = 0 ; q . push ( { 0 , s } ) ; while ( ! q . empty ( ) ) { auto p = q . top ( ) ; q . pop ( ) ; T d ; int v ; tie ( d , v ) = p ; if ( used [ v ] ) continue ; used [ v ] = true ; each ( e , g [ v ] ) { if ( used [ e . to ] ) continue ; assert ( dist [ v ] ! = INF ) ; if ( dist [ e . to ] > dist [ v ] + e . cost ) { dist [ e . to ] = dist [ v ] + e . cost ; q . push ( { dist [ e . to ] , e . to } ) ; } } } return dist ; } void solve ( ) { int V , E , r ; cin > > V > > E > > r ; auto g = WeightedGraph < i64 > ( V ) ; rep ( i , E ) { int s , t , d ; cin > > s > > t > > d ; g . add_edge ( s , t , d ) ; } auto ans = dijkstra ( g , r ) ; rep ( i , V ) { if ( ans [ i ] == numeric_limits < i64 > :: max ( ) ) { cout << "INF" << '\n' ; } else { cout << ans [ i ] << '\n' ; } } }<CODESPLIT>-0.11503100395202637<CODESPLIT>5.6460371017456055<CODESPLIT>-1.3255226612091064<CODESPLIT>-1.32396399974823<CODESPLIT>-1.244033694267273<CODESPLIT>-1.563207983970642
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <iostream> #include <queue> #include <stack> #include <vector> #include <stdio.h> #include <algorithm> #include <string> #include <cstring> #include <cmath> #include <complex> #include <map> #include <climits> using namespace std ; #define rep(i,n) for(int i=0;i<int(n);++i) #define ALL(v) (v).begin(),(v).end() #define PB push_back #define EPS 1e-8 #define F first #define S second static const double PI = 6 * asin ( 0.5 ) ; typedef long long ll ; typedef complex < double > CP ; typedef pair < int , int > P ; static const ll INF = 10000000000000 ; struct ED { int s , t , d ; } ; bool operator < ( ED a , ED b ) { return a . d > b . d ; } bool operator < ( pair < ll , ED > a , pair < ll , ED > b ) { return a . F > b . F ; } int main ( ) { int V , E , r , s , t , d ; vector < vector < ED > > v ( 100010 ) ; ll vmin [ 100010 ] ; int vis [ 100010 ] ; int exi [ 100010 ] ; priority_queue < pair < long long , ED > > pq ; cin > > V > > E > > r ; rep ( i , 100010 ) { vmin [ i ] = INF ; vis [ i ] = 0 ; exi [ i ] = 0 ; } rep ( i , E ) { cin > > s > > t > > d ; ED t1 , t2 ; t1 . s = s ; t1 . t = t ; t1 . d = d ; t2 . s = t ; t2 . t = s ; t2 . d = d ; v [ s ] . PB ( t1 ) ; exi [ t ] = exi [ s ] = 1 ; } vmin [ r ] = 0 ; vis [ r ] = 1 ; rep ( i , v [ r ] . size ( ) ) { pair < int , ED > tp ; tp . F = v [ r ] [ i ] . d ; tp . S = v [ r ] [ i ] ; pq . push ( tp ) ; } while ( ! pq . empty ( ) ) { pair < ll , ED > tmp = pq . top ( ) ; pq . pop ( ) ; if ( vis [ tmp . S . t ] == 1 ) continue ; vmin [ tmp . S . t ] = tmp . F ; vis [ tmp . S . t ] = 1 ; rep ( i , v [ tmp . S . t ] . size ( ) ) { if ( vis [ v [ tmp . S . t ] [ i ] . t ] == 0 ) { pair < ll , ED > tp ; tp . F = tmp . F + v [ tmp . S . t ] [ i ] . d ; tp . S = v [ tmp . S . t ] [ i ] ; pq . push ( tp ) ; } } } rep ( i , V ) { if ( vis [ i ] == 1 ) { cout << vmin [ i ] << endl ; } else if ( vmin [ i ] == INF ) { cout << "INF" << endl ; } } return 0 ; }<CODESPLIT>-1.0778650045394897<CODESPLIT>5.740628242492676<CODESPLIT>-1.2364355325698853<CODESPLIT>-1.2280162572860718<CODESPLIT>-1.1499543190002441<CODESPLIT>-1.404342532157898
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> using namespace std ; #define REP(i, n) for(int i = 0; i < n; i++) #define REPR(i, n) for(int i = n - 1; i >= 0; i--) #define FOR(i, m, n) for(int i = m; i <= n; i++) #define FORR(i, m, n) for(int i = m; i >= n; i--) #define SORT(v, n) sort(v, v+n); #define VSORT(v) sort(v.begin(), v.end()); #define VSORTR(v) sort(v.rbegin(), v.rend()); #define ALL(v) (v).begin(),(v).end() using ll = long long ; using vll = vector < ll > ; using vvll = vector < vector < ll > > ; using P = pair < ll , ll > ; using vvp = vector < vector < P > > ; template < typename T > using min_priority_queue = priority_queue < T , vector < T > , greater < T > > ; template < class T > bool chmax ( T & a , const T & b ) { if ( a < b ) { a = b ; return 1 ; } return 0 ; } template < class T > bool chmin ( T & a , const T & b ) { if ( b < a ) { a = b ; return 1 ; } return 0 ; } const ll mod = 1e9 + 7 ; const ll inf = 1e18 ; int main ( ) { cin . tie ( 0 ) ; ios :: sync_with_stdio ( false ) ; cout << fixed << setprecision ( 10 ) ; ll n , m , r ; cin > > n > > m > > r ; ll a , b , c ; vvp e ( n ) ; REP ( i , m ) { cin > > a > > b > > c ; e [ a ] . push_back ( { b , c } ) ; } vll res ( n , inf ) ; res [ r ] = 0 ; min_priority_queue < P > que ; que . push ( { 0 , r } ) ; ll cur , mem ; while ( ! que . empty ( ) ) { mem = que . top ( ) . first , cur = que . top ( ) . second ; que . pop ( ) ; for ( auto ee : e [ cur ] ) { ll to = ee . first , w = ee . second ; if ( chmin ( res [ to ] , res [ cur ] + w ) ) { que . push ( { res [ to ] , to } ) ; } } } REP ( i , n ) { if ( res [ i ] == inf ) cout << "INF" << endl ; else cout << res [ i ] << endl ; } return 0 ; }<CODESPLIT>-0.7238918542861938<CODESPLIT>5.741997718811035<CODESPLIT>-1.256047010421753<CODESPLIT>-1.2765541076660156<CODESPLIT>-1.1465630531311035<CODESPLIT>-1.471686840057373
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <iostream> #include <vector> #include <queue> #include <limits> #define FORR(i,b,e) for(int i=(b);i<(int)(e);++i) #define FOR(i,e) FORR(i,0,e) #define dump(var) cerr << #var ": " << var << "\n" #define dumpc(con) for(auto& e: con) cerr << e << " "; cerr<<"\n" typedef long long ll ; typedef unsigned long long ull ; const double EPS = 1e-6 ; const int d4 [ ] = { 0 , - 1 , 0 , 1 , 0 } ; using namespace std ; typedef pair < int , int > Pii ; const int INF = numeric_limits < int > :: max ( ) ; int main ( ) { cin . tie ( 0 ) ; ios :: sync_with_stdio ( false ) ; int V , E , r ; cin > > V > > E > > r ; vector < vector < Pii > > edge ( V ) ; FOR ( i , E ) { int s , t , d ; cin > > s > > t > > d ; edge [ s ] . push_back ( make_pair ( t , d ) ) ; } vector < int > dist ( V , INF ) ; dist [ r ] = 0 ; priority_queue < Pii , vector < Pii > , greater < Pii > > q ; q . push ( Pii ( 0 , r ) ) ; while ( ! q . empty ( ) ) { Pii cur = q . top ( ) ; q . pop ( ) ; int cdist = cur . first , cv = cur . second ; if ( dist [ cv ] < cdist ) continue ; FOR ( i , edge [ cv ] . size ( ) ) { int nd = cdist + edge [ cv ] [ i ] . second , nv = edge [ cv ] [ i ] . first ; if ( nd < dist [ nv ] ) { dist [ nv ] = nd ; q . push ( Pii ( nd , nv ) ) ; } } } for ( auto & d : dist ) { if ( d == INF ) cout << "INF" ; else cout << d ; cout << '\n' ; } return 0 ; }<CODESPLIT>-1.058485984802246<CODESPLIT>5.732797622680664<CODESPLIT>-1.2269606590270996<CODESPLIT>-1.2495118379592896<CODESPLIT>-1.1542526483535767<CODESPLIT>-1.408908486366272
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include<iostream> #include<cstdio> #include<cstdlib> #include<algorithm> #include<vector> #include<string> #include<sstream> #include<iomanip> #include<utility> #include<cmath> #include<set> #include<list> #include<string> #include<queue> #include<stack> #include<deque> #include<map> #include<set> #include<cstring> #include<iterator> #include<bitset> #include<assert.h> using namespace std ; typedef long long ll ; static const int MOD = 1000000007 ; #define PB push_back #define MP make_pair #define MT make_tuple #define FI first #define SE second #define NP next_permutation #define PQ priority_queue #define UB upper_bound #define LB lower_bound #define SZ(a) int((a).size()) #define LEN(a) int((a).length()) #define SORT(c) sort((c).begin(),(c).end()) #define FOR(i,a,b) for(int i=(a);i<(b);i++) #define REP(i,x) for(int i=0;i<(int)(x);i++) #define REP1(i,x) for(int i=1;i<=(int)(x);i++) #define RREP(i,x) for(int i=((int)(x)-1);i>=0;i--) #define RREP1(i,x) for(int i=((int)(x));i>0;i--) #define ALL(x) (x).begin(),(x).end() #define YESNO(x) puts((x)?"YES":"NO") template < typename T > struct edge { int src , to ; T cost ; edge ( int to , T cost ) : src ( - 1 ) , to ( to ) , cost ( cost ) { } edge ( int src , int to , T cost ) : src ( src ) , to ( to ) , cost ( cost ) { } operator int ( ) const { return to ; } } ; template < typename T > using Edges = vector < edge < T > > ; template < typename T > using WeightedGraph = vector < Edges < T > > ; template < typename T > vector < T > dijkstra ( WeightedGraph < T > & g , int s ) { const auto INF = numeric_limits < T > :: max ( ) ; vector < T > dist ( g . size ( ) , INF ) ; using Pi = pair < T , int > ; priority_queue < Pi , vector < Pi > , greater < Pi > > que ; dist [ s ] = 0 ; que . emplace ( dist [ s ] , s ) ; while ( ! que . empty ( ) ) { T cost ; int idx ; tie ( cost , idx ) = que . top ( ) ; que . pop ( ) ; if ( dist [ idx ] < cost ) continue ; for ( auto & e : g [ idx ] ) { auto next_cost = cost + e . cost ; if ( dist [ e . to ] <= next_cost ) continue ; dist [ e . to ] = next_cost ; que . emplace ( dist [ e . to ] , e . to ) ; } } return dist ; } signed main ( ) { int v , e , r ; cin > > v > > e > > r ; WeightedGraph < unsigned > g ( v ) ; REP ( i , e ) { int t1 , t2 , t3 ; cin > > t1 > > t2 > > t3 ; g [ t1 ] . emplace_back ( t2 , t3 ) ; } auto cost = dijkstra ( g , r ) ; REP ( i , v ) { if ( cost [ i ] == numeric_limits < unsigned > :: max ( ) ) puts ( "INF" ) ; else printf ( "%d\n" , cost [ i ] ) ; } return 0 ; }<CODESPLIT>-1.0061057806015015<CODESPLIT>5.734905242919922<CODESPLIT>-1.2549552917480469<CODESPLIT>-1.223353624343872<CODESPLIT>-1.1275280714035034<CODESPLIT>-1.3900986909866333
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> using namespace std ; #define TemplateVersion "3.4.0" #ifdef LOCAL #define debug(args...)                           \<CODESPLIT>-0.7020826935768127<CODESPLIT>5.647917747497559<CODESPLIT>-1.242120623588562<CODESPLIT>-1.180530071258545<CODESPLIT>-1.116353154182434<CODESPLIT>-1.382878065109253
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <iostream> #include <sstream> #include <cstdio> #include <stdlib.h> #include <string> #include <vector> #include <algorithm> #include <queue> using namespace std ; struct edge { int to , w ; } ; #define MAX 1000000005 vector < vector < edge > > g ; vector < int > min_d ; priority_queue < edge , vector < edge > , greater < edge > > que ; bool operator > ( const edge a , const edge b ) { return a . w > b . w ; } ; void dfs ( int v , int n ) { edge this_p ; for ( int i = 0 ; i < n ; i ++ ) min_d [ i ] = MAX ; min_d [ v ] = 0 ; for ( auto e : g [ v ] ) { que . push ( e ) ; min_d [ e . to ] = e . w ; } while ( ! que . empty ( ) ) { this_p = que . top ( ) ; que . pop ( ) ; for ( auto e : g [ this_p . to ] ) { if ( min_d [ e . to ] > min_d [ this_p . to ] + e . w ) { min_d [ e . to ] = min_d [ this_p . to ] + e . w ; que . push ( e ) ; } } } } int main ( ) { int v , e , s , t , r , w ; edge tmp ; cin > > v > > e > > r ; g . resize ( v ) ; min_d . resize ( v ) ; tmp . to = r ; tmp . w = 0 ; g [ r ] . push_back ( tmp ) ; for ( int i = 0 ; i < e ; i ++ ) { cin > > s > > t > > w ; tmp . to = t ; tmp . w = w ; g [ s ] . push_back ( tmp ) ; } dfs ( r , v ) ; for ( auto i : min_d ) { if ( i == MAX ) cout << "INF" << endl ; else cout << i << endl ; } return 0 ; }<CODESPLIT>-1.1125398874282837<CODESPLIT>5.746289253234863<CODESPLIT>-1.2229623794555664<CODESPLIT>-1.205381155014038<CODESPLIT>-1.1292970180511475<CODESPLIT>-1.392159342765808
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <iostream> #include <cstdio> #include <climits> #include <cmath> #include <cassert> #include <algorithm> #include <utility> #include <vector> #include <string> #include <stack> #include <queue> #include <map> #define MAX 100 #define INFTY 1<<30  #define N 100 #define N2 10000   #define REP(i,n) for(int i=0;i<n;i++) #define ALL(o) (o).begin(), (o).end() using namespace std ; typedef long long llong ; int V , E , R , S [ 500010 ] , T [ 500010 ] , D [ 500010 ] ; int C [ 100010 ] ; int main ( ) { cin . tie ( 0 ) ; ios :: sync_with_stdio ( false ) ; cin > > V > > E > > R ; REP ( i , E ) cin > > S [ i ] > > T [ i ] > > D [ i ] ; REP ( i , V ) C [ i ] = INFTY ; C [ R ] = 0 ; REP ( j , V ) { bool update = false ; REP ( i , E ) { int s = S [ i ] , t = T [ i ] , d = D [ i ] ; if ( C [ s ] < INFTY && C [ s ] + d < C [ t ] ) { C [ t ] = C [ s ] + d ; update = true ; } } if ( ! update ) break ; } REP ( i , V ) { if ( C [ i ] == INFTY ) cout << "INF" << endl ; else cout << C [ i ] << endl ; } return 0 ; }<CODESPLIT>-1.035935401916504<CODESPLIT>5.744603157043457<CODESPLIT>-1.2374355792999268<CODESPLIT>-1.2313419580459595<CODESPLIT>-1.1411081552505493<CODESPLIT>-1.412214994430542
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include<cstdio> #include<cstring> #include<vector> #include<queue> #include<algorithm> #include<cmath> using namespace std ; #define rep(i,n) for(int i=0;i<(n);i++) #define reg(i,a,b) for(int i=(a);i<=(b);i++) typedef long long int lli ; typedef pair < int , int > mp ; #define fir first #define sec second int dijkstra ( int n , int s , vector < mp > * vs , int * dist , int g = - 1 ) { memset ( dist , - 1 , sizeof ( int ) * n ) ; priority_queue < mp , vector < mp > , greater < mp > > que ; que . push ( mp ( 0 , s ) ) ; while ( ! que . empty ( ) ) { mp pa = que . top ( ) ; que . pop ( ) ; int co = pa . fir , no = pa . sec ; if ( dist [ no ] ! = - 1 && dist [ no ] < co ) continue ; dist [ no ] = co ; if ( no == g ) return co ; rep ( i , vs [ no ] . size ( ) ) { mp pb = vs [ no ] [ i ] ; int to = pb . fir , tc = co + pb . sec ; if ( dist [ to ] ! = - 1 && dist [ to ] <= tc ) continue ; dist [ to ] = tc ; que . push ( mp ( tc , to ) ) ; } } return - 1 ; } int n , m ; vector < mp > vs [ 100005 ] ; int dist [ 100005 ] ; int main ( void ) { int n , m , s ; scanf ( "%d%d%d" , & n , & m , & s ) ; rep ( i , m ) { int a , b , c ; scanf ( "%d%d%d" , & a , & b , & c ) ; vs [ a ] . push_back ( mp ( b , c ) ) ; } dijkstra ( n , s , vs , dist ) ; rep ( i , n ) { if ( dist [ i ] ! = - 1 ) printf ( "%d\n" , dist [ i ] ) ; else printf ( "INF\n" ) ; } return 0 ; }<CODESPLIT>-1.111203670501709<CODESPLIT>5.743945121765137<CODESPLIT>-1.2171826362609863<CODESPLIT>-1.2417187690734863<CODESPLIT>-1.1134662628173828<CODESPLIT>-1.3911099433898926
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include<iostream> #include<vector> #include<algorithm> #include<functional> #include<queue> #include<chrono> #include<iomanip> #include<map> #include<set> using namespace std ; using ll = long long ; using P = pair < ll , ll > ; void init_io ( ) { cin . tie ( 0 ) ; ios :: sync_with_stdio ( false ) ; cout << setprecision ( 10 ) ; } #define MAX_V 2000000 #define INF 10000000000 ll d [ MAX_V ] ; struct edge { ll to , cost ; } ; vector < edge > G [ MAX_V ] ; void dij ( ll s ) { priority_queue < P , vector < P > , greater < P > > que ; fill ( d , d + MAX_V , INF ) ; d [ s ] = 0 ; que . push ( make_pair ( 0 , s ) ) ; while ( ! que . empty ( ) ) { P p = que . top ( ) ; que . pop ( ) ; ll v = p . second ; if ( d [ v ] < p . first ) continue ; for ( ll i = 0 ; i < G [ v ] . size ( ) ; i ++ ) { edge e = G [ v ] [ i ] ; if ( d [ e . to ] > d [ v ] + e . cost ) { d [ e . to ] = d [ v ] + e . cost ; que . push ( make_pair ( d [ e . to ] , e . to ) ) ; } } } } signed main ( ) { init_io ( ) ; ll v , e , r ; cin > > v > > e > > r ; ll s , t , di ; for ( int i = 0 ; i < e ; i ++ ) { cin > > s > > t > > di ; G [ s ] . push_back ( { t , di } ) ; } dij ( r ) ; for ( int i = 0 ; i < v ; i ++ ) { if ( d [ i ] == INF ) cout << "INF\n" ; else cout << d [ i ] << endl ; } }<CODESPLIT>-1.2009855508804321<CODESPLIT>5.728611946105957<CODESPLIT>-1.21830415725708<CODESPLIT>-1.1970393657684326<CODESPLIT>-1.0850355625152588<CODESPLIT>-1.373752236366272
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> #define INF INT_MAX using namespace std ; struct edge { int to ; int cost ; } ; typedef pair < int , int > P ; int main ( ) { cin . tie ( 0 ) ; ios :: sync_with_stdio ( false ) ; int V , E , r ; cin > > V > > E > > r ; vector < vector < edge > > G ( V , vector < edge > ( ) ) ; for ( int i = 0 ; i < E ; i ++ ) { int s_i , t_i , d_i ; cin > > s_i > > t_i > > d_i ; G [ s_i ] . push_back ( { t_i , d_i } ) ; } vector < int > d ( V ) ; fill ( d . begin ( ) , d . end ( ) , INF ) ; d [ r ] = 0 ; priority_queue < P , vector < P > , greater < P > > que ; que . push ( P ( 0 , r ) ) ; while ( ! que . empty ( ) ) { P p = que . top ( ) ; que . pop ( ) ; int v = p . second ; if ( d [ v ] < p . first ) continue ; for ( uint j = 0 ; j < G [ v ] . size ( ) ; j ++ ) { edge e = G [ v ] [ j ] ; if ( d [ e . to ] > d [ v ] + e . cost ) { d [ e . to ] = d [ v ] + e . cost ; que . push ( P ( d [ e . to ] , e . to ) ) ; } } } for ( int i = 0 ; i < V ; i ++ ) { if ( d [ i ] == INF ) { cout << "INF" << endl ; } else { cout << d [ i ] << endl ; } } }<CODESPLIT>-1.153836965560913<CODESPLIT>5.742879867553711<CODESPLIT>-1.2171101570129395<CODESPLIT>-1.1959526538848877<CODESPLIT>-1.083360195159912<CODESPLIT>-1.3485548496246338
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <algorithm> #include <cstdint> #include <iostream> #include <queue> #include <string> #include <sstream> #include <vector> typedef std :: uint_least64_t cost_t ; #define COST_INF UINT_LEAST64_MAX struct Edge { int target ; int distance ; } ; struct Node { std :: vector < Edge > edges ; cost_t cost ; Node ( ) : cost ( COST_INF ) { } } ; int main ( ) { int v , e , r ; std :: cin > > v > > e > > r ; std :: vector < Node > nodes ( v ) ; nodes [ r ] . cost = 0 ; for ( int i = 0 ; i < e ; i ++ ) { int s , t , d ; std :: cin > > s > > t > > d ; nodes [ s ] . edges . push_back ( { t , d } ) ; } auto greater_node = [ & ] ( int x , int y ) { return nodes [ x ] . cost > nodes [ y ] . cost ; } ; std :: priority_queue < int , std :: vector < int > , decltype ( greater_node ) > queue ( greater_node ) ; queue . push ( r ) ; while ( ! queue . empty ( ) ) { Node & node = nodes [ queue . top ( ) ] ; queue . pop ( ) ; for ( Edge e : node . edges ) { Node & target = nodes [ e . target ] ; cost_t new_cost = node . cost + e . distance ; if ( new_cost < target . cost ) { target . cost = new_cost ; queue . push ( e . target ) ; } } } for ( Node & node : nodes ) { if ( node . cost == COST_INF ) std :: cout << "INF" ; else std :: cout << node . cost ; std :: cout << std :: endl ; } return 0 ; }<CODESPLIT>-1.0542136430740356<CODESPLIT>5.7534589767456055<CODESPLIT>-1.2141450643539429<CODESPLIT>-1.233889102935791<CODESPLIT>-1.114592432975769<CODESPLIT>-1.3974627256393433
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> using namespace std ; using LL = long long ; using P = pair < int , int > ; #define FOR(i, a, n) for(int i = (int)(a); i < (int)(n); ++i) #define REP(i, n) FOR(i, 0, n) #define pb(a) push_back(a) #define all(x) (x).begin(),(x).end() const int INF = ( int ) 1e9 ; const LL INFL = ( LL ) 1e19 ; const int MOD = 1e9 + 7 ; template < typename T > struct Edge { int from , to ; T cost ; Edge ( int to , T cost ) : from ( - 1 ) , to ( to ) , cost ( cost ) { } Edge ( int from , int to , T cost ) : from ( from ) , to ( to ) , cost ( cost ) { } } ; template < typename T > using Edges = vector < Edge < T > > ; template < typename T > using AdjList = vector < Edges < T > > ; template < typename T > class Dijkstra { private : T INF = numeric_limits < T > :: max ( ) / 10 ; int V ; AdjList < T > adj ; vector < int > prever ; public : Dijkstra ( int n ) : V ( n + 1 ) , adj ( V ) , prever ( vector < int > ( V , - 1 ) ) , cost ( V , INF ) { } vector < T > cost ; void AddEdge ( int f , int t , int c ) { adj [ f ] . push_back ( Edge < T > ( t , c ) ) ; } bool HasPath ( int t ) { return cost [ t ] ! = INF ; } vector < int > GetShortestPath ( int t ) { vector < int > path ; for ( ; t ! = - 1 ; t = prever [ t ] ) path . push_back ( t ) ; reverse ( path . begin ( ) , path . end ( ) ) ; return path ; } void Run ( int f ) { cost . assign ( V , INF ) ; prever . assign ( V , - 1 ) ; using Pi = pair < T , int > ; priority_queue < Pi , vector < Pi > , greater < Pi > > pq ; cost [ f ] = 0 ; pq . push ( Pi ( cost [ f ] , f ) ) ; while ( ! pq . empty ( ) ) { Pi currentEdge = pq . top ( ) ; pq . pop ( ) ; if ( cost [ currentEdge . second ] < currentEdge . first ) continue ; for ( Edge < T > tmp : adj [ currentEdge . second ] ) { T sumCost = currentEdge . first + tmp . cost ; if ( cost [ tmp . to ] > sumCost ) { cost [ tmp . to ] = sumCost ; prever [ tmp . to ] = currentEdge . second ; pq . push ( Pi ( cost [ tmp . to ] , tmp . to ) ) ; } } } } } ; signed main ( ) { cin . tie ( 0 ) ; ios :: sync_with_stdio ( false ) ; int v , e , r ; cin > > v > > e > > r ; Dijkstra < LL > dij ( v ) ; REP ( i , e ) { int s , t , d ; cin > > s > > t > > d ; dij . AddEdge ( s , t , d ) ; } dij . Run ( r ) ; REP ( i , v ) { cout << ( dij . HasPath ( i ) ? to_string ( dij . cost [ i ] ) : "INF" ) << endl ; } }<CODESPLIT>-1.0431947708129883<CODESPLIT>5.741236209869385<CODESPLIT>-1.2409120798110962<CODESPLIT>-1.2135295867919922<CODESPLIT>-1.1394163370132446<CODESPLIT>-1.407401204109192
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> using namespace std ; #define fi first #define se second #define pb push_back typedef long long LL ; typedef long double LD ; const LL INF = ( 1LL << 60 ) ; typedef pair < LL , int > PLL ; void dijkstra ( int n , vector < PLL > adjList [ ] , int source , vector < LL > & dist ) ; int main ( ) { ios_base :: sync_with_stdio ( 0 ) ; cin . tie ( 0 ) ; vector < PLL > adjList [ 100005 ] ; int n , m , r ; cin > > n > > m > > r ; for ( int i = 0 ; i < m ; i ++ ) { int s , t ; LL d ; cin > > s > > t > > d ; adjList [ s ] . pb ( { d , t } ) ; } vector < LL > dist ; dijkstra ( n , adjList , r , dist ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( dist [ i ] == INF ) cout << "INF" << endl ; else cout << dist [ i ] << endl ; } return 0 ; } void dijkstra ( int n , vector < PLL > adjList [ ] , int source , vector < LL > & dist ) { dist . assign ( n , INF ) ; dist [ source ] = 0 ; priority_queue < PLL , vector < PLL > , greater < PLL > > pq ; pq . push ( { 0LL , source } ) ; while ( ! pq . empty ( ) ) { LL cost ; int u ; tie ( cost , u ) = pq . top ( ) ; pq . pop ( ) ; if ( cost > dist [ u ] ) continue ; for ( PLL neighbor : adjList [ u ] ) { LL w ; int v ; tie ( w , v ) = neighbor ; if ( dist [ v ] > dist [ u ] + w ) { dist [ v ] = dist [ u ] + w ; pq . push ( { dist [ v ] , v } ) ; } } } }<CODESPLIT>-1.0976413488388062<CODESPLIT>5.746477127075195<CODESPLIT>-1.2366750240325928<CODESPLIT>-1.2181755304336548<CODESPLIT>-1.1277318000793457<CODESPLIT>-1.3744059801101685
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include<stdio.h> #include<string.h> #include<vector> #include<algorithm> #include<bits/stdc++.h> #define INF 0x3f3f3f3f using namespace std ; struct node { int end ; int power ; } t ; const int maxn = 100010 ; int n ; vector < node > q [ maxn ] ; int dis [ maxn ] ; int vis [ maxn ] ; priority_queue < pair < int , int > > qu ; void Dijkstra ( int start ) { memset ( dis , INF , sizeof ( dis ) ) ; dis [ start ] = 0 ; qu . push ( make_pair ( 0 , start ) ) ; while ( ! qu . empty ( ) ) { int x = qu . top ( ) . second ; qu . pop ( ) ; if ( vis [ x ] ) continue ; vis [ x ] = 1 ; int len = q [ x ] . size ( ) ; for ( int j = 0 ; j < len ; j ++ ) { if ( vis [ q [ x ] [ j ] . end ] == 0 && dis [ q [ x ] [ j ] . end ] > q [ x ] [ j ] . power + dis [ x ] ) { dis [ q [ x ] [ j ] . end ] = q [ x ] [ j ] . power + dis [ x ] ; qu . push ( make_pair ( - dis [ q [ x ] [ j ] . end ] , q [ x ] [ j ] . end ) ) ; } } } } int main ( ) { int m , i ; int begin , end , power ; int a , b ; scanf ( "%d%d%d" , & n , & m , & a ) ; for ( i = 0 ; i < m ; i ++ ) { scanf ( "%d%d%d" , & begin , & end , & power ) ; t . end = end ; t . power = power ; q [ begin ] . push_back ( t ) ; } Dijkstra ( a ) ; for ( int t = 0 ; t < n ; ++ t ) { if ( dis [ t ] == INF ) { printf ( "INF\n" ) ; } else { printf ( "%d\n" , dis [ t ] ) ; } } return 0 ; }<CODESPLIT>-1.1191041469573975<CODESPLIT>5.7355546951293945<CODESPLIT>-1.2029476165771484<CODESPLIT>-1.2375361919403076<CODESPLIT>-1.1068217754364014<CODESPLIT>-1.3508259057998657
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> using namespace std ; typedef long long ll ; typedef vector < ll > vl ; typedef vector < vl > vvl ; typedef pair < ll , ll > pl ; typedef vector < pl > vp ; #define fore(i,a,b) for(ll i=(ll)(a);i<=(ll)(b);++i) #define rep(i,n) fore(i,0,(n)-1) #define rfore(i,a,b) for(ll i=(ll)(b);i>=(ll)(a);--i) #define rrep(i,n) rfore(i,0,(n)-1) #define all(x) (x).begin(),(x).end() const ll INF = 1001001001 ; const ll LINF = 1001001001001001001 ; const ll D4 [ ] = { 0 , 1 , 0 , - 1 , 0 } ; const ll D8 [ ] = { 0 , 1 , 1 , 0 , - 1 , - 1 , 1 , - 1 , 0 } ; template < class T > bool chmax ( T & a , const T & b ) { if ( a < b ) { a = b ; return 1 ; } return 0 ; } template < class T > bool chmin ( T & a , const T & b ) { if ( b < a ) { a = b ; return 1 ; } return 0 ; } #define N 100005 vp g [ N ] ; void solve ( ) { ll v , e , r ; cin > > v > > e > > r ; rep ( i , e ) { ll s , t , d ; cin > > s > > t > > d ; g [ s ] . push_back ( pl ( t , d ) ) ; } vl dist ( v , LINF ) ; dist [ r ] = 0 ; priority_queue < pl , vp , greater < pl > > que ; que . push ( pl ( 0 , r ) ) ; while ( ! que . empty ( ) ) { pl p1 = que . top ( ) ; que . pop ( ) ; ll d = p1 . first , s = p1 . second ; if ( dist [ s ] < d ) continue ; dist [ s ] = d ; rep ( i , g [ s ] . size ( ) ) { ll t = g [ s ] [ i ] . first , d2 = g [ s ] [ i ] . second ; if ( dist [ t ] <= d + d2 ) continue ; dist [ t ] = d + d2 ; que . push ( pl ( d + d2 , t ) ) ; } } rep ( i , v ) { if ( dist [ i ] == LINF ) cout << "INF" << endl ; else cout << dist [ i ] << endl ; } } int main ( ) { cin . tie ( 0 ) ; ios :: sync_with_stdio ( 0 ) ; solve ( ) ; }<CODESPLIT>-0.9374338388442993<CODESPLIT>5.751324653625488<CODESPLIT>-1.2432284355163574<CODESPLIT>-1.2353382110595703<CODESPLIT>-1.1399739980697632<CODESPLIT>-1.4488033056259155
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include<bits/stdc++.h> using namespace std ; typedef long long ll ; typedef pair < int , int > pp ; int main ( ) { const int MAX = 1000000000 ; int v , e , r ; cin > > v > > e > > r ; vector < pp > g [ v ] ; vector < int > d ( v , MAX ) ; for ( int i = 0 ; i < e ; i ++ ) { int s , t , d ; cin > > s > > t > > d ; g [ s ] . push_back ( pp ( t , d ) ) ; } d [ r ] = 0 ; priority_queue < pp , vector < pp > , greater < pp > > que ; que . push ( pp ( r , 0 ) ) ; while ( ! que . empty ( ) ) { pp p = que . top ( ) ; que . pop ( ) ; int v = p . first ; if ( d [ v ] < p . second ) continue ; for ( pp next : g [ v ] ) { if ( d [ next . first ] > d [ v ] + next . second ) { d [ next . first ] = d [ v ] + next . second ; que . push ( pp ( next . first , d [ next . first ] ) ) ; } } } for ( int i = 0 ; i < v ; i ++ ) { if ( d [ i ] == MAX ) cout << "INF" << endl ; else cout << d [ i ] << endl ; } return 0 ; }<CODESPLIT>-1.059720754623413<CODESPLIT>5.750697135925293<CODESPLIT>-1.2285710573196411<CODESPLIT>-1.217508316040039<CODESPLIT>-1.1199449300765991<CODESPLIT>-1.3782994747161865
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> using namespace std ; typedef pair < int , int > P ; int v , e , r ; const long long INF = 1e18 ; const int V_MAX = 100010 ; struct edge { int to ; long long cost ; } ; vector < edge > G [ V_MAX ] ; long long D [ V_MAX ] ; void dijkstra ( int start ) { priority_queue < P , vector < P > , greater < P > > q ; for ( int i = 0 ; i < v ; i ++ ) { D [ i ] = INF ; } D [ start ] = 0 ; q . push ( { start , 0 } ) ; while ( ! q . empty ( ) ) { P p = q . top ( ) ; q . pop ( ) ; int now = p . first ; if ( D [ now ] < p . second ) continue ; for ( int i = 0 ; i < G [ now ] . size ( ) ; i ++ ) { edge e = G [ now ] [ i ] ; if ( D [ e . to ] > D [ now ] + e . cost ) { D [ e . to ] = D [ now ] + e . cost ; q . push ( { e . to , D [ e . to ] } ) ; } } } } int main ( ) { cin . tie ( 0 ) ; ios :: sync_with_stdio ( false ) ; cin > > v > > e > > r ; for ( int i = 0 ; i < e ; i ++ ) { int s , t , d ; cin > > s > > t > > d ; G [ s ] . push_back ( { t , d } ) ; } dijkstra ( r ) ; for ( int i = 0 ; i < v ; i ++ ) { if ( D [ i ] == INF ) cout << "INF" << endl ; else cout << D [ i ] << endl ; } return 0 ; }<CODESPLIT>-1.0282297134399414<CODESPLIT>5.723470211029053<CODESPLIT>-1.2339181900024414<CODESPLIT>-1.2412962913513184<CODESPLIT>-1.154807209968567<CODESPLIT>-1.3733946084976196
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include "bits/stdc++.h" using namespace std ; int main ( ) { int v , e , r , inf = 1000000000 ; scanf ( "%d %d %d" , & v , & e , & r ) ; vector < vector < pair < int , int > > > a ( v , vector < pair < int , int > > ( 0 ) ) ; for ( int i = 0 , s , t , d ; i < e ; i ++ ) { scanf ( "%d %d %d" , & s , & t , & d ) ; a [ s ] . push_back ( make_pair ( d , t ) ) ; } vector < int > cost ( v , inf ) , vis ( v , false ) ; priority_queue < pair < int , int > , vector < pair < int , int > > , greater < pair < int , int > > > q ; cost [ r ] = 0 ; q . push ( make_pair ( 0 , r ) ) ; for ( pair < int , int > t ; ! q . empty ( ) ; ) { t = q . top ( ) ; q . pop ( ) ; vis [ t . second ] = true ; if ( cost [ t . second ] < t . first ) { continue ; } for ( int i = 0 ; i < a [ t . second ] . size ( ) ; i ++ ) { if ( ! vis [ a [ t . second ] [ i ] . second ] && cost [ a [ t . second ] [ i ] . second ] > cost [ t . second ] + a [ t . second ] [ i ] . first ) { cost [ a [ t . second ] [ i ] . second ] = cost [ t . second ] + a [ t . second ] [ i ] . first ; q . push ( make_pair ( cost [ a [ t . second ] [ i ] . second ] , a [ t . second ] [ i ] . second ) ) ; } } } for ( int i = 0 ; i < v ; i ++ ) { printf ( cost [ i ] >= inf ? "INF\n" : "%d\n" , cost [ i ] ) ; } }<CODESPLIT>-0.9521582126617432<CODESPLIT>5.734447479248047<CODESPLIT>-1.2530615329742432<CODESPLIT>-1.2588820457458496<CODESPLIT>-1.1474486589431763<CODESPLIT>-1.4056291580200195
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> #define be(v) (v).begin(),(v).end() #define pb(q) push_back(q) typedef long long ll ; using namespace std ; const ll mod = 1000000007 ; #define doublecout(a) cout<<fixed<<setprecision(10)<<a<<endl; ll dis [ 100000 ] ; vector < vector < pair < ll , ll > > > g ( 100000 ) ; void dijkstra ( ll start ) { for ( int i = 0 ; i < 100000 ; i ++ ) dis [ i ] = 1e18 ; dis [ start ] = 0 ; multiset < pair < ll , ll > > ms ; ms . insert ( make_pair ( 0 , start ) ) ; pair < ll , ll > p , niko ; ll maki ; while ( ! ms . empty ( ) ) { p = * ( ms . begin ( ) ) ; ms . erase ( ms . begin ( ) ) ; if ( dis [ p . second ] < p . first ) continue ; maki = g [ p . second ] . size ( ) ; for ( int i = 0 ; i < maki ; i ++ ) { niko = g [ p . second ] [ i ] ; if ( dis [ niko . first ] > dis [ p . second ] + niko . second ) { dis [ niko . first ] = dis [ p . second ] + niko . second ; ms . insert ( make_pair ( dis [ niko . first ] , niko . first ) ) ; } } } return ; } int main ( ) { cin . tie ( 0 ) ; cout . tie ( 0 ) ; ios :: sync_with_stdio ( false ) ; int n , m , s , a , b , c ; cin > > n > > m > > s ; for ( int i = 0 ; i < m ; i ++ ) { cin > > a > > b > > c ; g [ a ] . pb ( make_pair ( b , c ) ) ; } dijkstra ( s ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( dis [ i ] == 1e18 ) cout << "INF" << endl ; else cout << dis [ i ] << endl ; } return 0 ; }<CODESPLIT>-1.1382452249526978<CODESPLIT>5.745337009429932<CODESPLIT>-1.2189815044403076<CODESPLIT>-1.207200288772583<CODESPLIT>-1.1080049276351929<CODESPLIT>-1.3690751791000366
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <cstdio> #include <cstdlib> #include <cstring> const int N = 100010 ; const int M = 500010 ; const int inf = 0x3fffffff ; struct Edge { int to , len , next ; } es [ M ] ; int SIZE = 0 ; int h [ N ] ; int dist [ N ] , queue [ N ] , inq [ N ] ; inline void add ( int u , int v , int w ) { int i = ++ SIZE ; es [ i ] . to = v ; es [ i ] . len = w ; es [ i ] . next = h [ u ] ; h [ u ] = i ; } inline int inc ( int x ) { return ( x == N - 1 ? 0 : x + 1 ) ; } void sssp ( int r ) { int front = 0 , back = 0 ; queue [ back ++ ] = r ; while ( front ! = back ) { int x = queue [ front ] ; inq [ x ] = 0 ; front = inc ( front ) ; for ( int i = h [ x ] ; i ; i = es [ i ] . next ) { int y = es [ i ] . to ; int new_d = dist [ x ] + es [ i ] . len ; if ( new_d < dist [ y ] ) { dist [ y ] = new_d ; if ( ! inq [ y ] ) { queue [ back ] = y ; inq [ y ] = 1 ; back = inc ( back ) ; } } } } } void run ( ) { int n , m , r , x , y , w ; scanf ( "%d%d%d" , & n , & m , & r ) ; memset ( h , 0 , sizeof ( h ) ) ; for ( int i = 0 ; i < m ; i ++ ) { scanf ( "%d%d%d" , & x , & y , & w ) ; add ( x , y , w ) ; } for ( int i = 0 ; i < n ; i ++ ) { dist [ i ] = ( i == r ? 0 : inf ) ; inq [ i ] = 0 ; } sssp ( r ) ; for ( int i = 0 ; i < n ; i ++ ) if ( dist [ i ] == inf ) printf ( "INF\n" ) ; else printf ( "%d\n" , dist [ i ] ) ; } int main ( ) { run ( ) ; }<CODESPLIT>-0.8456411957740784<CODESPLIT>5.71605920791626<CODESPLIT>-1.237926959991455<CODESPLIT>-1.2752879858016968<CODESPLIT>-1.1922643184661865<CODESPLIT>-1.4094473123550415
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <iostream> #include <vector> #include <queue> #include <utility> using namespace std ; const int INF = ( 1e9 ) ; vector < int > dijkstra ( vector < vector < pair < int , int > > > & G , int s ) { vector < int > ret ( G . size ( ) , INF ) ; priority_queue < pair < int , int > > wait ; wait . emplace ( 0 , s ) ; while ( ! wait . empty ( ) ) { int c = - wait . top ( ) . first , v = wait . top ( ) . second ; wait . pop ( ) ; if ( ret [ v ] < c ) continue ; ret [ v ] = c ; for ( size_t i = 0 ; i < G [ v ] . size ( ) ; ++ i ) { int c_ = c + G [ v ] [ i ] . first , v_ = G [ v ] [ i ] . second ; if ( c_ < ret [ v_ ] ) { ret [ v_ ] = c_ ; wait . emplace ( - c_ , v_ ) ; } } } return ret ; } int main ( ) { int V , E , r ; cin > > V > > E > > r ; vector < vector < pair < int , int > > > G ( V ) ; for ( int i = 0 ; i < E ; ++ i ) { int s , t , d ; cin > > s > > t > > d ; G [ s ] . emplace_back ( d , t ) ; } vector < int > ans = dijkstra ( G , r ) ; for ( int i = 0 ; i < V ; ++ i ) { if ( ans [ i ] < INF ) cout << ans [ i ] << endl ; else cout << "INF" << endl ; } return 0 ; }<CODESPLIT>-1.0041812658309937<CODESPLIT>5.7382683753967285<CODESPLIT>-1.2441189289093018<CODESPLIT>-1.2390305995941162<CODESPLIT>-1.1154628992080688<CODESPLIT>-1.3883202075958252
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> #include <queue> using namespace std ; #define rep(i, n) for (int i = 0; i < (n); i++) #define contains(v, t) (find(v.begin(), v.end(), t) != v.end()) #define MOD 1000000007 using ll = long long ; using ull = unsigned long long ; using Pii = pair < int , int > ; struct edge { int to , cost ; } ; vector < int > dijkstra ( vector < vector < edge > > g , int start , int v_count , int e_count ) { vector < int > d ( v_count ) ; rep ( i , v_count ) d [ i ] = 1 << 30 ; d [ start ] = 0 ; priority_queue < Pii , vector < Pii > , greater < Pii > > que ; que . emplace ( d [ start ] , start ) ; while ( ! que . empty ( ) ) { Pii p = que . top ( ) ; que . pop ( ) ; int v = p . second ; if ( p . first > d [ v ] ) continue ; rep ( i , g [ v ] . size ( ) ) { edge e = g [ v ] [ i ] ; if ( d [ e . to ] > d [ v ] + e . cost ) { d [ e . to ] = d [ v ] + e . cost ; que . push ( Pii ( d [ e . to ] , e . to ) ) ; } } } return d ; } int main ( ) { int vc , ec , r ; cin > > vc > > ec > > r ; vector < vector < edge > > g ( 500000 ) ; rep ( i , ec ) { int s , t , d ; cin > > s > > t > > d ; g [ s ] . push_back ( { t , d } ) ; } vector < int > d = dijkstra ( g , r , vc , ec ) ; rep ( i , vc ) { if ( d [ i ] == 1 << 30 ) cout << "INF" << endl ; else cout << d [ i ] << endl ; } }<CODESPLIT>-1.1144554615020752<CODESPLIT>5.736750602722168<CODESPLIT>-1.2171807289123535<CODESPLIT>-1.234723448753357<CODESPLIT>-1.111374020576477<CODESPLIT>-1.3765844106674194
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> #define INF 10e9 #define rep(i, a) for (int i = 0; i < (a); i++) using namespace std ; typedef struct edge { long long int from ; long long int to ; long long int cost ; } edge ; int main ( ) { long long int V , E , r ; cin > > V > > E > > r ; vector < edge > edges ; long long int i ; for ( i = 0 ; i < E ; i ++ ) { long long int s , t , d ; cin > > s > > t > > d ; edge e ; e . from = s ; e . to = t ; e . cost = d ; edges . push_back ( e ) ; } long long int dist [ V ] ; for ( i = 0 ; i < V ; i ++ ) { dist [ i ] = INF ; } dist [ r ] = 0 ; long long int count = 0 ; bool update ; if ( E == 0 ) { update = false ; } else { update = true ; } while ( update ) { count ++ ; update = false ; for ( i = 0 ; i < E ; i ++ ) { edge e = edges [ i ] ; if ( dist [ e . from ] ! = INF && dist [ e . to ] > dist [ e . from ] + e . cost ) { dist [ e . to ] = dist [ e . from ] + e . cost ; update = true ; } } } for ( i = 0 ; i < V ; i ++ ) { if ( dist [ i ] ! = INF ) { cout << dist [ i ] << endl ; } else { cout << "INF" << endl ; } } }<CODESPLIT>-0.9780897498130798<CODESPLIT>5.760042190551758<CODESPLIT>-1.2450082302093506<CODESPLIT>-1.2529425621032715<CODESPLIT>-1.1357451677322388<CODESPLIT>-1.4058723449707031
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <iostream> #include <functional> #include <algorithm> #include <vector> #include <queue> #include <limits> using namespace std ; template < class T , class Compare = less < T > > using MaxHeap = priority_queue < T , vector < T > , Compare > ; template < class T , class Compare = greater < T > > using MinHeap = priority_queue < T , vector < T > , Compare > ; using llong = long long ; template < class T > struct Edge { int src , to ; T cost ; Edge ( int to , T cost ) : src ( - 1 ) , to ( to ) , cost ( cost ) { } ; Edge ( int src , int to , T cost ) : src ( src ) , to ( to ) , cost ( cost ) { } ; operator int ( ) const { return to ; } ; } ; template < class T > using WeightedGraph = vector < vector < Edge < T > > > ; using UnWeightedGraph = vector < vector < int > > ; template < class T > vector < T > dijkstra ( WeightedGraph < T > & g , int s ) { const T INF = numeric_limits < T > :: max ( ) ; using P = pair < T , int > ; vector < T > min_cost ( g . size ( ) , INF ) ; priority_queue < P , vector < P > , greater < P > > que ; que . emplace ( 0 , s ) ; while ( ! que . empty ( ) ) { T cost = que . top ( ) . first ; int pos = que . top ( ) . second ; que . pop ( ) ; if ( min_cost [ pos ] ! = INF ) continue ; min_cost [ pos ] = cost ; for ( Edge < T > e : g [ pos ] ) { if ( min_cost [ e . to ] <= cost + e . cost ) continue ; que . emplace ( cost + e . cost , e . to ) ; } } return min_cost ; } ; int AOJ_GRL_1_A ( ) { ios :: sync_with_stdio ( false ) ; cin . tie ( nullptr ) ; int n , m , r ; int s , t , d ; const llong INF = numeric_limits < int > :: max ( ) ; cin > > n > > m > > r ; WeightedGraph < int > g ( n ) ; for ( int i = 0 ; i < m ; i ++ ) { cin > > s > > t > > d ; g [ s ] . emplace_back ( t , d ) ; } vector < int > dist = dijkstra ( g , r ) ; for ( int i = 0 ; i < n ; i ++ ) { if ( dist [ i ] == INF ) cout << "INF" << '\n' ; else cout << dist [ i ] << '\n' ; } return 0 ; } int main ( ) { AOJ_GRL_1_A ( ) ; return 0 ; }<CODESPLIT>-1.056625485420227<CODESPLIT>5.697381973266602<CODESPLIT>-1.2388341426849365<CODESPLIT>-1.2209525108337402<CODESPLIT>-1.1375528573989868<CODESPLIT>-1.424596905708313
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> using namespace std ; #define rep(i, n) for (int i = (int)(0); i < (int)(n); ++i) #define reps(i, n) for (int i = (int)(1); i <= (int)(n); ++i) #define rrep(i, n) for (int i = ((int)(n)-1); i >= 0; i--) #define rreps(i, n) for (int i = ((int)(n)); i > 0; i--) #define irep(i, m, n) for (int i = (int)(m); i < (int)(n); ++i) #define ireps(i, m, n) for (int i = (int)(m); i <= (int)(n); ++i) #define SORT(v, n) sort(v, v + n); #define REVERSE(v, n) reverse(v, v+n); #define vsort(v) sort(v.begin(), v.end()); #define all(v) v.begin(), v.end() #define mp(n, m) make_pair(n, m); #define cout(d) cout<<d<<endl; #define coutd(d) cout<<std::setprecision(10)<<d<<endl; #define cinline(n) getline(cin,n); #define replace_all(s, b, a) replace(s.begin(),s.end(), b, a); #define PI (acos(-1)) #define FILL(v, n, x) fill(v, v + n, x); #define sz(x) int(x.size()) using ll = long long ; using vi = vector < int > ; using vvi = vector < vi > ; using vll = vector < ll > ; using vvll = vector < vll > ; using pii = pair < int , int > ; using pll = pair < ll , ll > ; template < class T > inline bool chmax ( T & a , T b ) { if ( a < b ) { a = b ; return 1 ; } return 0 ; } template < class T > inline bool chmin ( T & a , T b ) { if ( a > b ) { a = b ; return 1 ; } return 0 ; } const int INF = 1e9 ; const int MOD = 1e9+7 ; const ll LINF = 1e18 ; ll n , m ; vector < pll > G [ 100005 ] ; ll dist [ 100005 ] ; void dijikstra ( ll s ) { fill ( dist , dist + n , LINF ) ; dist [ s ] = 0 ; priority_queue < pll , vector < pll > , greater < pll > > q ; q . emplace ( 0 , s ) ; while ( ! q . empty ( ) ) { pll v = q . top ( ) ; q . pop ( ) ; if ( dist [ v . second ] < v . first ) continue ; for ( auto nv : G [ v . second ] ) { if ( dist [ nv . first ] > dist [ v . second ] + nv . second ) { dist [ nv . first ] = dist [ v . second ] + nv . second ; q . emplace ( dist [ nv . first ] , nv . first ) ; } } } } signed main ( ) { cin . tie ( 0 ) ; ios :: sync_with_stdio ( false ) ; ll r ; cin > > n > > m > > r ; rep ( i , m ) { ll a , b , c ; cin > > a > > b > > c ; G [ a ] . emplace_back ( b , c ) ; } dijikstra ( r ) ; rep ( i , n ) { if ( dist [ i ] ! = LINF ) cout << dist [ i ] << endl ; else cout << "INF" << endl ; } }<CODESPLIT>-0.31258657574653625<CODESPLIT>5.653390884399414<CODESPLIT>-1.3090195655822754<CODESPLIT>-1.2950044870376587<CODESPLIT>-1.2055217027664185<CODESPLIT>-1.517298698425293
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <bits/stdc++.h> using namespace std ; typedef long long ll ; typedef vector < int > vi ; typedef vector < vi > vvi ; typedef vector < ll > vll ; typedef vector < vll > vvll ; typedef vector < string > vs ; typedef pair < int , int > P ; #define rep(i, n) for(int i = 0; i < (int)(n); i++) #define all(x) (x).begin(),(x).end() #define rall(x) (x).rbegin(),(x).rend() void YN ( bool flg ) { if ( flg ) cout << "YES" << endl ; else cout << "NO" << endl ; } void Yn ( bool flg ) { if ( flg ) cout << "Yes" << endl ; else cout << "No" << endl ; } void yn ( bool flg ) { if ( flg ) cout << "yes" << endl ; else cout << "no" << endl ; } struct Edge { int to ; int cost ; } ; const int MAXV = 100010 ; const int INF = 1001001001 ; int V , E , r ; vector < vector < Edge > > g ( MAXV ) ; void dijkstra ( ) { vi d ( V , INF ) ; d [ r ] = 0 ; priority_queue < P , vector < P > , greater < P > > q ; q . push ( { r , 0 } ) ; while ( ! q . empty ( ) ) { auto p = q . top ( ) ; q . pop ( ) ; int from = p . first ; rep ( i , g [ from ] . size ( ) ) { auto v = g [ from ] [ i ] ; int to = v . to ; int cost = v . cost ; if ( d [ to ] > d [ from ] + cost ) { d [ to ] = min ( d [ to ] , d [ from ] + cost ) ; q . push ( { to , d [ to ] } ) ; } } } rep ( i , V ) { if ( d [ i ] == INF ) cout << "INF" << endl ; else cout << d [ i ] << endl ; } } int main ( ) { cin > > V > > E > > r ; rep ( i , E ) { int s , t , d ; cin > > s > > t > > d ; g [ s ] . push_back ( Edge { t , d } ) ; } dijkstra ( ) ; return 0 ; }<CODESPLIT>-0.9970713257789612<CODESPLIT>5.752176761627197<CODESPLIT>-1.2334270477294922<CODESPLIT>-1.2442578077316284<CODESPLIT>-1.1287976503372192<CODESPLIT>-1.4206031560897827
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include "bits/stdc++.h" using namespace std ; #ifndef DEBUG #define dump(...) #endif #define all(x) x.begin(), x.end() #define rep(i, n) for (intmax_t i = 0, i##_limit = (n); i < i##_limit; ++i) #define reps(i, b, e) for (intmax_t i = (b), i##_limit = (e); i <= i##_limit; ++i) #define repr(i, b, e) for (intmax_t i = (b), i##_limit = (e); i >= i##_limit; --i) #define var(Type, ...) Type __VA_ARGS__; input(__VA_ARGS__) constexpr size_t operator "" _zu ( unsigned long long value ) { return value ; } ; constexpr intmax_t operator "" _jd ( unsigned long long value ) { return value ; } ; constexpr uintmax_t operator "" _ju ( unsigned long long value ) { return value ; } ; constexpr int INF = 0x3f3f3f3f ; constexpr intmax_t LINF = 0x3f3f3f3f3f3f3f3f _jd ; template < class T > using MaxHeap = priority_queue < T , vector < T > , less < T > > ; template < class T > using MinHeap = priority_queue < T , vector < T > , greater < T > > ; inline void input ( ) { } template < class Head , class . . . Tail > inline void input ( Head && head , Tail && . . . tail ) { cin > > head ; input ( forward < Tail > ( tail ) . . . ) ; } template < class T > inline void input ( vector < T > & vec ) { for ( auto & e : vec ) { cin > > e ; } } template < class T > inline void input ( vector < vector < T > > & mat ) { for ( auto & vec : mat ) { input ( vec ) ; } } inline void print ( ) { cout << "\n" ; } template < class Head , class . . . Tail > inline void print ( Head && head , Tail && . . . tail ) { cout << head ; if ( sizeof . . . ( tail ) ) cout << " " ; print ( forward < Tail > ( tail ) . . . ) ; } template < class T > inline ostream & operator << ( ostream & strm , const vector < T > & vec ) { static constexpr const char * delim [ ] = { " " , "" } ; for ( const auto & e : vec ) { strm << e << delim [ & e == & vec . back ( ) ] ; } return strm ; } template < class T > inline vector < T > make_v ( const T & initValue , size_t sz ) { return vector < T > ( sz , initValue ) ; } template < class T , class . . . Args > inline auto make_v ( const T & initValue , size_t sz , Args . . . args ) { return vector < decltype ( make_v < T > ( initValue , args . . . ) ) > ( sz , make_v < T > ( initValue , args . . . ) ) ; } template < class Func > class FixPoint : Func { public : explicit constexpr FixPoint ( Func && f ) noexcept : Func ( forward < Func > ( f ) ) { } template < class . . . Args > constexpr decltype ( auto ) operator ( ) ( Args && . . . args ) const { return Func :: operator ( ) ( * this , std :: forward < Args > ( args ) . . . ) ; } } ; template < class Func > static inline constexpr decltype ( auto ) makeFixPoint ( Func && f ) noexcept { return FixPoint < Func > { forward < Func > ( f ) } ; } template < class T > inline bool chmax ( T & a , const T & b ) noexcept { return b > a && ( a = b , true ) ; } template < class T > inline bool chmin ( T & a , const T & b ) noexcept { return b < a && ( a = b , true ) ; } template < class T > inline T diff ( const T & a , const T & b ) noexcept { return a < b ? b - a : a - b ; } template < class Weight > struct Edge { size_t from , to ; Weight weight ; Edge ( ) { } Edge ( size_t from , size_t to , Weight weight = 1 ) : from ( from ) , to ( to ) , weight ( weight ) { } bool operator < ( const Edge & rhs ) const { return weight < rhs . weight ; } bool operator > ( const Edge & rhs ) const { return weight > rhs . weight ; } operator size_t ( ) const { return to ; } } ; template < class Weight > class Graph : public vector < vector < Edge < Weight > > > { using graph = vector < vector < Edge < Weight > > > ; public : Graph ( ) { } Graph ( const size_t V ) : graph ( V ) { } void connect ( size_t from , size_t to , size_t weight = 1 ) { ( * this ) [ from ] . emplace_back ( from , to , weight ) ; } friend ostream & operator << ( ostream & strm , const Graph & G ) { for ( size_t v = 0 ; v < G . size ( ) ; ++ v ) { strm << '[' << setw ( 2 ) << v << ']' ; for ( const auto & e : G [ v ] ) { strm << ' ' << setw ( 2 ) << e . to ; } strm << '\n' ; } return strm ; } } ; template < class Weight > vector < Weight > dijkstra ( const Graph < Weight > & G , const vector < size_t > & startNodes ) { using P = pair < Weight , size_t > ; vector < Weight > dp ( G . size ( ) , numeric_limits < Weight > :: max ( ) ) ; priority_queue < P , vector < P > , greater < > > pq ; for ( const auto startNode : startNodes ) { dp [ startNode ] = 0 ; pq . emplace ( 0 , startNode ) ; } while ( ! pq . empty ( ) ) { const Weight nowCost = pq . top ( ) . first ; const size_t nowNode = pq . top ( ) . second ; pq . pop ( ) ; if ( dp [ nowNode ] < nowCost ) { continue ; } for ( const auto & e : G [ nowNode ] ) { const Weight newCost = dp [ nowNode ] + e . weight ; const size_t newNode = e . to ; if ( newCost < dp [ newNode ] ) { dp [ newNode ] = newCost ; pq . emplace ( newCost , newNode ) ; } } } return dp ; } int main ( ) { ios_base :: sync_with_stdio ( false ) ; cin . tie ( nullptr ) ; var ( size_t , V , E , src ) ; Graph < size_t > G ( V ) ; rep ( i , E ) { var ( size_t , from , to , cost ) ; G . connect ( from , to , cost ) ; } const auto dist = dijkstra ( G , { src } ) ; rep ( v , V ) { if ( dist [ v ] == SIZE_MAX ) { print ( "INF" ) ; } else { print ( dist [ v ] ) ; } } return 0 ; }<CODESPLIT>-0.8253803849220276<CODESPLIT>5.751662731170654<CODESPLIT>-1.2679715156555176<CODESPLIT>-1.2609628438949585<CODESPLIT>-1.150514006614685<CODESPLIT>-1.465779423713684
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include<iostream> #include<vector> using namespace std ; int main ( ) { int iv , ie , r ; cin > > iv > > ie > > r ; int d [ 100010 ] ; for ( int i = 0 ; i < iv ; i ++ ) { d [ i ] = 1000000010 ; } d [ r ] = 0 ; vector < pair < int , int > > w ( ie ) ; vector < int > cost ( ie ) ; for ( int i = 0 ; i < ie ; i ++ ) { int s0 , e0 , d0 ; cin > > s0 > > e0 > > d0 ; w [ i ] = make_pair ( s0 , e0 ) ; cost [ i ] = d0 ; } for ( int i = 0 ; i < iv - 1 ; i ++ ) { int k = 0 ; for ( int j = 0 ; j < ie ; j ++ ) { int s1 , e1 , d1 ; s1 = w [ j ] . first ; e1 = w [ j ] . second ; d1 = cost [ j ] ; if ( d [ e1 ] > d [ s1 ] + d1 ) k += 1 ; d [ e1 ] = min ( d [ e1 ] , d [ s1 ] + d1 ) ; } if ( k == 0 ) break ; } for ( int i = 0 ; i < iv ; i ++ ) { if ( d [ i ] == 1000000010 ) { cout << "INF" << endl ; } else { cout << d [ i ] << endl ; } } }<CODESPLIT>-0.7990943789482117<CODESPLIT>5.756757736206055<CODESPLIT>-1.2677873373031616<CODESPLIT>-1.2688623666763306<CODESPLIT>-1.149953842163086<CODESPLIT>-1.4299755096435547
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <cstdio> #include <cctype> #include <utility> #include <vector> #include <climits> #include <queue> using namespace std ; const auto gcu = getchar_unlocked ; const auto pcu = putchar_unlocked ; #define _T template <typename T> #define _HT template <typename H, typename... T> #define _il inline #define _sc _il bool scan _T T in ( int c ) { T n = 0 ; int m = 1 ; while ( isspace ( c ) ) { c = gcu ( ) ; } if ( c == '-' ) m = - 1 , c = gcu ( ) ; do { n = 10 * n + ( c - '0' ) , c = gcu ( ) ; } while ( c >= '0' && c <= '9' ) ; return m * n ; } _il int in ( ) { return in < int > ( gcu ( ) ) ; } _T T scan ( T & n ) { int c = gcu ( ) ; return c == EOF ? false : ( n = in < T > ( c ) , true ) ; } _sc ( char & c ) { c = gcu ( ) ; gcu ( ) ; return c ! = EOF ; } #ifdef _GLIBCXX_STRING _sc ( string & s ) { int c ; s = "" ; for ( ; ; ) { c = gcu ( ) ; if ( c == '\n' || c == ' ' ) return true ; else if ( c == EOF ) return false ; s += c ; } } #endif _HT _sc ( H & h , T && . . . t ) { return scan ( h ) && scan ( t . . . ) ; } #define _ot _il void out #define _ol _il void outl _ot ( bool b ) { pcu ( '0' + b ) ; } _ot ( const char * s ) { while ( * s ) pcu ( * s ++ ) ; } _ot ( char c ) { pcu ( c ) ; } #ifdef _GLIBCXX_STRING _ot ( string s ) { for ( char c : s ) pcu ( c ) ; } #endif _T _ot ( T n ) { static char b [ 20 ] ; char * p = b , m = n < 0 ? pcu ( '-' ) , - 1 : 1 ; if ( ! n ) * p ++ = '0' ; else while ( n ) * p ++ = n % 10 * m + '0' , n / = 10 ; while ( p ! = b ) pcu ( * -- p ) ; } _ol ( ) { out ( '\n' ) ; } #ifdef _GLIBCXX_VECTOR _T _ot ( vector < T > & v ) { for ( T & x : v ) out ( & x == & v [ 0 ] ? "" : " " ) , out ( x ) ; outl ( ) ; } #endif _HT _ot ( H && h , T && . . . t ) { out ( h ) ; out ( move ( t ) . . . ) ; } template < typename . . . T > _ol ( T && . . . t ) { out ( move ( t ) . . . ) ; outl ( ) ; } struct graph { struct node { int n , w ; bool operator < ( const node a ) const { return w > a . w ; } } ; using V = vector < node > ; vector < V > nodes ; V w ; graph ( int v ) : nodes ( v ) , w ( v , { 0 , INT_MAX } ) { } void dks ( int r ) { w [ r ] . w = 0 ; priority_queue < node > q ; q . push ( { r , 0 } ) ; while ( ! q . empty ( ) ) { node n = q . top ( ) ; q . pop ( ) ; for ( node & x : nodes [ n . n ] ) { if ( ! w [ n . n ] . n && w [ x . n ] . w > n . w + x . w ) q . push ( { x . n , w [ x . n ] . w = n . w + x . w } ) ; } w [ n . n ] . n |= 1 ; } } } ; int main ( ) { graph g ( in ( ) ) ; int E = in ( ) , r = in ( ) ; for ( int i = E ; i ; i -- ) { int s = in ( ) ; g . nodes [ s ] . push_back ( { in ( ) , in ( ) } ) ; } g . dks ( r ) ; for ( auto & n : g . w ) if ( n . w == INT_MAX ) outl ( "INF" ) ; else outl ( n . w ) ; }<CODESPLIT>-0.9303663372993469<CODESPLIT>5.744322299957275<CODESPLIT>-1.2413806915283203<CODESPLIT>-1.2279382944107056<CODESPLIT>-1.1411247253417969<CODESPLIT>-1.4156664609909058
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include <iostream> #include <string> #include <vector> #include <sstream> #include <map> #include <set> #include <queue> #include <algorithm> #include <cmath> #include <cstdio> #include <cstdlib> #include <cstring> using namespace std ; using ll = long long ; #define all(c) (c).begin(), (c).end() #define rep(i,n) for(int i=0;i<(int)(n);i++) #define pb(e) push_back(e) #define mp(a, b) make_pair(a, b) #define fr first #define sc second const ll INF = 1e9 ; const ll MOD = 1e9+7 ; int dx [ 4 ] = { 1 , 0 , - 1 , 0 } ; int dy [ 4 ] = { 0 , 1 , 0 , - 1 } ; using Weight = ll ; struct Edge { int to ; Weight cost ; } ; struct Node { int v ; Node ( int v ) : v ( v ) { } bool operator < ( const Node & rhs ) const { return tie ( v ) < tie ( rhs . v ) ; } } ; struct State : public Node { Weight cost ; State ( Node node , int cost ) : Node ( node ) , cost ( cost ) { } bool operator < ( const State & rhs ) const { return cost > rhs . cost ; } } ; map < Node , Weight > dijkstra ( const vector < vector < Edge > > & adj , const Node & source ) { map < Node , Weight > dist ; priority_queue < State > que ; que . push ( State ( source , 0 ) ) ; dist [ source ] = 0 ; while ( que . size ( ) ) { State s = que . top ( ) ; que . pop ( ) ; Node cur { s . v } ; for ( auto u : adj [ s . v ] ) { Node next { u . to } ; if ( ! dist . count ( next ) || dist [ next ] > dist [ cur ] + u . cost ) { dist [ next ] = dist [ cur ] + u . cost ; que . push ( State ( next , dist [ next ] ) ) ; } } } return dist ; } int main ( ) { int V , E , r ; cin > > V > > E > > r ; vector < vector < Edge > > adj ; adj . resize ( V ) ; rep ( i , E ) { int s , t , d ; cin > > s > > t > > d ; adj [ s ] . push_back ( Edge { t , d } ) ; } auto dist = dijkstra ( adj , r ) ; rep ( i , V ) { Node node { i } ; if ( dist . count ( node ) ) cout << dist [ node ] << endl ; else cout << "INF" << endl ; } return 0 ; }<CODESPLIT>-1.0525113344192505<CODESPLIT>5.743895053863525<CODESPLIT>-1.2288463115692139<CODESPLIT>-1.228385329246521<CODESPLIT>-1.1364082098007202<CODESPLIT>-1.430716872215271
1<CODESPLIT>All Pair Source Shortest Path<CODESPLIT>#include<iostream> #include<vector> #include<algorithm> #include<stdio.h> #include<time.h> #include<set> #include<map> #include<utility> #include<queue> #include<limits> using namespace std ; class Edge { public : int from ; int to ; int flow ; Edge ( int f , int t , int d ) { from = f ; to = t ; flow = d ; } } ; class Shortest_path_result { public : int sum_of_cost ; vector < int > path ; vector < int > distance ; vector < int > predecessor ; Shortest_path_result ( ) { } } ; class Graph { public : int INF ; int n ; vector < set < int > > vertices_list ; vector < map < int , int > > cost_list ; vector < map < int , int > > capacity_list ; vector < int > potential_list ; Graph ( ) { } Graph ( int n ) { INF = 1e9 ; this -> n = n ; vertices_list . insert ( vertices_list . begin ( ) , n , set < int > ( ) ) ; cost_list . insert ( cost_list . begin ( ) , n , map < int , int > ( ) ) ; capacity_list . insert ( capacity_list . begin ( ) , n , map < int , int > ( ) ) ; potential_list = vector < int > ( n , 0 ) ; } void insert_edge ( int b , int e , int cost , int capacity ) { vertices_list [ b ] . insert ( e ) ; cost_list [ b ] [ e ] = cost ; capacity_list [ b ] [ e ] = capacity ; } void delete_edge ( int b , int e ) { vertices_list [ b ] . erase ( e ) ; cost_list [ b ] . erase ( e ) ; capacity_list [ b ] . erase ( e ) ; } int degree_of_vertex ( int a ) { return vertices_list [ a ] . size ( ) ; } bool edge_search ( int a , int b ) { return vertices_list [ a ] . find ( b ) ! = vertices_list [ a ] . end ( ) ; } bool path_search ( int a , int b , set < int > visited = set < int > ( ) ) { visited . insert ( a ) ; set < int > :: iterator itr ; for ( itr = vertices_list [ a ] . begin ( ) ; itr ! = vertices_list [ a ] . end ( ) ; itr ++ ) { if ( ( * itr ) == b ) { return true ; } if ( visited . find ( * itr ) == visited . end ( ) ) { if ( path_search ( * itr , b , visited ) ) { return true ; } } } return false ; } Shortest_path_result solve_dijkstra ( int start , int goal ) { set < int > visited = set < int > ( ) ; vector < int > distance = vector < int > ( n , INF ) ; vector < int > predecessor = vector < int > ( n ) ; priority_queue < pair < int , int > , vector < pair < int , int > > , greater < pair < int , int > > > pq ; pq . push ( pair < int , int > ( 0 , start ) ) ; while ( ! pq . empty ( ) ) { pair < int , int > p = pq . top ( ) ; pq . pop ( ) ; int nv = p . second ; if ( distance [ nv ] < p . first ) { continue ; } distance [ nv ] = p . first ; for ( set < int > :: iterator itr = vertices_list [ nv ] . begin ( ) ; itr ! = vertices_list [ nv ] . end ( ) ; itr ++ ) { int next = ( * itr ) ; if ( distance [ next ] > distance [ nv ] + cost_list [ nv ] [ next ] ) { distance [ next ] = distance [ nv ] + cost_list [ nv ] [ next ] ; predecessor [ next ] = nv ; pq . push ( pair < int , int > ( distance [ next ] , next ) ) ; } } } Shortest_path_result result ; if ( distance [ goal ] == INF ) { } else { result . path = vector < int > ( ) ; result . path . push_back ( goal ) ; if ( start ! = goal ) { while ( true ) { int now = result . path . back ( ) ; int pre = predecessor [ now ] ; result . path . push_back ( pre ) ; if ( pre == start ) { reverse ( result . path . begin ( ) , result . path . end ( ) ) ; break ; } } } } result . path = vector < int > ( ) ; result . sum_of_cost = distance [ goal ] ; result . distance = distance ; result . predecessor = predecessor ; return result ; } pair < int , vector < Edge > > solve_mincostflow ( int s , int t , int flow_size ) { vector < map < int , int > > flow_list = vector < map < int , int > > ( n ) ; vector < map < int , int > > origin_cost = cost_list ; bool feasible_flag = true ; int sum_flow_cost = 0 ; while ( flow_size > 0 ) { Shortest_path_result res ; vector < int > path ; int min_capa = INF ; res = solve_dijkstra ( s , t ) ; cout << res . sum_of_cost << endl ; if ( res . sum_of_cost == INF ) { feasible_flag = false ; break ; } path = res . path ; for ( int i = 0 ; i < n ; i ++ ) { potential_list [ i ] = potential_list [ i ] - res . distance [ i ] ; } vector < int > :: iterator itr = path . begin ( ) ; itr ++ ; for ( ; itr ! = path . end ( ) ; itr ++ ) { if ( min_capa > capacity_list [ * ( itr - 1 ) ] [ * itr ] ) { min_capa = capacity_list [ * ( itr - 1 ) ] [ * itr ] ; } } if ( min_capa > flow_size ) { min_capa = flow_size ; } itr = path . begin ( ) ; itr ++ ; for ( ; itr ! = path . end ( ) ; itr ++ ) { if ( flow_list [ * ( itr - 1 ) ] . find ( * itr ) == flow_list [ * ( itr - 1 ) ] . end ( ) ) { flow_list [ * ( itr - 1 ) ] [ * itr ] = min_capa ; } else { flow_list [ * ( itr - 1 ) ] [ * itr ] += min_capa ; } } flow_size = flow_size - min_capa ; itr = path . begin ( ) ; for ( itr ++ ; itr ! = path . end ( ) ; itr ++ ) { int capa , cost ; int from , to ; from = * ( itr - 1 ) ; to = * itr ; capa = capacity_list [ from ] [ to ] ; cost = cost_list [ from ] [ to ] ; delete_edge ( from , to ) ; if ( capa - min_capa > 0 ) { insert_edge ( from , to , cost , capa - min_capa ) ; } insert_edge ( to , from , - 1 * cost , min_capa ) ; } for ( int b = 0 ; b > n ; b ++ ) { map < int , int > :: iterator itr ; for ( itr = cost_list [ b ] . begin ( ) ; itr ! = cost_list [ b ] . end ( ) ; itr ++ ) { ( * itr ) . second = ( * itr ) . second - potential_list [ itr -> first ] + potential_list [ b ] ; } } } for ( int i = 0 ; i < n ; i ++ ) { map < int , int > :: iterator itr ; for ( itr = flow_list [ i ] . begin ( ) ; itr ! = flow_list [ i ] . end ( ) ; itr ++ ) { sum_flow_cost += origin_cost [ i ] [ itr -> first ] * itr -> second ; } } if ( ! feasible_flag ) { cout << "-1" << endl ; } else { cout << sum_flow_cost << endl ; } return pair < int , vector < Edge > > ( ) ; } void print ( void ) { int i = 0 ; vector < set < int > > :: iterator itr ; set < int > :: iterator itr_c ; for ( itr = vertices_list . begin ( ) ; itr ! = vertices_list . end ( ) ; itr ++ ) { cout << i << ":" ; for ( itr_c = ( * itr ) . begin ( ) ; itr_c ! = ( * itr ) . end ( ) ; itr_c ++ ) { cout << * itr_c << "(" << capacity_list [ i ] [ * itr_c ] << ")" << "," ; } i ++ ; cout << endl ; } } } ; int main ( ) { const int inf = 1e9 ; int v , e , flow ; Graph g ; Shortest_path_result res ; int r ; cin > > v > > e > > r ; g = Graph ( v ) ; int from , to , cost , cap ; for ( int i = 0 ; i < e ; i ++ ) { cin > > from > > to > > cost ; g . insert_edge ( from , to , cost , 0 ) ; } res = g . solve_dijkstra ( r , v - 1 ) ; for ( int i = 0 ; i < v ; i ++ ) { if ( res . distance [ i ] == inf ) { cout << "INF" << endl ; } else { cout << res . distance [ i ] << endl ; } } return 0 ; }<CODESPLIT>-1.0537631511688232<CODESPLIT>5.731997013092041<CODESPLIT>-1.2246818542480469<CODESPLIT>-1.2407143115997314<CODESPLIT>-1.1321851015090942<CODESPLIT>-1.3759721517562866
