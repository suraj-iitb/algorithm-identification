3<CODESPLIT>Counting Sort<CODESPLIT>#include<stdio.h> #include<stdlib.h> #define MAX 2000001 #define VMAX 10000 void CountingSort ( int * , int * , int , int ) ; int main ( ) { int n , * a , * b , i , max ; scanf ( "%d" , & n ) ; if ( n < 1 || 2000000 < n ) exit ( 0 ) ; a = ( int * ) malloc ( ( n + 1 ) * sizeof ( int ) ) ; b = ( int * ) malloc ( ( n + 1 ) * sizeof ( int ) ) ; scanf ( "%d" , & a [ 0 ] ) ; max = a [ 0 ] ; for ( i = 1 ; i < n ; i ++ ) { scanf ( "%d" , & a [ i ] ) ; if ( a [ i ] < 0 || 10000 < a [ i ] ) exit ( 0 ) ; if ( max < a [ i ] ) max = a [ i ] ; } CountingSort ( & a [ 0 ] , & b [ 0 ] , max , n ) ; printf ( "%d" , b [ 1 ] ) ; for ( i = 2 ; i <= n ; i ++ ) { printf ( " %d" , b [ i ] ) ; } printf ( "\n" ) ; return 0 ; } void CountingSort ( int * a , int * b , int k , int n ) { int i , * c , j ; c = ( int * ) malloc ( ( k + 1 ) * sizeof ( int ) ) ; for ( i = 0 ; i <= k ; i ++ ) { c [ i ] = 0 ; } for ( j = 0 ; j < n ; j ++ ) { c [ a [ j ] ] ++ ; } for ( i = 1 ; i <= k ; i ++ ) { c [ i ] = c [ i ] + c [ i - 1 ] ; } for ( j = n - 1 ; 0 <= j ; j -- ) { b [ c [ a [ j ] ] ] = a [ j ] ; c [ a [ j ] ] -- ; } } 
3<CODESPLIT>Counting Sort<CODESPLIT>#include <stdio.h> #include <stdlib.h> #define MAX 2000001 #define VMAX 10000 int main ( ) { unsigned short * A , * B ; int C [ VMAX + 1 ] ; int n , i , j ; scanf ( "%d" , & n ) ; A = malloc ( sizeof ( short ) * n + 1 ) ; B = malloc ( sizeof ( short ) * n + 1 ) ; for ( i = 0 ; i <= VMAX ; i ++ ) C [ i ] = 0 ; for ( i = 0 ; i < n ; i ++ ) { scanf ( "%hu" , & A [ i + 1 ] ) ; C [ A [ i + 1 ] ] ++ ; } for ( i = 1 ; i <= VMAX ; i ++ ) C [ i ] = C [ i ] + C [ i - 1 ] ; for ( j = 1 ; j <= n ; j ++ ) { B [ C [ A [ j ] ] ] = A [ j ] ; C [ A [ j ] ] -- ; } for ( i = 1 ; i <= n ; i ++ ) { if ( i > 1 ) printf ( " " ) ; printf ( "%d" , B [ i ] ) ; } printf ( "\n" ) ; return 0 ; } 
3<CODESPLIT>Counting Sort<CODESPLIT>#include<stdio.h> #define N1 2000001 #define N2 2000001 #define M 10001 int array [ N1 ] , sort_array [ N2 ] , counting [ M ] ; int main ( ) { int i , n , k ; for ( i = 1 ; i < N2 ; i ++ ) sort_array [ i ] = 0 ; for ( i = 1 ; i < M ; i ++ ) counting [ i ] = 0 ; scanf ( "%d" , & n ) ; for ( i = 1 ; i <= n ; i ++ ) { scanf ( "%d" , & array [ i ] ) ; counting [ array [ i ] ] ++ ; } for ( i = 0 ; i < M ; i ++ ) { counting [ i + 1 ] += counting [ i ] ; } for ( i = n ; i >= 1 ; i -- ) { sort_array [ counting [ array [ i ] ] ] = array [ i ] ; counting [ array [ i ] ] -- ; } for ( i = 1 ; i <= n ; i ++ ) { if ( i ! = 1 ) printf ( " " ) ; printf ( "%d" , sort_array [ i ] ) ; } printf ( "\n" ) ; return 0 ; } 
3<CODESPLIT>Counting Sort<CODESPLIT>#include <stdio.h> #define N 2000001 #define K 10000 int A [ 2000001 ] ; int B [ 2000001 ] ; int C [ 10000 ] ; void CountingSort ( int , int ) ; int main ( ) { int n , i , j ; scanf ( "%d" , & n ) ; for ( i = 1 ; i < n + 1 ; i ++ ) scanf ( "%d" , & A [ i ] ) ; CountingSort ( K , n ) ; for ( i = 1 ; i < n ; i ++ ) printf ( "%d " , B [ i ] ) ; printf ( "%d\n" , B [ i ] ) ; return 0 ; } void CountingSort ( int k , int n ) { int i ; for ( i = 0 ; i < k ; i ++ ) C [ i ] = 0 ; for ( i = 1 ; i < n + 1 ; i ++ ) C [ A [ i ] ] ++ ; for ( i = 1 ; i < k ; i ++ ) C [ i ] += C [ i - 1 ] ; for ( i = n ; i > 0 ; i -- ) { B [ C [ A [ i ] ] ] = A [ i ] ; C [ A [ i ] ] -- ; } } 
3<CODESPLIT>Counting Sort<CODESPLIT>#include <stdio.h> #include <stdlib.h> #define MAX 2000001 #define VMAX 10000 int main ( ) { unsigned short * A , * B ; int C [ VMAX + 1 ] ; int n , i , j ; int k = VMAX ; scanf ( "%d" , & n ) ; A = malloc ( sizeof ( short ) * n + 1 ) ; B = malloc ( sizeof ( short ) * n + 1 ) ; for ( i = 0 ; i <= k ; i ++ ) { C [ i ] = 0 ; } for ( j = 1 ; j <= n ; j ++ ) { scanf ( "%d" , & A [ j ] ) ; C [ A [ j ] ] ++ ; } for ( i = 1 ; i <= k ; i ++ ) { C [ i ] = C [ i ] + C [ i - 1 ] ; } for ( j = n ; j >= 1 ; j -- ) { B [ C [ A [ j ] ] ] = A [ j ] ; C [ A [ j ] ] -- ; } for ( i = 1 ; i <= n ; i ++ ) { printf ( "%d" , B [ i ] ) ; if ( i ! = n ) printf ( " " ) ; } printf ( "\n" ) ; return 0 ; } 
3<CODESPLIT>Counting Sort<CODESPLIT>#include <stdio.h> #define N 10000 int arrayA [ 2000001 ] , arrayC [ N + 1 ] , arrayB [ 2000001 ] ; int main ( ) { int k , i , j , max = 0 ; scanf ( "%d" , & k ) ; for ( i = 0 ; i < k ; i ++ ) { scanf ( "%d" , & arrayA [ i ] ) ; if ( max < arrayA [ i ] ) max = arrayA [ i ] ; } for ( i = 0 ; i <= max ; i ++ ) arrayC [ i ] = 0 ; for ( j = 0 ; j < k ; j ++ ) arrayC [ arrayA [ j ] ] ++ ; for ( i = 1 ; i <= max ; i ++ ) arrayC [ i ] = arrayC [ i ] + arrayC [ i - 1 ] ; for ( j = k - 1 ; j >= 0 ; j -- ) { arrayB [ arrayC [ arrayA [ j ] ] ] = arrayA [ j ] ; arrayC [ arrayA [ j ] ] -- ; } for ( i = 1 ; i < k ; i ++ ) { printf ( "%d " , arrayB [ i ] ) ; } printf ( "%d" , arrayB [ k ] ) ; printf ( "\n" ) ; return 0 ; } 
3<CODESPLIT>Counting Sort<CODESPLIT>#include <stdio.h> #include <stdlib.h> void countingsort ( int * , int * , int ) ; int n ; int main ( ) { int i , j ; int * A , * B , max = 0 ; A = ( int * ) malloc ( 2000000 * sizeof ( int ) ) ; B = ( int * ) malloc ( 2000000 * sizeof ( int ) ) ; scanf ( "%d" , & n ) ; if ( n < 1 || n > 2000000 ) exit ( 1 ) ; for ( i = 1 ; i < n + 1 ; i ++ ) { scanf ( "%d" , & A [ i ] ) ; if ( A [ i ] < 0 || A [ i ] > 10000 ) exit ( 2 ) ; if ( max < A [ i ] ) max = A [ i ] ; } countingsort ( A , B , max ) ; for ( j = 1 ; j < n + 1 ; j ++ ) { if ( j < n ) printf ( "%d " , B [ j ] ) ; else printf ( "%d\n" , B [ j ] ) ; } free ( A ) ; free ( B ) ; return 0 ; } void countingsort ( int A [ ] , int B [ ] , int k ) { int i , j , C [ k ] ; for ( i = 0 ; i <= k ; i ++ ) C [ i ] = 0 ; for ( j = 1 ; j < n + 1 ; j ++ ) C [ A [ j ] ] ++ ; for ( i = 1 ; i <= k ; i ++ ) C [ i ] = C [ i ] + C [ i - 1 ] ; for ( j = n ; j >= 1 ; j -- ) { B [ C [ A [ j ] ] ] = A [ j ] ; C [ A [ j ] ] -- ; } } 
3<CODESPLIT>Counting Sort<CODESPLIT>#include<stdio.h> #define MAX 2000000 int B [ MAX ] , A [ MAX ] , n ; int main ( ) { int j , i ; int max = 0 , kei = 0 ; scanf ( "%d" , & n ) ; for ( i = 0 ; i < n ; i ++ ) { scanf ( "%d" , & A [ i ] ) ; if ( max < A [ i ] ) max = A [ i ] ; } for ( i = 0 ; i <= max ; i ++ ) { B [ i ] = 0 ; } for ( i = 0 ; i < n ; i ++ ) { B [ A [ i ] ] ++ ; } for ( i = 0 ; i <= max ; i ++ ) { if ( B [ i ] > 0 ) { for ( j = 1 ; j <= B [ i ] ; j ++ ) { if ( kei ! = n - 1 ) printf ( "%d " , i ) ; else printf ( "%d\n" , i ) ; kei ++ ; } } } return 0 ; } 
3<CODESPLIT>Counting Sort<CODESPLIT>#include <stdio.h> #include <stdlib.h> #define MAX 2000000 #define VMAX 10000 int main ( ) { int * A , * B ; int C [ VMAX + 1 ] ; int n , i , j ; scanf ( "%d" , & n ) ; A = ( int * ) malloc ( sizeof ( int ) * n + 1 ) ; B = ( int * ) malloc ( sizeof ( int ) * n + 1 ) ; for ( i = 0 ; i < n ; i ++ ) { scanf ( "%d" , & A [ i + 1 ] ) ; } for ( i = 0 ; i <= VMAX ; i ++ ) { C [ i ] = 0 ; } for ( j = 1 ; j <= n ; j ++ ) { C [ A [ j ] ] ++ ; } for ( i = 1 ; i <= VMAX ; i ++ ) { C [ i ] = C [ i ] + C [ i - 1 ] ; } for ( j = 1 ; j <= n ; j ++ ) { B [ C [ A [ j ] ] ] = A [ j ] ; C [ A [ j ] ] -- ; } for ( i = 1 ; i <= n ; i ++ ) { if ( i > 1 ) printf ( " " ) ; printf ( "%d" , B [ i ] ) ; } printf ( "\n" ) ; return 0 ; } 
3<CODESPLIT>Counting Sort<CODESPLIT>#include <stdio.h> #define MAX 20000500 #define K 10000 void CountingSort ( int ) ; int A [ MAX ] , B [ MAX ] , C [ MAX ] , n ; int main ( ) { int i ; scanf ( "%d" , & n ) ; for ( i = 0 ; i < n ; i ++ ) { scanf ( "%d" , & A [ i ] ) ; } CountingSort ( K ) ; for ( i = 1 ; i <= n ; i ++ ) { printf ( "%d" , B [ i ] ) ; if ( i == n ) printf ( "\n" ) ; else printf ( " " ) ; } return 0 ; } void CountingSort ( int k ) { int i , j ; for ( i = 0 ; i < k ; i ++ ) { C [ i ] = 0 ; } for ( j = 0 ; j < n ; j ++ ) { C [ A [ j ] ] = C [ A [ j ] ] + 1 ; } for ( i = 1 ; i < k ; i ++ ) { C [ i ] = C [ i ] + C [ i - 1 ] ; } for ( j = n - 1 ; j >= 0 ; j -- ) { B [ C [ A [ j ] ] ] = A [ j ] ; C [ A [ j ] ] = C [ A [ j ] ] - 1 ; } } 
3<CODESPLIT>Counting Sort<CODESPLIT>#include<stdio.h> #include<stdlib.h> #define k 10001 void CountingSort ( int * , int * , int ) ; main ( ) { int n , i ; int * A , * B ; scanf ( "%d" , & n ) ; A = ( int * ) malloc ( sizeof ( int ) * n ) ; if ( A == NULL ) exit ( 1 ) ; B = ( int * ) malloc ( sizeof ( int ) * n ) ; if ( B == NULL ) exit ( 2 ) ; for ( i = 0 ; i < n ; i ++ ) { scanf ( "%d" , & A [ i ] ) ; } CountingSort ( A , B , n ) ; for ( i = 0 ; i < n ; i ++ ) { if ( i == 0 ) printf ( "%d" , B [ i ] ) ; else printf ( " %d" , B [ i ] ) ; } printf ( "\n" ) ; free ( A ) ; free ( B ) ; return 0 ; } void CountingSort ( int * A , int * B , int n ) { int i ; int C [ k ] ; for ( i = 0 ; i < k ; i ++ ) { C [ i ] = 0 ; } for ( i = 0 ; i < n ; i ++ ) { C [ A [ i ] ] ++ ; } for ( i = 1 ; i < k ; i ++ ) { C [ i ] = C [ i ] + C [ i - 1 ] ; } for ( i = n ; i >= 1 ; i -- ) { B [ C [ A [ i - 1 ] ] - 1 ] = A [ i - 1 ] ; C [ A [ i - 1 ] ] -- ; } } 
3<CODESPLIT>Counting Sort<CODESPLIT>#include<stdio.h> #include<stdlib.h> #define MAXDATA 10001 int main ( ) { int i , datanum , temp ; int * a , * b ; int c [ MAXDATA ] ; scanf ( "%d" , & datanum ) ; a = ( int * ) malloc ( sizeof ( int ) * ( datanum + 1 ) ) ; b = ( int * ) malloc ( sizeof ( int ) * ( datanum + 1 ) ) ; for ( i = 0 ; i < MAXDATA ; i ++ ) { c [ i ] = 0 ; } for ( i = 0 ; i < datanum ; i ++ ) { scanf ( "%d" , & a [ i + 1 ] ) ; c [ a [ i + 1 ] ] ++ ; } for ( i = 1 ; i <= MAXDATA ; i ++ ) { c [ i ] = c [ i ] + c [ i - 1 ] ; } for ( i = datanum ; i >= 1 ; i -- ) { b [ c [ a [ i ] ] ] = a [ i ] ; c [ a [ i ] ] -- ; } for ( i = 1 ; i <= datanum ; i ++ ) { if ( i ! = 1 ) printf ( " " ) ; printf ( "%d" , b [ i ] ) ; } printf ( "\n" ) ; return 0 ; } 
3<CODESPLIT>Counting Sort<CODESPLIT>#include <stdio.h> #define PutChar(c) ; *p = (char)(c); ++p; #define MAX_N (2000001) #define MAX_Ai (10001) #define STR_SIZE (10000010) int getNum ( void ) ; void putNum ( int n ) ; void CountingSort ( int A [ ] , int B [ ] , int k , int len ) ; int A [ MAX_N ] ; int B [ MAX_N ] ; char str [ STR_SIZE ] ; char * p = str ; int main ( void ) { register int i ; int n ; fread ( str , 1 , STR_SIZE , stdin ) ; n = getNum ( ) ; for ( i = 1 ; i <= n ; ++ i ) { A [ i ] = getNum ( ) ; } CountingSort ( A , B , MAX_Ai , n ) ; p = str ; -- n ; for ( i = 1 ; i <= n ; ++ i ) { putNum ( B [ i ] ) ; PutChar ( ' ' ) ; } putNum ( B [ i ] ) ; PutChar ( '\0' ) ; puts ( str ) ; return 0 ; } int getNum ( void ) { int n = 0 ; while ( ( * p >= '0' ) && ( * p <= '9' ) ) { n = n * 10 + ( int ) ( * p - '0' ) ; ++ p ; } ++ p ; return n ; } void putNum ( int n ) { int d ; if ( n < 10 ) { PutChar ( '0' + n ) ; return ; } d = n / 10 ; if ( d ) putNum ( d ) ; PutChar ( '0' + ( n - ( d * 10 ) ) ) ; } void CountingSort ( int A [ ] , int B [ ] , int k , int len ) { int C [ MAX_Ai ] = { 0 } ; int i , j ; for ( j = 1 ; j <= len ; ++ j ) { ++ C [ A [ j ] ] ; } for ( i = 1 ; i <= k ; ++ i ) { C [ i ] += C [ i - 1 ] ; } for ( j = len ; j > 0 ; -- j ) { B [ C [ A [ j ] ] ] = A [ j ] ; -- C [ A [ j ] ] ; } } 
4<CODESPLIT>Merge Sort<CODESPLIT>#include <stdio.h> #include <stdlib.h> #include <memory.h> void put_uint ( int n ) { if ( ! n ) { putchar_unlocked ( '0' ) ; return ; } char buf [ 11 ] ; int i = 0 ; while ( n ) buf [ i ++ ] = ( char ) ( n % 10 + '0' ) , n / = 10 ; while ( i -- ) putchar_unlocked ( buf [ i ] ) ; } int get_uint ( ) { int n = 0 ; int c = getchar_unlocked ( ) ; if ( c < 48 || 57 < c ) return c ; while ( 47 < c && c < 58 ) { n = 10 * n + ( c & 0xf ) ; c = getchar_unlocked ( ) ; } return n ; } int cnt ; void merge ( int * first , int * mid , int * last ) { const int N1 = ( int ) ( mid - first ) ; const int N2 = ( int ) ( last - mid ) ; int * left = malloc ( sizeof ( int ) * ( N1 + 1 ) ) ; int * right = malloc ( sizeof ( int ) * ( N2 + 1 ) ) ; memcpy ( left , first , sizeof ( int ) * ( N1 + 1 ) ) ; memcpy ( right , mid , sizeof ( int ) * ( N2 + 1 ) ) ; left [ N1 ] = right [ N2 ] = 1000000000 ; for ( int * it = first , i = 0 , j = 0 ; it ! = last ; ++ it ) { * it = left [ i ] <= right [ j ] ? left [ i ++ ] : right [ j ++ ] ; } free ( left ) ; free ( right ) ; } void merge_sort ( int * first , int * last ) { const int N = ( int ) ( last - first ) ; if ( N < 2 ) return ; int * mid = first + N / 2 ; merge_sort ( first , mid ) ; merge_sort ( mid , last ) ; merge ( first , mid , last ) ; cnt += N ; } int main ( int argc , char ** argv ) { int n = get_uint ( ) ; int s [ 500001 ] ; for ( int i = 0 ; i < n ; ++ i ) s [ i ] = get_uint ( ) ; merge_sort ( s , s + n ) ; for ( int i = 0 ; i < n - 1 ; ++ i ) put_uint ( s [ i ] ) , putchar_unlocked ( ' ' ) ; put_uint ( s [ n - 1 ] ) , putchar_unlocked ( '\n' ) ; put_uint ( cnt ) , putchar_unlocked ( '\n' ) ; return 0 ; } 
4<CODESPLIT>Merge Sort<CODESPLIT>#include <stdio.h> #include <stdlib.h> #define INFTY 1000000000 #define SIZE 500000 int count = 0 ; void merge ( int A [ ] , int left , int mid , int right ) { int i , j , k ; int n1 = mid - left ; int n2 = right - mid ; int * L = malloc ( sizeof ( int ) * ( n1 + 1 ) ) ; int * R = malloc ( sizeof ( int ) * ( n2 + 1 ) ) ; for ( i = 0 ; i <= n1 - 1 ; i ++ ) { L [ i ] = A [ left + i ] ; } for ( i = 0 ; i <= n2 - 1 ; i ++ ) { R [ i ] = A [ mid + i ] ; } L [ n1 ] = INFTY ; R [ n2 ] = INFTY ; i = 0 ; j = 0 ; for ( k = left ; k < right ; k ++ ) { count ++ ; if ( L [ i ] <= R [ j ] ) { A [ k ] = L [ i ] ; i = i + 1 ; } else { A [ k ] = R [ j ] ; j = j + 1 ; } } free ( L ) ; free ( R ) ; } void mergeSort ( int A [ ] , int left , int right ) { if ( left + 1 < right ) { int mid = ( left + right ) / 2 ; mergeSort ( A , left , mid ) ; mergeSort ( A , mid , right ) ; merge ( A , left , mid , right ) ; } } int main ( ) { int i , x ; int a [ SIZE ] ; scanf ( "%d" , & x ) ; for ( i = 0 ; i < x ; i ++ ) { scanf ( "%d" , & a [ i ] ) ; } mergeSort ( a , 0 , x ) ; for ( i = 0 ; i < x - 1 ; i ++ ) { printf ( "%d " , a [ i ] ) ; } printf ( "%d\n" , a [ x - 1 ] ) ; printf ( "%d\n" , count ) ; return 0 ; } 
4<CODESPLIT>Merge Sort<CODESPLIT>#include <stdio.h> #include <stdlib.h> #define INF 1000000001 void merge ( int * , int , int , int ) ; void mergeSort ( int * , int , int ) ; int cnt = 0 ; int main ( ) { int i , n , s [ 500000 ] ; scanf ( "%d" , & n ) ; for ( i = 0 ; i < n ; i ++ ) scanf ( "%d" , & s [ i ] ) ; mergeSort ( s , 0 , n ) ; for ( i = 0 ; i < n ; i ++ ) { if ( i ) printf ( " " ) ; printf ( "%d" , s [ i ] ) ; } printf ( "\n%d\n" , cnt ) ; return 0 ; } void mergeSort ( int * A , int left , int right ) { int mid ; if ( left + 1 < right ) { mid = ( left + right ) / 2 ; mergeSort ( A , left , mid ) ; mergeSort ( A , mid , right ) ; merge ( A , left , mid , right ) ; } } void merge ( int * A , int left , int mid , int right ) { int i , j , k , n1 , n2 , l [ 500000 ] , r [ 500000 ] ; n1 = mid - left ; n2 = right - mid ; for ( i = 0 ; i < n1 ; i ++ ) l [ i ] = A [ left + i ] ; for ( i = 0 ; i < n2 ; i ++ ) r [ i ] = A [ mid + i ] ; l [ n1 ] = INF ; r [ n2 ] = INF ; i = 0 ; j = 0 ; for ( k = left ; k < right ; k ++ ) { cnt ++ ; if ( l [ i ] <= r [ j ] ) { A [ k ] = l [ i ] ; i ++ ; } else { A [ k ] = r [ j ] ; j ++ ; } } } 
4<CODESPLIT>Merge Sort<CODESPLIT>#include <stdio.h> #define MAX 500001 #define SENTINEL 1000000001 void merge_sort ( int [ ] , int , int ) ; void merge ( int [ ] , int , int , int ) ; int count = 0 ; int main ( ) { int n , S [ MAX ] , i ; scanf ( "%d" , & n ) ; for ( i = 0 ; i < n ; i ++ ) { scanf ( "%d" , & S [ i ] ) ; } merge_sort ( S , 0 , n ) ; for ( i = 0 ; i < n - 1 ; i ++ ) { printf ( "%d " , S [ i ] ) ; } printf ( "%d\n" , S [ n - 1 ] ) ; printf ( "%d\n" , count ) ; return 0 ; } void merge_sort ( int s [ ] , int left , int right ) { if ( left + 1 < right ) { int mid = ( left + right ) / 2 ; merge_sort ( s , left , mid ) ; merge_sort ( s , mid , right ) ; merge ( s , left , mid , right ) ; } } void merge ( int s [ ] , int left , int mid , int right ) { int i , k ; int n1 = mid - left + 1 ; int n2 = right - mid + 1 ; int L [ n1 ] , R [ n2 ] ; for ( i = 0 ; i < ( n1 - 1 ) ; i ++ ) { L [ i ] = s [ left + i ] ; } for ( i = 0 ; i < ( n2 - 1 ) ; i ++ ) { R [ i ] = s [ mid + i ] ; } L [ n1 - 1 ] = SENTINEL ; R [ n2 - 1 ] = SENTINEL ; i = 0 ; int j = 0 ; for ( k = left ; k < right ; k ++ ) { if ( L [ i ] <= R [ j ] ) { s [ k ] = L [ i ] ; i ++ ; } else { s [ k ] = R [ j ] ; j ++ ; } count ++ ; } } 
4<CODESPLIT>Merge Sort<CODESPLIT>#include <stdio.h> #define Max 500000 #define INFTY 2000000000 int L [ Max / 2+2 ] ; int R [ Max / 2+2 ] ; int count = 0 ; void mergeA ( int A [ ] , int left , int mid , int right ) { int n1 = mid - left ; int n2 = right - mid ; int i , j , k ; for ( i = 0 ; i < n1 ; i ++ ) L [ i ] = A [ left + i ] ; for ( i = 0 ; i < n2 ; i ++ ) R [ i ] = A [ mid + i ] ; L [ n1 ] = INFTY ; R [ n2 ] = INFTY ; i = 0 ; j = 0 ; for ( k = left ; k < right ; k ++ ) { if ( L [ i ] <= R [ j ] ) { A [ k ] = L [ i ] ; i ++ ; count ++ ; } else { A [ k ] = R [ j ] ; j ++ ; count ++ ; } } } void mergeSort ( int A [ ] , int left , int right ) { if ( left + 1 < right ) { int mid = ( left + right ) / 2 ; mergeSort ( A , left , mid ) ; mergeSort ( A , mid , right ) ; mergeA ( A , left , mid , right ) ; } } int main ( ) { int n ; int i ; int A [ Max ] ; scanf ( "%d" , & n ) ; for ( i = 0 ; i < n ; i ++ ) { scanf ( "%d" , & A [ i ] ) ; } mergeSort ( A , 0 , n ) ; for ( i = 0 ; i < n ; i ++ ) { printf ( "%d" , A [ i ] ) ; if ( i < n - 1 ) printf ( " " ) ; } printf ( "\n%d\n" , count ) ; return 0 ; } 
4<CODESPLIT>Merge Sort<CODESPLIT>#include <stdio.h> #define INFTY 1000000001 void merge ( int , int , int ) ; void mergeSort ( int , int ) ; int A [ 500002 ] , c = 0 ; int main ( ) { int n , i ; scanf ( "%d" , & n ) ; for ( i = 0 ; i < n ; i ++ ) { scanf ( "%d" , & A [ i ] ) ; } mergeSort ( 0 , n ) ; for ( i = 0 ; i < n - 1 ; i ++ ) { printf ( "%d " , A [ i ] ) ; } printf ( "%d\n%d\n" , A [ n - 1 ] , c ) ; return 0 ; } void merge ( int left , int mid , int right ) { int n1 , n2 , L [ 250001 ] , R [ 250001 ] , i , j , k ; n1 = mid - left ; n2 = right - mid ; for ( i = 0 ; i < n1 ; i ++ ) { L [ i ] = A [ left + i ] ; } for ( i = 0 ; i < n2 ; i ++ ) { R [ i ] = A [ mid + i ] ; } L [ n1 ] = INFTY ; R [ n2 ] = INFTY ; i = 0 ; j = 0 ; for ( k = left ; k < right ; k ++ ) { if ( L [ i ] <= R [ j ] ) { A [ k ] = L [ i ] ; i ++ ; } else { A [ k ] = R [ j ] ; j ++ ; } } } void mergeSort ( int left , int right ) { int mid ; if ( left + 1 < right ) { mid = ( left + right ) / 2 ; mergeSort ( left , mid ) ; mergeSort ( mid , right ) ; merge ( left , mid , right ) ; c += right - left ; } } 
4<CODESPLIT>Merge Sort<CODESPLIT>#include<stdio.h> void mergeSort ( int * , int , int ) ; void merge ( int * , int , int , int ) ; int count ; int main ( ) { int n , S [ 500005 ] , i ; scanf ( "%d" , & n ) ; for ( i = 0 ; i < n ; i ++ ) scanf ( "%d" , & S [ i ] ) ; mergeSort ( S , 0 , n ) ; for ( i = 0 ; i < n - 1 ; i ++ ) printf ( "%d " , S [ i ] ) ; printf ( "%d\n" , S [ n - 1 ] ) ; printf ( "%d\n" , count ) ; return 0 ; } void merge ( int * A , int left , int mid , int right ) { int n1 = mid - left , n2 = right - mid , L [ 250005 ] , R [ 250005 ] , i , j = 0 , k ; for ( i = 0 ; i < n1 ; i ++ ) L [ i ] = A [ left + i ] ; for ( i = 0 ; i < n2 ; i ++ ) R [ i ] = A [ mid + i ] ; L [ n1 ] = 2000000000 ; R [ n2 ] = 2000000000 ; i = 0 ; for ( k = left ; k < right ; k ++ ) { count ++ ; if ( L [ i ] <= R [ j ] ) { A [ k ] = L [ i ] ; i = i + 1 ; } else { A [ k ] = R [ j ] ; j = j + 1 ; } } } void mergeSort ( int * A , int left , int right ) { int mid ; if ( left + 1 < right ) { mid = ( left + right ) / 2 ; mergeSort ( A , left , mid ) ; mergeSort ( A , mid , right ) ; merge ( A , left , mid , right ) ; } } 
4<CODESPLIT>Merge Sort<CODESPLIT>#include <stdio.h> #define v 500000 #define V 2000000000 int M [ v / 2+2 ] , S [ v / 2+2 ] ; int c ; void merge ( int T [ ] , int n , int l , int m , int r ) { int i , j , k , n1 , n2 ; n1 = m - l ; n2 = r - m ; for ( i = 0 ; i < n1 ; i ++ ) M [ i ] = T [ l + i ] ; for ( i = 0 ; i < n2 ; i ++ ) S [ i ] = T [ m + i ] ; M [ n1 ] = S [ n2 ] = V ; i = 0 ; j = 0 ; for ( k = l ; k < r ; k ++ ) { c ++ ; if ( M [ i ] <= S [ j ] ) T [ k ] = M [ i ++ ] ; else T [ k ] = S [ j ++ ] ; } } void mergeSort ( int T [ ] , int n , int l , int r ) { int m ; if ( l + 1 < r ) { m = ( l + r ) / 2 ; mergeSort ( T , n , l , m ) ; mergeSort ( T , n , m , r ) ; merge ( T , n , l , m , r ) ; } } int main ( ) { int n , i , T [ v ] ; scanf ( "%d" , & n ) ; c = 0 ; for ( i = 0 ; i < n ; i ++ ) { scanf ( "%d" , & T [ i ] ) ; } mergeSort ( T , n , 0 , n ) ; for ( i = 0 ; i < n - 1 ; i ++ ) { printf ( "%d " , T [ i ] ) ; } printf ( "%d\n" , T [ n - 1 ] ) ; printf ( "%d\n" , c ) ; return 0 ; } 
4<CODESPLIT>Merge Sort<CODESPLIT>#include<stdio.h> #define N 500000 #define M 2000000000 int L [ N / 2+2 ] , R [ N / 2+2 ] ; int count = 0 ; void merge ( int A [ ] , int l , int m , int r ) { int i , j , k ; int n1 ; int n2 ; n1 = m - l ; n2 = r - m ; for ( i = 0 ; i < n1 ; i ++ ) { L [ i ] = A [ l + i ] ; } for ( i = 0 ; i < n2 ; i ++ ) { R [ i ] = A [ m + i ] ; } L [ n1 ] = R [ n2 ] = M ; i = j = 0 ; for ( k = l ; k < r ; k ++ ) { count ++ ; if ( L [ i ] <= R [ j ] ) { A [ k ] = L [ i ] ; i ++ ; } else { A [ k ] = R [ j ] ; j ++ ; } } } void mergesort ( int A [ ] , int l , int r ) { int m ; if ( l + 1 < r ) { m = ( l + r ) / 2 ; mergesort ( A , l , m ) ; mergesort ( A , m , r ) ; merge ( A , l , m , r ) ; } } int main ( ) { int i , a , b [ N ] ; scanf ( "%d" , & a ) ; for ( i = 0 ; i < a ; i ++ ) { scanf ( "%d" , & b [ i ] ) ; } mergesort ( b , 0 , a ) ; for ( i = 0 ; i < a - 1 ; i ++ ) { printf ( "%d " , b [ i ] ) ; } printf ( "%d\n" , b [ a - 1 ] ) ; printf ( "%d" , count ) ; printf ( "\n" ) ; return 0 ; } 
4<CODESPLIT>Merge Sort<CODESPLIT>#include<stdio.h> #include<stdlib.h> #define INFTY 1000000000 void merge ( int * , int , int , int ) ; void mergeSort ( int * , int , int ) ; int sum = 0 ; int main ( ) { int * T ; int n , i ; int left , right ; scanf ( "%d" , & n ) ; T = malloc ( n * sizeof ( int * ) ) ; for ( i = 0 ; i < n ; i ++ ) scanf ( "%d" , & T [ i ] ) ; left = 0 ; right = n ; mergeSort ( T , left , right ) ; for ( i = 0 ; i < n - 1 ; i ++ ) printf ( "%d " , T [ i ] ) ; printf ( "%d\n" , T [ n - 1 ] ) ; printf ( "%d\n" , sum ) ; return 0 ; } void merge ( int * A , int left , int mid , int right ) { int i , j , k ; int n1 = mid - left ; int n2 = right - mid ; int L [ n1 ] , R [ n2 ] ; for ( i = 0 ; i < n1 ; i ++ ) L [ i ] = A [ left + i ] ; for ( i = 0 ; i < n2 ; i ++ ) R [ i ] = A [ mid + i ] ; L [ n1 ] = INFTY ; R [ n2 ] = INFTY ; i = 0 ; j = 0 ; for ( k = left ; k < right ; k ++ ) { if ( L [ i ] <= R [ j ] ) { A [ k ] = L [ i ] ; i = i + 1 ; sum ++ ; } else { A [ k ] = R [ j ] ; j = j + 1 ; sum ++ ; } } } void mergeSort ( int * A , int left , int right ) { int mid ; if ( left + 1 < right ) { mid = ( left + right ) / 2 ; mergeSort ( A , left , mid ) ; mergeSort ( A , mid , right ) ; merge ( A , left , mid , right ) ; } } 
4<CODESPLIT>Merge Sort<CODESPLIT>#include <stdio.h> #define MAX 500000 #define SENTINEL 2000000000 int L [ MAX / 2+2 ] , R [ MAX / 2+2 ] ; int cnt ; void merge ( int A [ ] , int n , int left , int mid , int right ) { int i , j , k ; int n1 = mid - left ; int n2 = right - mid ; for ( i = 0 ; i < n1 ; i ++ ) L [ i ] = A [ left + i ] ; for ( i = 0 ; i < n2 ; i ++ ) R [ i ] = A [ mid + i ] ; L [ n1 ] = R [ n2 ] = SENTINEL ; i = 0 , j = 0 ; for ( k = left ; k < right ; k ++ ) { cnt ++ ; if ( L [ i ] <= R [ j ] ) { A [ k ] = L [ i ++ ] ; } else { A [ k ] = R [ j ++ ] ; } } } void mergeSort ( int A [ ] , int n , int left , int right ) { int mid ; if ( left + 1 < right ) { mid = ( left + right ) / 2 ; mergeSort ( A , n , left , mid ) ; mergeSort ( A , n , mid , right ) ; merge ( A , n , left , mid , right ) ; } } int main ( void ) { int A [ MAX ] , n , i ; cnt = 0 ; scanf ( "%d" , & n ) ; for ( i = 0 ; i < n ; i ++ ) scanf ( "%d" , & A [ i ] ) ; mergeSort ( A , n , 0 , n ) ; for ( i = 0 ; i < n ; i ++ ) { if ( i ) printf ( " " ) ; printf ( "%d" , A [ i ] ) ; } printf ( "\n%d\n" , cnt ) ; return 0 ; } 
4<CODESPLIT>Merge Sort<CODESPLIT>#include <stdio.h> #define MAX 500000 #define SENTINEL 2000000000 int L [ MAX / 2+2 ] , R [ MAX / 2+2 ] ; int cnt ; void merge ( int A [ ] , int n , int left , int mid , int right ) { int i , j , k ; int n1 = mid - left ; int n2 = right - mid ; for ( i = 0 ; i < n1 ; i ++ ) L [ i ] = A [ left + i ] ; for ( i = 0 ; i < n2 ; i ++ ) R [ i ] = A [ mid + i ] ; L [ n1 ] = R [ n2 ] = SENTINEL ; i = 0 , j = 0 ; for ( k = left ; k < right ; k ++ ) { cnt ++ ; if ( L [ i ] <= R [ j ] ) { A [ k ] = L [ i ++ ] ; } else { A [ k ] = R [ j ++ ] ; } } } void mergeSort ( int A [ ] , int n , int left , int right ) { int mid ; if ( left + 1 < right ) { mid = ( left + right ) / 2 ; mergeSort ( A , n , left , mid ) ; mergeSort ( A , n , mid , right ) ; merge ( A , n , left , mid , right ) ; } } int main ( void ) { int A [ MAX ] , n , i ; cnt = 0 ; scanf ( "%d" , & n ) ; for ( i = 0 ; i < n ; i ++ ) scanf ( "%d" , & A [ i ] ) ; mergeSort ( A , n , 0 , n ) ; for ( i = 0 ; i < n ; i ++ ) { if ( i ) printf ( " " ) ; printf ( "%d" , A [ i ] ) ; } printf ( "\n%d\n" , cnt ) ; return 0 ; } 
2<CODESPLIT>Selection Sort<CODESPLIT>#include<stdio.h> void swap ( int * a , int * b ) ; int main ( ) { int i , j , A [ 100 ] , N , count = 0 , minj ; while ( 1 ) { scanf ( "%d" , & N ) ; if ( 1 <= N && N <= 100 ) break ; } for ( i = 0 ; i < N ; i ++ ) { scanf ( "%d" , & A [ i ] ) ; } for ( i = 0 ; i <= N - 1 ; i ++ ) { minj = i ; for ( j = i ; j <= N - 1 ; j ++ ) { if ( A [ j ] < A [ minj ] ) { minj = j ; } } swap ( & A [ i ] , & A [ minj ] ) ; if ( minj ! = i ) count ++ ; } for ( i = 0 ; i < N - 1 ; i ++ ) printf ( "%d " , A [ i ] ) ; printf ( "%d\n" , A [ N - 1 ] ) ; printf ( "%d\n" , count ) ; return 0 ; } void swap ( int * a , int * b ) { int t ; t = * a ; * a = * b ; * b = t ; } 
2<CODESPLIT>Selection Sort<CODESPLIT>#include<stdio.h> int sentaku ( int * , int ) ; int main ( ) { int A [ 100 ] , N , a , sum ; scanf ( "%d" , & N ) ; for ( a = 0 ; a < N ; a ++ ) { scanf ( "%d" , & A [ a ] ) ; } sum = sentaku ( A , N ) ; for ( a = 0 ; a < N ; a ++ ) { if ( a > 0 ) { printf ( " " ) ; } printf ( "%d" , A [ a ] ) ; } printf ( "\n" ) ; printf ( "%d\n" , sum ) ; return 0 ; } int sentaku ( int A [ ] , int N ) { int a , b , c , sum = 0 , num ; for ( a = 0 ; a < N - 1 ; a ++ ) { num = a ; for ( b = a ; b < N ; b ++ ) { if ( A [ b ] < A [ num ] ) { num = b ; } } c = A [ a ] ; A [ a ] = A [ num ] ; A [ num ] = c ; if ( a ! = num ) { sum ++ ; } } return sum ; } 
2<CODESPLIT>Selection Sort<CODESPLIT>#include<stdio.h> int main ( ) { int i , j , minj , n , a [ 100 ] , tmp , sum = 0 ; scanf ( "%d" , & n ) ; for ( i = 0 ; i < n ; i ++ ) { scanf ( "%d" , & a [ i ] ) ; } for ( i = 0 ; i < n ; i ++ ) { minj = i ; for ( j = i + 1 ; j < n ; j ++ ) { if ( a [ j ] < a [ minj ] ) { minj = j ; } } if ( i ! = minj ) { sum ++ ; } tmp = a [ i ] ; a [ i ] = a [ minj ] ; a [ minj ] = tmp ; } for ( i = 0 ; i < n ; i ++ ) { printf ( "%d" , a [ i ] ) ; if ( i == n - 1 ) { printf ( "\n" ) ; } else { printf ( " " ) ; } } printf ( "%d\n" , sum ) ; } 
2<CODESPLIT>Selection Sort<CODESPLIT>#include <stdio.h> #define MAX_N 100 int main ( ) { int i , j , k , l ; int n , tmp , min , cnt = 0 ; int A [ MAX_N ] ; scanf ( "%d" , & n ) ; for ( i = 0 ; i < n ; i ++ ) scanf ( "%d" , & A [ i ] ) ; for ( j = 0 ; j < n ; j ++ ) { min = j ; for ( k = j ; k < n ; k ++ ) { if ( A [ k ] < A [ min ] ) min = k ; } tmp = A [ j ] ; A [ j ] = A [ min ] ; A [ min ] = tmp ; if ( j ! = min ) cnt ++ ; } for ( l = 0 ; l < n ; l ++ ) { if ( l ! = n - 1 ) printf ( "%d " , A [ l ] ) ; else printf ( "%d\n" , A [ l ] ) ; } printf ( "%d\n" , cnt ) ; return 0 ; } 
2<CODESPLIT>Selection Sort<CODESPLIT>#include<stdio.h> void swap ( int * x , int * y ) { int z ; z = * x ; * x = * y ; * y = z ; } void selectionSort ( int A [ ] , int N ) { int i , j ; int minj ; int count = 0 ; for ( i = 0 ; i < N ; i ++ ) { minj = i ; for ( j = i ; j < N ; j ++ ) { if ( A [ j ] < A [ minj ] ) minj = j ; } if ( i ! = minj ) { swap ( & A [ i ] , & A [ minj ] ) ; count ++ ; } } for ( j = 0 ; j < N - 1 ; j ++ ) { printf ( "%d " , A [ j ] ) ; } printf ( "%d\n" , A [ j ] ) ; printf ( "%d\n" , count ) ; } int main ( void ) { int N ; scanf ( "%d" , & N ) ; int Num [ N ] ; int i ; for ( i = 0 ; i < N ; i ++ ) scanf ( "%d" , & Num [ i ] ) ; selectionSort ( Num , N ) ; return 0 ; } 
2<CODESPLIT>Selection Sort<CODESPLIT>#include <stdio.h> int main ( void ) { int N , num [ 101 ] = { 0 } , i , j , cnt = 0 , mini , temp ; scanf ( "%d" , & N ) ; for ( i = 0 ; i < N ; i ++ ) { scanf ( "%d" , & num [ i ] ) ; } for ( i = 0 ; i < N ; i ++ ) { mini = i ; for ( j = i ; j < N ; j ++ ) { if ( num [ j ] < num [ mini ] ) { mini = j ; } } if ( num [ i ] > num [ mini ] ) { temp = num [ i ] ; num [ i ] = num [ mini ] ; num [ mini ] = temp ; cnt ++ ; } } for ( i = 0 ; i < N ; i ++ ) { printf ( "%d" , num [ i ] ) ; if ( i ! = N - 1 ) printf ( " " ) ; } printf ( "\n%d\n" , cnt ) ; return 0 ; } 
2<CODESPLIT>Selection Sort<CODESPLIT>#include <stdio.h> #define MAX_N 100 int main ( void ) { int A [ MAX_N ] , N ; int i , j , minj , hoge , count = 0 ; scanf ( "%d" , & N ) ; for ( i = 0 ; i < N ; i ++ ) scanf ( "%d" , & A [ i ] ) ; for ( i = 0 ; i < N ; i ++ ) { minj = i ; for ( j = i + 1 ; j < N ; j ++ ) { if ( A [ j ] < A [ minj ] ) minj = j ; } if ( minj ! = i ) { hoge = A [ i ] ; A [ i ] = A [ minj ] ; A [ minj ] = hoge ; count ++ ; } } for ( i = 0 ; i < N - 1 ; i ++ ) printf ( "%d " , A [ i ] ) ; printf ( "%d\n%d\n" , A [ i ] , count ) ; return 0 ; } 
2<CODESPLIT>Selection Sort<CODESPLIT>#include  <stdio.h> int main ( ) { int A [ 100 ] , n , i , j , k , min , temp , count = 0 ; scanf ( "%d" , & n ) ; for ( i = 0 ; i < n ; i ++ ) { scanf ( "%d" , & A [ i ] ) ; } for ( i = 0 ; i < n - 1 ; i ++ ) { min = A [ i ] ; k = i ; for ( j = i + 1 ; j < n ; j ++ ) { if ( A [ j ] < min ) { min = A [ j ] ; k = j ; } } temp = A [ i ] ; A [ i ] = A [ k ] ; A [ k ] = temp ; if ( i ! = k ) count ++ ; } for ( i = 0 ; i < n ; i ++ ) { printf ( "%d" , A [ i ] ) ; if ( i ! = n - 1 ) { printf ( " " ) ; } } printf ( "\n" ) ; printf ( "%d\n" , count ) ; return 0 ; } 
2<CODESPLIT>Selection Sort<CODESPLIT>#include<stdio.h> void selectionSort ( int A [ 101 ] , int N ) { int t , c = 0 , minj ; for ( int i = 0 ; i < N ; i ++ ) { minj = i ; for ( int j = i ; j < N ; j ++ ) { if ( A [ j ] < A [ minj ] ) { minj = j ; } } t = A [ i ] ; A [ i ] = A [ minj ] ; A [ minj ] = t ; if ( i ! = minj ) c ++ ; } for ( int i = 0 ; i < N ; i ++ ) { if ( i == N - 1 ) { printf ( "%d\n" , A [ i ] ) ; break ; } printf ( "%d " , A [ i ] ) ; } printf ( "%d\n" , c ) ; } int main ( void ) { int n , A [ 101 ] = { } ; scanf ( "%d" , & n ) ; for ( int i = 0 ; i < n ; i ++ ) { scanf ( "%d" , & A [ i ] ) ; } selectionSort ( A , n ) ; return 0 ; } 
2<CODESPLIT>Selection Sort<CODESPLIT>#include <stdio.h> #include <stdlib.h> int main ( ) { int n , cnt = 0 , i , j ; scanf ( "%d" , & n ) ; int * dat ; dat = ( int * ) malloc ( sizeof ( int ) * n ) ; for ( i = 0 ; i < n ; i ++ ) scanf ( "%d" , & dat [ i ] ) ; for ( i = 0 ; i < n - 1 ; i ++ ) { int jmin = i ; for ( j = i + 1 ; j < n ; j ++ ) { if ( dat [ j ] < dat [ jmin ] ) jmin = j ; } if ( jmin ! = i ) { int tmp = dat [ i ] ; dat [ i ] = dat [ jmin ] ; dat [ jmin ] = tmp ; cnt ++ ; } } printf ( "%d" , dat [ 0 ] ) ; for ( i = 1 ; i < n ; i ++ ) printf ( " %d" , dat [ i ] ) ; printf ( "\n%d\n" , cnt ) ; return 0 ; } 
2<CODESPLIT>Selection Sort<CODESPLIT>#include <stdio.h> int main ( ) { int flag , i , minj , j , N , A [ 100 ] , tmp , count = 0 ; flag = 1 ; i = 0 ; scanf ( "%d" , & N ) ; if ( N > 100 || N < 0 ) return 0 ; while ( i < N ) { scanf ( "%d" , & A [ i ] ) ; if ( A [ i ] > 100 || A [ i ] < 0 ) return 0 ; i ++ ; } for ( i = 0 ; i <= N - 1 ; i ++ ) { minj = i ; for ( j = i ; j <= N - 1 ; j ++ ) { if ( A [ j ] < A [ minj ] ) { minj = j ; } } if ( i ! = minj ) { tmp = A [ minj ] ; A [ minj ] = A [ i ] ; A [ i ] = tmp ; count ++ ; } } for ( j = 0 ; j <= N - 2 ; j ++ ) { printf ( "%d " , A [ j ] ) ; } printf ( "%d" , A [ j ] ) ; printf ( "\n%d\n" , count ) ; return 0 ; } 
2<CODESPLIT>Selection Sort<CODESPLIT>#include<stdio.h> int main ( ) { int i , j , n , min , kou = 0 , A [ 100 ] , B ; scanf ( "%d" , & n ) ; for ( i = 0 ; i < n ; i ++ ) { scanf ( "%d" , & A [ i ] ) ; } for ( i = 0 ; i < n ; i ++ ) { min = i ; for ( j = i ; j < n ; j ++ ) { if ( A [ min ] > A [ j ] ) min = j ; } if ( min ! = i ) { B = A [ i ] ; A [ i ] = A [ min ] ; A [ min ] = B ; kou ++ ; } } for ( i = 0 ; i < n ; i ++ ) { if ( i ! = n - 1 ) printf ( "%d " , A [ i ] ) ; else printf ( "%d\n" , A [ i ] ) ; } printf ( "%d\n" , kou ) ; return 0 ; } 
2<CODESPLIT>Selection Sort<CODESPLIT>#include<stdio.h> #define N 101 int main ( ) { int i , j , n , key = 0 , count = 0 , array [ N ] , mini ; scanf ( "%d" , & n ) ; for ( i = 0 ; i < n ; i ++ ) { scanf ( "%d" , & array [ i ] ) ; } for ( i = 0 ; i < n ; i ++ ) { mini = i ; for ( j = i ; j < n ; j ++ ) { if ( array [ j ] < array [ mini ] ) { mini = j ; } } key = array [ i ] ; array [ i ] = array [ mini ] ; array [ mini ] = key ; if ( mini ! = i ) count ++ ; } for ( i = 0 ; i < n ; i ++ ) { if ( i < n - 1 ) printf ( "%d " , array [ i ] ) ; if ( i == n - 1 ) printf ( "%d\n" , array [ i ] ) ; } printf ( "%d\n" , count ) ; return 0 ; } 
2<CODESPLIT>Selection Sort<CODESPLIT>#include <stdio.h> int main ( ) { int a [ 100 ] ; int i , j , minj , n ; int data , c , cnt = 0 ; scanf ( "%d" , & n ) ; if ( n < 1 || n > 100 ) return 0 ; for ( c = 0 ; c < n ; c ++ ) { scanf ( "%d" , & a [ c ] ) ; } for ( i = 0 ; i < n ; i ++ ) { minj = i ; for ( j = i ; j < n ; j ++ ) { if ( a [ j ] < a [ minj ] ) { minj = j ; } } data = a [ i ] ; a [ i ] = a [ minj ] ; a [ minj ] = data ; if ( i ! = minj ) { cnt ++ ; } } for ( c = 0 ; c < n - 1 ; c ++ ) { printf ( "%d " , a [ c ] ) ; } printf ( "%d\n" , a [ n - 1 ] ) ; printf ( "%d\n" , cnt ) ; return 0 ; } 
2<CODESPLIT>Selection Sort<CODESPLIT>#include <stdio.h> int selectionSort ( int A [ ] , int N ) { int i , j , t , sw = 0 , mini ; for ( i = 0 ; i < N - 1 ; i ++ ) { mini = i ; for ( j = i ; j < N ; j ++ ) { if ( A [ j ] < A [ mini ] ) mini = j ; } t = A [ i ] ; A [ i ] = A [ mini ] ; A [ mini ] = t ; if ( i ! = mini ) sw ++ ; } return sw ; } int main ( void ) { int A [ 100 ] , N , i , sw ; scanf ( "%d" , & N ) ; for ( i = 0 ; i < N ; i ++ ) scanf ( "%d" , & A [ i ] ) ; sw = selectionSort ( A , N ) ; for ( i = 0 ; i < N ; i ++ ) { if ( i > 0 ) printf ( " " ) ; printf ( "%d" , A [ i ] ) ; } printf ( "\n" ) ; printf ( "%d\n" , sw ) ; return 0 ; } 
2<CODESPLIT>Selection Sort<CODESPLIT>#include <stdio.h> #define N 100 int selection ( int * , int ) ; int main ( ) { int i , num = 0 , num2 [ N ] , new ; scanf ( "%d" , & num ) ; for ( i = 0 ; i < num ; i ++ ) { scanf ( "%d" , & num2 [ i ] ) ; } new = selection ( num2 , num ) ; for ( i = 0 ; i < num ; i ++ ) { if ( i < num - 1 ) printf ( "%d " , num2 [ i ] ) ; else printf ( "%d\n" , num2 [ i ] ) ; } printf ( "%d\n" , new ) ; return 0 ; } int selection ( int * num2 , int num ) { int i , minj , j , cnt = 0 , temp ; for ( i = 0 ; i <= num - 1 ; i ++ ) { minj = i ; for ( j = i ; j <= num - 1 ; j ++ ) { if ( num2 [ j ] < num2 [ minj ] ) { minj = j ; } } temp = num2 [ i ] ; num2 [ i ] = num2 [ minj ] ; num2 [ minj ] = temp ; if ( num2 [ i ] ! = num2 [ minj ] ) cnt ++ ; } return cnt ; } 
2<CODESPLIT>Selection Sort<CODESPLIT>#include<stdio.h> #include<stdlib.h> int main ( ) { int N , i , A [ 100 ] , minj , j , state = 0 , cnt = 0 , cnt2 = 0 ; scanf ( "%d" , & N ) ; if ( N < 1 || N > 100 ) exit ( 0 ) ; for ( i = 0 ; i < N ; i ++ ) { scanf ( "%d" , & A [ i ] ) ; } for ( i = 0 ; i < N ; i ++ ) { minj = i ; for ( j = i ; j < N ; j ++ ) { if ( A [ j ] < A [ minj ] ) { minj = j ; } } if ( minj ! = i ) { state = A [ i ] ; A [ i ] = A [ minj ] ; A [ minj ] = state ; cnt ++ ; } } for ( i = 0 ; i < N ; i ++ ) { if ( i == N - 1 ) { printf ( "%d" , A [ i ] ) ; } else { printf ( "%d " , A [ i ] ) ; } } printf ( "\n" ) ; printf ( "%d\n" , cnt ) ; return 0 ; } 
2<CODESPLIT>Selection Sort<CODESPLIT>#include <stdio.h> #include <stdlib.h> int main ( int argc , char ** argv ) { int size , counter = 0 ; int * A ; scanf ( "%d" , & size ) ; A = ( int * ) malloc ( sizeof ( int ) * size ) ; for ( int ix = 0 ; ix < size ; ++ ix ) scanf ( "%d" , & A [ ix ] ) ; for ( int c = 0 ; c < ( size - 1 ) ; c ++ ) { int position , swap , d ; position = c ; for ( d = c + 1 ; d < size ; d ++ ) { if ( A [ position ] > A [ d ] ) position = d ; } if ( position ! = c ) { swap = A [ c ] ; A [ c ] = A [ position ] ; A [ position ] = swap ; counter ++ ; } } for ( int ix = 0 ; ix < size ; ++ ix ) { if ( ix > 0 ) printf ( " " ) ; printf ( "%d" , A [ ix ] ) ; } printf ( "\n" ) ; printf ( "%d\n" , counter ) ; return ( EXIT_SUCCESS ) ; } 
2<CODESPLIT>Selection Sort<CODESPLIT>#include <stdio.h> int main ( ) { int a [ 100 ] , n , i , j , minj , count = 0 , tmp ; scanf ( "%d" , & n ) ; for ( i = 0 ; i < n ; i ++ ) scanf ( "%d" , & a [ i ] ) ; for ( i = 0 ; i < n - 1 ; i ++ ) { minj = i ; for ( j = i ; j < n ; j ++ ) { if ( a [ j ] < a [ minj ] ) { minj = j ; } } tmp = a [ i ] ; a [ i ] = a [ minj ] ; a [ minj ] = tmp ; if ( i ! = minj ) count ++ ; } for ( i = 0 ; i < n - 1 ; i ++ ) { printf ( "%d " , a [ i ] ) ; } printf ( "%d\n" , a [ n - 1 ] ) ; printf ( "%d\n" , count ) ; } 
0<CODESPLIT>Bubble Sort<CODESPLIT>#include <stdio.h> int n , a [ 105 ] , sps = 0 , temp ; int main ( ) { scanf ( "%d" , & n ) ; for ( int i = 0 ; i < n ; i ++ ) { scanf ( "%d" , & a [ i ] ) ; } for ( int i = 0 ; i < n - 1 ; i ++ ) { for ( int j = 0 ; j < n - i - 1 ; j ++ ) { if ( a [ j ] > a [ j + 1 ] ) { temp = a [ j ] ; a [ j ] = a [ j + 1 ] ; a [ j + 1 ] = temp ; sps ++ ; } } } for ( int i = 0 ; i < n ; i ++ ) { if ( i == n - 1 ) { printf ( "%d" , a [ i ] ) ; } else printf ( "%d " , a [ i ] ) ; } printf ( "\n" ) ; printf ( "%d\n" , sps ) ; } 
0<CODESPLIT>Bubble Sort<CODESPLIT>#include<stdio.h> void trance ( int A [ ] , int N , int count ) { int i ; for ( i = 0 ; i < N ; i ++ ) { if ( i > 0 ) printf ( " " ) ; printf ( "%d" , A [ i ] ) ; } printf ( "\n" ) ; printf ( "%d\n" , count ) ; } int bubbleSort ( int A [ ] , int N , int count ) { int i , v ; int sum ; sum = count ; for ( i = N - 1 ; i > 0 ; i -- ) { if ( A [ i ] < A [ i - 1 ] ) { v = A [ i ] ; A [ i ] = A [ i - 1 ] ; A [ i - 1 ] = v ; sum ++ ; } } return sum ; } int main ( void ) { int i , A [ 100 ] , N , count = 0 ; scanf ( "%d" , & N ) ; for ( i = 0 ; i < N ; i ++ ) { scanf ( "%d" , & A [ i ] ) ; } for ( i = 0 ; i < N ; i ++ ) { count = bubbleSort ( A , N , count ) ; } trance ( A , N , count ) ; return 0 ; } 
0<CODESPLIT>Bubble Sort<CODESPLIT>#include <stdio.h> #define N 100 void bubbleSort ( int * , int ) ; int main ( ) { int array [ N ] , n , i ; scanf ( "%d" , & n ) ; for ( i = 0 ; i < n ; i ++ ) scanf ( "%d" , & array [ i ] ) ; bubbleSort ( array , n ) ; return 0 ; } void bubbleSort ( int * array , int n ) { int flag = 1 , i = 0 , j , tmp , cnt = 0 ; while ( flag ) { flag = 0 ; for ( j = n - 1 ; j >= i + 1 ; j -- ) { if ( array [ j ] < array [ j - 1 ] ) { tmp = array [ j ] ; array [ j ] = array [ j - 1 ] ; array [ j - 1 ] = tmp ; flag = 1 ; cnt ++ ; } } i ++ ; } for ( i = 0 ; i < n ; i ++ ) { if ( i == n - 1 ) printf ( "%d\n" , array [ i ] ) ; else printf ( "%d " , array [ i ] ) ; } printf ( "%d\n" , cnt ) ; } 
0<CODESPLIT>Bubble Sort<CODESPLIT>#include <stdio.h> #define N 100 void trace ( int A [ ] , int n ) { int i ; for ( i = 1 ; i <= n ; i ++ ) { if ( i > 1 ) printf ( " " ) ; printf ( "%d" , A [ i ] ) ; } printf ( "\n" ) ; } int main ( void ) { int A [ N + 1 ] , i , j , key , n , count = 0 ; scanf ( "%d" , & n ) ; for ( i = 1 ; i < n + 1 ; i ++ ) { scanf ( "%d" , & A [ i ] ) ; } for ( i = 1 ; i < n + 1 ; i ++ ) { for ( j = n ; j >= i + 1 ; j -- ) { if ( A [ j ] < A [ j - 1 ] ) { key = A [ j ] ; A [ j ] = A [ j - 1 ] ; A [ j - 1 ] = key ; count ++ ; } } } trace ( A , n ) ; printf ( "%d\n" , count ) ; return 0 ; } 
0<CODESPLIT>Bubble Sort<CODESPLIT>#include <stdio.h> #define N 100 int bubbleSort ( int * , int ) ; void swap ( int * , int * ) ; int main ( ) { int A [ N ] ; int i , j , n , cnt = 0 ; scanf ( "%d" , & n ) ; for ( i = 0 ; i < n ; i ++ ) { scanf ( "%d" , & A [ i ] ) ; } cnt = bubbleSort ( A , n ) ; for ( j = 0 ; j < n ; j ++ ) { printf ( "%d" , A [ j ] ) ; if ( j < n - 1 ) printf ( " " ) ; } printf ( "\n" ) ; printf ( "%d\n" , cnt ) ; return 0 ; } int bubbleSort ( int A [ ] , int n ) { int j , flag = 1 , cnt = 0 ; while ( flag ) { flag = 0 ; for ( j = n - 1 ; j > 0 ; j -- ) { if ( A [ j ] < A [ j - 1 ] ) { swap ( & A [ j ] , & A [ j - 1 ] ) ; flag = 1 ; cnt ++ ; } } } return cnt ; } void swap ( int * a , int * b ) { int c ; c = * a ; * a = * b ; * b = c ; } 
0<CODESPLIT>Bubble Sort<CODESPLIT>#include <stdio.h> int main ( ) { int flag = 1 , i , cnt1 = 0 , cnt2 = 0 , N , tmp , A [ 100 ] , j ; scanf ( "%d" , & N ) ; for ( i = 0 ; i < N ; i ++ ) { scanf ( "%d" , & A [ i ] ) ; } while ( flag ) { flag = 0 ; for ( j = N - 1 ; j >= 1 ; j -- ) { if ( A [ j ] < A [ j - 1 ] ) { tmp = A [ j - 1 ] ; A [ j - 1 ] = A [ j ] ; A [ j ] = tmp ; flag = 1 ; cnt1 ++ ; } } cnt2 ++ ; if ( cnt2 > N ) break ; } for ( i = 0 ; i < N - 1 ; i ++ ) { printf ( "%d " , A [ i ] ) ; } printf ( "%d" , A [ N - 1 ] ) ; printf ( "\n%d\n" , cnt1 ) ; return 0 ; } 
0<CODESPLIT>Bubble Sort<CODESPLIT>#include<stdio.h> int main ( void ) { int v , i , n , j , A [ 100 ] ; int count = 0 ; scanf ( "%d" , & n ) ; for ( i = 0 ; i < n ; i ++ ) { scanf ( "%d" , & A [ i ] ) ; } for ( j = 0 ; j < n ; j ++ ) { for ( i = n - 1 ; i > j ; i -- ) { if ( A [ i ] < A [ i - 1 ] ) { v = A [ i ] ; A [ i ] = A [ i - 1 ] ; A [ i - 1 ] = v ; count ++ ; } } } for ( i = 0 ; i < n ; i ++ ) { if ( i == n - 1 ) { printf ( "%d\n" , A [ i ] ) ; } else { printf ( "%d " , A [ i ] ) ; } } printf ( "%d\n" , count ) ; return 0 ; } 
0<CODESPLIT>Bubble Sort<CODESPLIT>#include<stdio.h> void trace ( int A [ ] , int N ) { for ( int i = 0 ; i < N ; i ++ ) { if ( i > 0 ) printf ( " " ) ; printf ( "%d" , A [ i ] ) ; } printf ( "\n" ) ; } int bubbleSort ( int A [ ] , int N ) { int flag = 1 ; int sw = 0 ; while ( flag ) { flag = 0 ; for ( int j = N - 1 ; j >= 1 ; j -- ) { if ( A [ j ] < A [ j - 1 ] ) { int t = A [ j ] ; A [ j ] = A [ j - 1 ] ; A [ j - 1 ] = t ; sw ++ ; flag = 1 ; } } } trace ( A , N ) ; return sw ; } int main ( void ) { int N ; int A [ 100 ] ; int sw ; scanf ( "%d" , & N ) ; for ( int i = 0 ; i < N ; i ++ ) { scanf ( "%d" , & A [ i ] ) ; } sw = bubbleSort ( A , N ) ; printf ( "%d\n" , sw ) ; return 0 ; } 
0<CODESPLIT>Bubble Sort<CODESPLIT>#include <stdio.h> int main ( ) { int A [ 100 ] ; int i = 0 , j = 0 , n = 0 , N = 0 ; int a ; int flag = 1 ; scanf ( "%d" , & N ) ; for ( i = 0 ; i < N ; i ++ ) { scanf ( "%d" , & A [ i ] ) ; } while ( flag ) { flag = 0 ; for ( j = N - 1 ; 0 < j ; j -- ) { if ( A [ j ] < A [ j - 1 ] ) { a = A [ j ] ; A [ j ] = A [ j - 1 ] ; A [ j - 1 ] = a ; flag = 1 ; n ++ ; } } } for ( i = 0 ; i < N ; i ++ ) { printf ( "%d" , A [ i ] ) ; if ( i == N - 1 ) printf ( "\n" ) ; else printf ( " " ) ; } printf ( "%d\n" , n ) ; return 0 ; } 
0<CODESPLIT>Bubble Sort<CODESPLIT>#include <stdio.h> #include <stdlib.h> int main ( ) { int * A , N , j , flag , temp , count ; scanf ( "%d" , & N ) ; A = ( int * ) malloc ( sizeof ( int ) * N ) ; for ( j = 0 ; j < N ; j ++ ) { scanf ( "%d" , & A [ j ] ) ; } count = 0 ; flag = 1 ; while ( flag ) { flag = 0 ; for ( j = N - 1 ; j > 0 ; j -- ) { if ( A [ j ] < A [ j - 1 ] ) { temp = A [ j ] ; A [ j ] = A [ j - 1 ] ; A [ j - 1 ] = temp ; flag = 1 ; count ++ ; } } } for ( j = 0 ; j < N ; j ++ ) { printf ( "%d" , A [ j ] ) ; if ( j ! = N - 1 ) printf ( " " ) ; } printf ( "\n%d\n" , count ) ; return 0 ; } 
0<CODESPLIT>Bubble Sort<CODESPLIT>int main ( void ) { int N , tmp , flag = 1 , count = 0 ; scanf ( "%d" , & N ) ; int A [ N ] ; for ( int i = 0 ; i < N ; i ++ ) { scanf ( "%d" , & A [ i ] ) ; } while ( flag ) { flag = 0 ; for ( int j = N - 1 ; j > 0 ; j -- ) { if ( A [ j ] < A [ j - 1 ] ) { tmp = A [ j - 1 ] ; A [ j - 1 ] = A [ j ] ; A [ j ] = tmp ; count ++ ; flag = 1 ; } } } for ( int k = 0 ; k < N ; k ++ ) { printf ( "%d" , A [ k ] ) ; if ( k < N - 1 ) printf ( " " ) ; } printf ( "\n%d\n" , count ) ; return 0 ; } 
0<CODESPLIT>Bubble Sort<CODESPLIT>#include<stdio.h> #define N 100 void bubble ( int * , int ) ; int main ( ) { int i , n , array [ N ] ; scanf ( "%d" , & n ) ; for ( i = 0 ; i < n ; i ++ ) scanf ( "%d" , & array [ i ] ) ; bubble ( array , n ) ; return 0 ; } void bubble ( int A [ ] , int n ) { int i , j , cnt = 0 , tmp , flag ; flag = 1 ; while ( flag == 1 ) { flag = 0 ; for ( i = 0 ; i < n ; i ++ ) { for ( j = n - 1 ; j > i ; j -- ) { if ( A [ j ] < A [ j - 1 ] ) { tmp = A [ j ] ; A [ j ] = A [ j - 1 ] ; A [ j - 1 ] = tmp ; cnt ++ ; flag = 1 ; } } } } for ( i = 0 ; i < n ; i ++ ) { printf ( "%d" , A [ i ] ) ; if ( i ! = n - 1 ) printf ( " " ) ; } printf ( "\n%d\n" , cnt ) ; } 
0<CODESPLIT>Bubble Sort<CODESPLIT>#include<stdio.h> #define N 100 int main ( ) { int i , j , n , tmp , count = 0 , a [ N ] ; scanf ( "%d" , & n ) ; for ( i = 0 ; i < n ; i ++ ) { scanf ( "%d" , & a [ i ] ) ; } for ( i = 0 ; i < n ; i ++ ) { for ( j = n - 1 ; j > i ; j -- ) { if ( a [ j ] < a [ j - 1 ] ) { tmp = a [ j - 1 ] ; a [ j - 1 ] = a [ j ] ; a [ j ] = tmp ; count ++ ; } } } printf ( "%d" , a [ 0 ] ) ; for ( i = 1 ; i < n ; i ++ ) { printf ( " %d" , a [ i ] ) ; } printf ( "\n%d\n" , count ) ; return 0 ; } 
0<CODESPLIT>Bubble Sort<CODESPLIT>#include<stdio.h> #define MAX 100 int main ( ) { int A [ MAX ] ; int i , N , swap , flag , count = 0 ; scanf ( "%d" , & N ) ; for ( i = 0 ; i < N ; i ++ ) { scanf ( "%d" , & A [ i ] ) ; } flag = 1 ; while ( flag ) { flag = 0 ; for ( i = N - 1 ; i >= 1 ; i -- ) { if ( A [ i ] < A [ i - 1 ] ) { swap = A [ i ] ; A [ i ] = A [ i - 1 ] ; A [ i - 1 ] = swap ; count ++ ; flag = 1 ; } } } for ( i = 0 ; i < N ; i ++ ) { printf ( "%d" , A [ i ] ) ; if ( i == N - 1 ) break ; printf ( " " ) ; } printf ( "\n" ) ; printf ( "%d\n" , count ) ; return 0 ; } 
0<CODESPLIT>Bubble Sort<CODESPLIT>#include <stdio.h> #define BUF_SIZE 1000 #define ARR_SIZE 100 void print_array ( int array [ ] , int size ) { int i ; for ( i = 0 ; i < size ; i ++ ) { if ( i > 0 ) printf ( " " ) ; printf ( "%d" , array [ i ] ) ; } printf ( "\n" ) ; return ; } int bubble_sort ( int array [ ] , int size ) { int flag = 1 ; int tmp , j ; int swap_size ; int count = 0 ; while ( flag ) { flag = 0 ; for ( j = size - 1 ; 0 < j ; j -- ) { if ( array [ j ] < array [ j - 1 ] ) { tmp = array [ j ] ; array [ j ] = array [ j - 1 ] ; array [ j - 1 ] = tmp ; flag = 1 ; count ++ ; } } } return count ; } int main ( void ) { char buf [ BUF_SIZE ] ; int array [ ARR_SIZE ] ; int size , i , swap_size ; fgets ( buf , BUF_SIZE , stdin ) ; sscanf ( buf , "%d" , & size ) ; for ( i = 0 ; i < size ; i ++ ) { scanf ( "%d" , & array [ i ] ) ; } swap_size = bubble_sort ( array , size ) ; print_array ( array , size ) ; printf ( "%d\n" , swap_size ) ; return 0 ; } 
0<CODESPLIT>Bubble Sort<CODESPLIT>#include<stdio.h> int main ( ) { int i , j , u = 0 , m , temp = 0 , A [ 100 ] ; scanf ( "%d" , & m ) ; for ( i = 0 ; i < m ; i ++ ) { scanf ( "%d" , & A [ i ] ) ; } for ( i = 0 ; i < m - 1 ; i ++ ) { for ( j = m - 1 ; j >= i + 1 ; j -- ) { if ( A [ j ] < A [ j - 1 ] ) { temp = A [ j ] ; A [ j ] = A [ j - 1 ] ; A [ j - 1 ] = temp ; u ++ ; } } } for ( i = 0 ; i < m - 1 ; i ++ ) { printf ( "%d " , A [ i ] ) ; } printf ( "%d" , A [ m - 1 ] ) ; printf ( "\n" ) ; printf ( "%d\n" , u ) ; return 0 ; } 
0<CODESPLIT>Bubble Sort<CODESPLIT>#include<stdio.h> int main ( void ) { int i , j , t , N , A [ 100 ] , flag = 1 , count = 0 ; scanf ( "%d" , & N ) ; for ( i = 0 ; i < N ; i ++ ) scanf ( "%d" , & A [ i ] ) ; while ( flag ) { flag = 0 ; for ( j = N - 1 ; j >= 1 ; j -- ) { if ( A [ j ] < A [ j - 1 ] ) { t = A [ j ] ; A [ j ] = A [ j - 1 ] ; A [ j - 1 ] = t ; count ++ ; flag = 1 ; } } } for ( j = 0 ; j < N ; j ++ ) { if ( j == N - 1 ) printf ( "%d\n" , A [ j ] ) ; else printf ( "%d " , A [ j ] ) ; } printf ( "%d\n" , count ) ; return 0 ; } 
0<CODESPLIT>Bubble Sort<CODESPLIT>#include <stdio.h> void bubbleSort ( int * , int ) ; int main ( ) { int i , j , quantity , data [ 100 ] ; scanf ( "%d" , & quantity ) ; for ( i = 0 ; i < quantity ; i ++ ) { scanf ( "%d" , & data [ i ] ) ; } bubbleSort ( data , quantity ) ; } void bubbleSort ( int * a , int q ) { int i , j , k , time = 0 ; for ( i = 0 ; i < q ; i ++ ) { for ( j = q - 1 ; j > i ; j -- ) { if ( a [ j ] < a [ j - 1 ] ) { k = a [ j ] ; a [ j ] = a [ j - 1 ] ; a [ j - 1 ] = k ; time ++ ; } } } for ( i = 0 ; i < q - 1 ; i ++ ) printf ( "%d " , a [ i ] ) ; printf ( "%d\n" , a [ i ] ) ; printf ( "%d\n" , time ) ; } 
0<CODESPLIT>Bubble Sort<CODESPLIT>#include <stdio.h> #define MAX 100 int BubbleSort ( int A [ ] , int N ) { int flag = 1 ; int i ; int cnt = 0 ; while ( flag ) { flag = 0 ; for ( i = N - 1 ; i > 0 ; i -- ) { if ( A [ i ] < A [ i - 1 ] ) { int tmp ; tmp = A [ i ] ; A [ i ] = A [ i - 1 ] ; A [ i - 1 ] = tmp ; cnt ++ ; flag = 1 ; } } } return cnt ; } int main ( ) { int N ; int A [ MAX ] ; int ans , i ; scanf ( "%d" , & N ) ; for ( i = 0 ; i < N ; i ++ ) scanf ( "%d" , & A [ i ] ) ; ans = BubbleSort ( A , N ) ; for ( i = 0 ; i < N ; i ++ ) { if ( i ! = 0 ) printf ( " " ) ; printf ( "%d" , A [ i ] ) ; } printf ( "\n" ) ; printf ( "%d\n" , ans ) ; return 0 ; } 
5<CODESPLIT>Quick Sort<CODESPLIT>#include <stdio.h> #define MAX 100000 #define INFINITY 2000000000 struct Card { char s ; int value ; } ; struct Card L [ MAX / 2+2 ] , R [ MAX / 2+2 ] ; void marge ( struct Card [ ] , int , int , int ) ; void margeSort ( struct Card [ ] , int , int ) ; int partition ( struct Card [ ] , int , int , int ) ; void quickSort ( struct Card [ ] , int , int , int ) ; int main ( ) { int n , i , j , v ; int stable = 1 ; struct Card A [ MAX ] , B [ MAX ] ; char S [ 10 ] ; scanf ( "%d" , & n ) ; for ( i = 0 ; i < n ; i ++ ) { scanf ( "%s %d" , S , & v ) ; A [ i ] . s = B [ i ] . s = S [ 0 ] ; A [ i ] . value = B [ i ] . value = v ; } margeSort ( A , 0 , n ) ; quickSort ( B , n , 0 , n - 1 ) ; for ( i = 0 ; i < n ; i ++ ) { if ( A [ i ] . s ! = B [ i ] . s ) stable = 0 ; } if ( stable == 1 ) printf ( "Stable\n" ) ; else printf ( "Not stable\n" ) ; for ( i = 0 ; i < n ; i ++ ) { printf ( "%c %d\n" , B [ i ] . s , B [ i ] . value ) ; } return 0 ; } void marge ( struct Card A [ ] , int left , int mid , int right ) { int i , j , k , n1 , n2 ; n1 = mid - left ; n2 = right - mid ; for ( i = 0 ; i < n1 ; i ++ ) L [ i ] = A [ left + i ] ; for ( i = 0 ; i < n2 ; i ++ ) R [ i ] = A [ mid + i ] ; L [ n1 ] . value = INFINITY ; R [ n2 ] . value = INFINITY ; i = 0 ; j = 0 ; for ( k = left ; k < right ; k ++ ) { if ( L [ i ] . value <= R [ j ] . value ) { A [ k ] = L [ i ++ ] ; } else { A [ k ] = R [ j ++ ] ; } } } void margeSort ( struct Card A [ ] , int left , int right ) { int mid ; if ( left + 1 < right ) { mid = ( left + right ) / 2 ; margeSort ( A , left , mid ) ; margeSort ( A , mid , right ) ; marge ( A , left , mid , right ) ; } } int partition ( struct Card A [ ] , int n , int p , int r ) { int i , j ; struct Card t , x ; x = A [ r ] ; i = p - 1 ; for ( j = p ; j < r ; j ++ ) { if ( A [ j ] . value <= x . value ) { i ++ ; t = A [ i ] ; A [ i ] = A [ j ] ; A [ j ] = t ; } } t = A [ i + 1 ] ; A [ i + 1 ] = A [ r ] ; A [ r ] = t ; return i + 1 ; } void quickSort ( struct Card A [ ] , int n , int p , int r ) { int q ; if ( p < r ) { q = partition ( A , n , p , r ) ; quickSort ( A , n , p , q - 1 ) ; quickSort ( A , n , q + 1 , r ) ; } } 
5<CODESPLIT>Quick Sort<CODESPLIT>#include<stdio.h> #define MAX 100000 #define MAX2 1000000000 typedef struct { char gara ; int value ; } point ; point L [ MAX / 2+2 ] , R [ MAX / 2+2 ] ; void merge ( point A [ ] , int n , int l , int m , int r ) { int i , j , k ; int x1 = r - m ; int x2 = m - l ; for ( i = 0 ; i < x1 ; i ++ ) R [ i ] = A [ m + i ] ; for ( i = 0 ; i < x2 ; i ++ ) L [ i ] = A [ l + i ] ; L [ x2 ] . value = R [ x1 ] . value = MAX2 ; i = j = 0 ; for ( k = l ; k < r ; k ++ ) { if ( L [ i ] . value <= R [ j ] . value ) { A [ k ] = L [ i ++ ] ; } else { A [ k ] = R [ j ++ ] ; } } } void sort ( point A [ ] , int n , int l , int r ) { int m ; if ( l + 1 < r ) { m = ( l + r ) / 2 ; sort ( A , n , l , m ) ; sort ( A , n , m , r ) ; merge ( A , n , l , m , r ) ; } } int part ( point A [ ] , int n , int p , int r ) { int i , j ; point k , x ; x = A [ r ] ; i = p - 1 ; for ( j = p ; j < r ; j ++ ) { if ( A [ j ] . value <= x . value ) { i ++ ; k = A [ i ] ; A [ i ] = A [ j ] ; A [ j ] = k ; } } k = A [ i + 1 ] ; A [ i + 1 ] = A [ r ] ; A [ r ] = k ; return i + 1 ; } void quick ( point A [ ] , int n , int p , int r ) { int q ; if ( p < r ) { q = part ( A , n , p , r ) ; quick ( A , n , p , q - 1 ) ; quick ( A , n , q + 1 , r ) ; } } int main ( ) { int n , i , x , stable = 1 ; point data [ MAX ] , data2 [ MAX ] ; char C [ 10 ] ; scanf ( "%d" , & n ) ; for ( i = 0 ; i < n ; i ++ ) { scanf ( "%s %d" , C , & x ) ; data [ i ] . value = data2 [ i ] . value = x ; data [ i ] . gara = data2 [ i ] . gara = C [ 0 ] ; } sort ( data , n , 0 , n ) ; quick ( data2 , n , 0 , n - 1 ) ; for ( i = 0 ; i < n ; i ++ ) { if ( data [ i ] . gara ! = data2 [ i ] . gara ) stable = 0 ; } if ( stable == 1 ) printf ( "Stable\n" ) ; else printf ( "Not stable\n" ) ; for ( i = 0 ; i < n ; i ++ ) { printf ( "%c %d\n" , data2 [ i ] . gara , data2 [ i ] . value ) ; } return 0 ; } 
5<CODESPLIT>Quick Sort<CODESPLIT>#include <stdio.h> #if 1 #define gc() getchar_unlocked() #define pc(c) putchar_unlocked(c) #else #define gc() getchar() #define pc(c) putchar(c) #endif int in ( ) { int n = 0 , c = gc ( ) ; do n = 10 * n + ( c & 0xf ) , c = gc ( ) ; while ( c >= '0' ) ; return n ; } char buf [ 20 ] ; void mypr ( int n ) { int i ; if ( ! n ) { pc ( '0' ) ; return ; } i = 0 ; while ( n ) buf [ i ++ ] = n % 10 + '0' , n / = 10 ; while ( i -- ) pc ( buf [ i ] ) ; } typedef struct { char c ; int a ; int id ; } DATA ; int partition ( DATA * a , int lo , int hi ) { int i , j ; int key ; DATA t ; key = a [ hi ] . a , i = lo - 1 ; for ( j = lo ; j < hi ; j ++ ) { if ( a [ j ] . a <= key ) i ++ , t = a [ i ] , a [ i ] = a [ j ] , a [ j ] = t ; } t = a [ ++ i ] , a [ i ] = a [ hi ] , a [ hi ] = t ; return i ; } void quick_sort ( DATA * a , int lo , int hi ) { int mi ; if ( lo < hi ) { mi = partition ( a , lo , hi ) ; quick_sort ( a , lo , mi - 1 ) ; quick_sort ( a , mi + 1 , hi ) ; } } DATA a [ 100002 ] ; int main ( ) { int N , i , f ; N = in ( ) ; for ( i = 0 ; i < N ; i ++ ) { a [ i ] . c = gc ( ) , gc ( ) ; a [ i ] . a = in ( ) , a [ i ] . id = i ; } quick_sort ( a , 0 , N - 1 ) ; f = 0 ; for ( i = 1 ; i < N ; i ++ ) { if ( a [ i - 1 ] . a == a [ i ] . a && a [ i - 1 ] . id > a [ i ] . id ) { f = 1 ; break ; } } puts ( f ? "Not stable" : "Stable" ) ; for ( i = 0 ; i < N ; i ++ ) { pc ( a [ i ] . c ) , pc ( ' ' ) , mypr ( a [ i ] . a ) , pc ( '\n' ) ; } return 0 ; } 
5<CODESPLIT>Quick Sort<CODESPLIT>#include<stdio.h> char S [ 100000 ] ; int A [ 100000 ] ; int I [ 100000 ] ; int partition ( int p , int r ) { int x = A [ I [ r - 1 ] ] ; int i = p ; for ( int j = p ; j < r - 1 ; j ++ ) { if ( A [ I [ j ] ] <= x ) { int temp = I [ i ] ; I [ i ] = I [ j ] ; I [ j ] = temp ; i ++ ; } } int temp = I [ i ] ; I [ i ] = I [ r - 1 ] ; I [ r - 1 ] = temp ; return i ; } void quicksort ( int p , int r ) { if ( r - p >= 2 ) { int q = partition ( p , r ) ; quicksort ( p , q ) ; quicksort ( q + 1 , r ) ; } } int main ( void ) { int n ; scanf ( "%d" , & n ) ; for ( int i = 0 ; i < n ; i ++ ) { getchar ( ) ; scanf ( "%c" , & S [ i ] ) ; scanf ( "%d" , & A [ i ] ) ; I [ i ] = i ; } quicksort ( 0 , n ) ; int m = A [ I [ 0 ] ] ; int stable = 1 ; for ( int i = 1 ; i < n ; i ++ ) { if ( A [ I [ i - 1 ] ] == A [ I [ i ] ] && I [ i - 1 ] > I [ i ] ) stable = 0 ; } puts ( stable ? "Stable" : "Not stable" ) ; for ( int i = 0 ; i < n ; i ++ ) printf ( "%c %d\n" , S [ I [ i ] ] , A [ I [ i ] ] ) ; } 
5<CODESPLIT>Quick Sort<CODESPLIT>#include <stdio.h> #define MAX 100000 #define SENTINEL 2000000000 struct Card { char suit ; int value ; } ; struct Card L [ MAX / 2+2 ] , R [ MAX / 2+2 ] ; void merge ( struct Card A [ ] , int n , int left , int mid , int right ) { int i , j , k ; int n1 = mid - left ; int n2 = right - mid ; for ( int i = 0 ; i < n1 ; i ++ ) L [ i ] = A [ left + i ] ; for ( int i = 0 ; i < n2 ; i ++ ) R [ i ] = A [ mid + i ] ; L [ n1 ] . value = R [ n2 ] . value = SENTINEL ; i = j = 0 ; for ( k = left ; k < right ; k ++ ) { if ( L [ i ] . value <= R [ j ] . value ) { A [ k ] = L [ i ++ ] ; } else { A [ k ] = R [ j ++ ] ; } } } void mergeSort ( struct Card A [ ] , int n , int left , int right ) { if ( left + 1 < right ) { int mid = ( left + right ) / 2 ; mergeSort ( A , n , left , mid ) ; mergeSort ( A , n , mid , right ) ; merge ( A , n , left , mid , right ) ; } } int partition ( struct Card A [ ] , int n , int p , int r ) { int i , j ; struct Card t , x ; x = A [ r ] ; i = p - 1 ; for ( j = p ; j < r ; j ++ ) { if ( A [ j ] . value <= x . value ) { i ++ ; t = A [ i ] ; A [ i ] = A [ j ] ; A [ j ] = t ; } } t = A [ i + 1 ] ; A [ i + 1 ] = A [ r ] ; A [ r ] = t ; return i + 1 ; } void quickSort ( struct Card A [ ] , int n , int p , int r ) { int q ; if ( p < r ) { q = partition ( A , n , p , r ) ; quickSort ( A , n , p , q - 1 ) ; quickSort ( A , n , q + 1 , r ) ; } } int main ( ) { int n , i , v ; struct Card A [ MAX ] , B [ MAX ] ; char S [ 10 ] ; int stable = 1 ; scanf ( "%d" , & n ) ; for ( i = 0 ; i < n ; i ++ ) { scanf ( "%s %d" , S , & v ) ; A [ i ] . suit = B [ i ] . suit = S [ 0 ] ; A [ i ] . value = B [ i ] . value = v ; } mergeSort ( A , n , 0 , n ) ; quickSort ( B , n , 0 , n - 1 ) ; for ( i = 0 ; i < n ; i ++ ) { if ( A [ i ] . suit ! = B [ i ] . suit ) stable = 0 ; } if ( stable == 1 ) printf ( "Stable\n" ) ; else printf ( "Not stable\n" ) ; for ( i = 0 ; i < n ; i ++ ) { printf ( "%c %d\n" , B [ i ] . suit , B [ i ] . value ) ; } return 0 ; } 
5<CODESPLIT>Quick Sort<CODESPLIT>#include <stdio.h> #if 1 #define gc() getchar_unlocked() #define pc(c) putchar_unlocked(c) #else #define gc() getchar() #define pc(c) putchar(c) #endif int in ( ) { int n = 0 , c = gc ( ) ; do n = 10 * n + ( c & 0xf ) , c = gc ( ) ; while ( c >= '0' ) ; return n ; } char buf [ 20 ] ; void mypr ( int n ) { int i ; if ( ! n ) { pc ( '0' ) ; return ; } i = 0 ; while ( n ) buf [ i ++ ] = n % 10 + '0' , n / = 10 ; while ( i -- ) pc ( buf [ i ] ) ; } typedef struct { char c ; int a ; int id ; } DATA ; int partition ( DATA * a , int lo , int hi ) { int i , j ; int key ; DATA t ; key = a [ hi ] . a , i = lo - 1 ; for ( j = lo ; j < hi ; j ++ ) { if ( a [ j ] . a <= key ) i ++ , t = a [ i ] , a [ i ] = a [ j ] , a [ j ] = t ; } t = a [ ++ i ] , a [ i ] = a [ hi ] , a [ hi ] = t ; return i ; } void quick_sort ( DATA * a , int lo , int hi ) { int mi ; if ( lo < hi ) { mi = partition ( a , lo , hi ) ; quick_sort ( a , lo , mi - 1 ) ; quick_sort ( a , mi + 1 , hi ) ; } } DATA a [ 100002 ] ; int main ( ) { int N , i , f ; N = in ( ) ; for ( i = 0 ; i < N ; i ++ ) { a [ i ] . c = gc ( ) , gc ( ) ; a [ i ] . a = in ( ) , a [ i ] . id = i ; } quick_sort ( a , 0 , N - 1 ) ; f = 0 ; for ( i = 1 ; i < N ; i ++ ) { if ( a [ i - 1 ] . a == a [ i ] . a && a [ i - 1 ] . id > a [ i ] . id ) { f = 1 ; break ; } } puts ( f ? "Not stable" : "Stable" ) ; for ( i = 0 ; i < N ; i ++ ) { pc ( a [ i ] . c ) , pc ( ' ' ) , mypr ( a [ i ] . a ) , pc ( '\n' ) ; } return 0 ; } 
5<CODESPLIT>Quick Sort<CODESPLIT>#include <stdio.h> #define N 100001 int A [ N ] ; char X [ N ] ; int Number [ N ] ; char C [ N ] ; void quic_sort ( int , int ) ; void Swap1 ( int * , int * ) ; void Swap2 ( char * , char * ) ; int Check ( int ) ; int Partition ( int , int ) ; int main ( ) { int n , i ; scanf ( "%d" , & n ) ; for ( i = 0 ; i < n ; i ++ ) { getchar ( ) ; scanf ( "%c%d" , & X [ i ] , & A [ i ] ) ; } for ( i = 0 ; i < n ; i ++ ) { Number [ i ] = A [ i ] ; C [ i ] = X [ i ] ; } quic_sort ( 0 , n - 1 ) ; printf ( "%s\n" , ( Check ( n ) ? "Stable" : "Not stable" ) ) ; for ( i = 0 ; i < n ; i ++ ) printf ( "%c %d\n" , X [ i ] , A [ i ] ) ; return 0 ; } void Swap1 ( int * a , int * b ) { int tmp = * a ; * a = * b ; * b = tmp ; } void Swap2 ( char * a , char * b ) { char tmp = * a ; * a = * b ; * b = tmp ; } int Partition ( int p , int r ) { int x = A [ r ] ; int i = p - 1 , j ; for ( j = p ; j < r ; j ++ ) { if ( A [ j ] <= x ) { i ++ ; Swap1 ( & A [ i ] , & A [ j ] ) ; Swap2 ( & X [ i ] , & X [ j ] ) ; } } Swap1 ( & A [ i + 1 ] , & A [ r ] ) ; Swap2 ( & X [ i + 1 ] , & X [ r ] ) ; return i + 1 ; } void quic_sort ( int p , int r ) { if ( p < r ) { int q = Partition ( p , r ) ; quic_sort ( p , q - 1 ) ; quic_sort ( q + 1 , r ) ; } } int Check ( int n ) { int i , j ; for ( i = 1 ; i < n ; i ++ ) { if ( A [ i - 1 ] == A [ i ] ) { int a , b ; for ( j = 0 ; j < n ; j ++ ) { if ( A [ i - 1 ] == Number [ j ] && X [ i - 1 ] == C [ j ] ) a = j ; if ( A [ i ] == Number [ j ] && X [ i ] == C [ j ] ) b = j ; } if ( a > b ) return 0 ; } } return 1 ; } 
5<CODESPLIT>Quick Sort<CODESPLIT>#include <stdio.h> #include <stdlib.h> struct card { int n ; int p ; char c ; } typedef card ; card A [ 100000 ] ; int stableFlag = 0 ; int Partition ( int p , int r ) { int i , j ; card tmp ; i = p - 1 ; for ( j = p ; j < r ; j ++ ) { if ( A [ j ] . n <= A [ r ] . n ) { i = i + 1 ; tmp = A [ i ] ; A [ i ] = A [ j ] ; A [ j ] = tmp ; } } tmp = A [ i + 1 ] ; A [ i + 1 ] = A [ r ] ; A [ r ] = tmp ; return i + 1 ; } void QuickSort ( int p , int r ) { int q ; if ( p < r ) { q = Partition ( p , r ) ; QuickSort ( p , q - 1 ) ; QuickSort ( q + 1 , r ) ; } } int StableOrNot ( int n ) { int i ; for ( i = 0 ; i < n ; i ++ ) { if ( A [ i ] . n == A [ i + 1 ] . n && A [ i ] . p >= A [ i + 1 ] . p ) return 0 ; } return 1 ; } int main ( ) { int i ; int n ; scanf ( "%d" , & n ) ; for ( i = 0 ; i < n ; i ++ ) { while ( 1 ) { A [ i ] . c = getchar ( ) ; if ( A [ i ] . c ! = ' ' && A [ i ] . c ! = '\n' ) break ; } A [ i ] . p = i + 1 ; scanf ( "%d" , & A [ i ] . n ) ; } QuickSort ( 0 , n - 1 ) ; if ( StableOrNot ( n ) == 1 ) printf ( "Stable\n" ) ; else printf ( "Not stable\n" ) ; for ( i = 0 ; i < n ; i ++ ) { printf ( "%c %d\n" , A [ i ] . c , A [ i ] . n ) ; } return 0 ; } 
1<CODESPLIT>Insertion Sort<CODESPLIT>#include<stdio.h> int main ( ) { int k , v , N , i , j , A [ 1000 ] ; scanf ( "%d" , & N ) ; for ( k = 0 ; k < N ; k ++ ) { scanf ( "%d" , & A [ k ] ) ; } for ( k = 0 ; k < N ; k ++ ) { printf ( "%d" , A [ k ] ) ; if ( k < N - 1 ) { printf ( " " ) ; } } for ( i = 1 ; i <= N - 1 ; i ++ ) { v = A [ i ] ; j = i - 1 ; while ( j >= 0 && A [ j ] > v ) { A [ j + 1 ] = A [ j ] ; j -- ; } printf ( "\n" ) ; A [ j + 1 ] = v ; for ( k = 0 ; k < N ; k ++ ) { printf ( "%d" , A [ k ] ) ; if ( k < N - 1 ) { printf ( " " ) ; } } } printf ( "\n" ) ; return 0 ; } 
1<CODESPLIT>Insertion Sort<CODESPLIT>#include <stdio.h> int main ( ) { int N , A [ 100 ] , a , b , i , j , n , v ; scanf ( "%d" , & N ) ; for ( a = 0 ; a < N ; a ++ ) scanf ( "%d" , & A [ a ] ) ; for ( i = 1 ; i < N ; i ++ ) { for ( b = 0 ; b < N - 1 ; b ++ ) printf ( "%d " , A [ b ] ) ; printf ( "%d\n" , A [ N - 1 ] ) ; v = A [ i ] ; j = i - 1 ; while ( j >= 0 && A [ j ] > v ) { A [ j + 1 ] = A [ j ] ; j -- ; } A [ j + 1 ] = v ; } for ( b = 0 ; b < N - 1 ; b ++ ) printf ( "%d " , A [ b ] ) ; printf ( "%d\n" , A [ N - 1 ] ) ; return 0 ; } 
1<CODESPLIT>Insertion Sort<CODESPLIT>#include <stdio.h> int main ( void ) { int num ; int A [ 100 ] ; int i , j , k ; int V ; scanf ( "%d" , & num ) ; for ( i = 0 ; i < num ; i ++ ) { scanf ( "%d" , & A [ i ] ) ; } for ( i = 1 ; i <= num ; i ++ ) { for ( k = 0 ; k < num ; k ++ ) { if ( k == num - 1 ) { printf ( "%d" , A [ k ] ) ; } else { printf ( "%d " , A [ k ] ) ; } } printf ( "\n" ) ; V = A [ i ] ; j = i - 1 ; while ( A [ j ] > V && j >= 0 ) { A [ j + 1 ] = A [ j ] ; j -- ; } A [ j + 1 ] = V ; } return 0 ; } 
1<CODESPLIT>Insertion Sort<CODESPLIT>#include<stdio.h> int main ( ) { int v , i , j , k , n , a [ 100 ] ; scanf ( "%d" , & n ) ; for ( i = 0 ; i <= n - 1 ; i ++ ) { scanf ( "%d" , & a [ i ] ) ; } for ( k = 0 ; k <= n - 1 ; k ++ ) { printf ( "%d" , a [ k ] ) ; if ( k ! = n - 1 ) printf ( " " ) ; } printf ( "\n" ) ; for ( i = 1 ; i <= n - 1 ; i ++ ) { v = a [ i ] ; j = i - 1 ; while ( j >= 0 && a [ j ] > v ) { a [ j + 1 ] = a [ j ] ; j -- ; } a [ j + 1 ] = v ; for ( k = 0 ; k <= n - 1 ; k ++ ) { printf ( "%d" , a [ k ] ) ; if ( k ! = n - 1 ) printf ( " " ) ; } printf ( "\n" ) ; } return 0 ; } 
1<CODESPLIT>Insertion Sort<CODESPLIT>#include <stdio.h> int main ( ) { int N , A [ 100 ] , i , k , j , key ; scanf ( "%d" , & N ) ; for ( i = 0 ; i < N ; i ++ ) scanf ( "%d" , & A [ i ] ) ; for ( i = 0 ; i < N - 1 ; i ++ ) printf ( "%d " , A [ i ] ) ; printf ( "%d\n" , A [ N - 1 ] ) ; for ( j = 1 ; j < N ; j ++ ) { key = A [ j ] ; i = j - 1 ; while ( i > - 1 && A [ i ] > key ) { A [ i + 1 ] = A [ i ] ; i -- ; } A [ i + 1 ] = key ; for ( k = 0 ; k < N - 1 ; k ++ ) printf ( "%d " , A [ k ] ) ; printf ( "%d\n" , A [ N - 1 ] ) ; } return 0 ; } 
1<CODESPLIT>Insertion Sort<CODESPLIT>#include <stdio.h> #define maxArraySize 1000 void output ( int a [ ] , int n ) { int c ; for ( c = 0 ; c < n ; c ++ ) { printf ( "%d" , a [ c ] ) ; if ( c ! = n - 1 ) printf ( " " ) ; } printf ( "\n" ) ; } void insersionSort ( int A [ ] , int N ) { int i , j , v ; for ( i = 1 ; i < N ; i ++ ) { v = A [ i ] ; j = i - 1 ; while ( j >= 0 && A [ j ] > v ) { A [ j + 1 ] = A [ j ] ; j -- ; } A [ j + 1 ] = v ; output ( A , N ) ; } } int main ( void ) { int a [ maxArraySize ] , n , c ; scanf ( "%d" , & n ) ; for ( c = 0 ; c < n ; c ++ ) { scanf ( "%d" , & a [ c ] ) ; } output ( a , n ) ; insersionSort ( a , n ) ; } 
1<CODESPLIT>Insertion Sort<CODESPLIT>#include <stdio.h> static const int N = 1000 ; void trace ( int A [ ] , int n ) { int i ; for ( i = 1 ; i <= n ; i ++ ) { if ( i > 1 ) printf ( " " ) ; printf ( "%d" , A [ i ] ) ; } printf ( "\n" ) ; } int main ( ) { int n , i , j , v ; int A [ N + 1 ] ; scanf ( "%d" , & n ) ; for ( i = 1 ; i <= n ; i ++ ) scanf ( "%d" , & A [ i ] ) ; trace ( A , n ) ; for ( i = 2 ; i <= n ; i ++ ) { v = A [ i ] ; j = i - 1 ; while ( j >= 0 && A [ j ] > v ) { A [ j + 1 ] = A [ j ] ; j -- ; A [ j + 1 ] = v ; } trace ( A , n ) ; } return 0 ; } 
1<CODESPLIT>Insertion Sort<CODESPLIT>#include<stdio.h> int main ( ) { int o , n , k , i , j ; int key ; int A [ 110 ] ; scanf ( "%d" , & n ) ; for ( i = 1 ; i <= n ; i ++ ) scanf ( "%d" , & A [ i ] ) ; for ( i = 1 ; i <= n ; i ++ ) { key = A [ i ] ; j = i - 1 ; while ( j > 0 && A [ j ] > key ) { A [ j + 1 ] = A [ j ] ; j -- ; } A [ j + 1 ] = key ; for ( k = 1 ; k <= n ; k ++ ) { if ( k == n ) printf ( "%d\n" , A [ k ] ) ; else printf ( "%d " , A [ k ] ) ; } } return 0 ; } 
1<CODESPLIT>Insertion Sort<CODESPLIT>#include <stdio.h> int main ( ) { int n , a [ 100 ] , i , k , j , key ; scanf ( "%d" , & n ) ; for ( i = 0 ; i < n ; i ++ ) scanf ( "%d" , & a [ i ] ) ; for ( i = 0 ; i < n - 1 ; i ++ ) printf ( "%d " , a [ i ] ) ; printf ( "%d\n" , a [ n - 1 ] ) ; for ( j = 1 ; j < n ; j ++ ) { key = a [ j ] ; i = j - 1 ; while ( i > - 1 && a [ i ] > key ) { a [ i + 1 ] = a [ i ] ; i -- ; } a [ i + 1 ] = key ; for ( k = 0 ; k < n - 1 ; k ++ ) printf ( "%d " , a [ k ] ) ; printf ( "%d\n" , a [ n - 1 ] ) ; } return 0 ; } 
1<CODESPLIT>Insertion Sort<CODESPLIT>#include <stdio.h> int main ( void ) { int N , i , j , v , k ; scanf ( "%d" , & N ) ; int A [ N ] ; for ( i = 0 ; i < N ; i ++ ) { scanf ( "%d" , & A [ i ] ) ; } for ( i = 1 ; i < N ; i ++ ) { for ( k = 0 ; k < N - 1 ; k ++ ) { printf ( "%d " , A [ k ] ) ; } printf ( "%d\n" , A [ N - 1 ] ) ; v = A [ i ] ; j = i - 1 ; while ( j >= 0 && A [ j ] > v ) { A [ j + 1 ] = A [ j ] ; j -- ; } A [ j + 1 ] = v ; } for ( k = 0 ; k < N - 1 ; k ++ ) { printf ( "%d " , A [ k ] ) ; } printf ( "%d\n" , A [ N - 1 ] ) ; return 0 ; } 
1<CODESPLIT>Insertion Sort<CODESPLIT>#include<stdio.h> void trace ( int A [ ] , int N ) { int i ; for ( i = 0 ; i < N ; i ++ ) { if ( i > 0 ) printf ( " " ) ; printf ( "%d" , A [ i ] ) ; } printf ( "\n" ) ; } void insertionSort ( int A [ ] , int N ) { int j , i , v ; for ( i = 1 ; i < N ; i ++ ) { v = A [ i ] ; j = i - 1 ; while ( j >= 0 && A [ j ] > v ) { A [ j + 1 ] = A [ j ] ; j -- ; } A [ j + 1 ] = v ; trace ( A , N ) ; } } int main ( ) { int N , i , j ; int A [ 100 ] ; scanf ( "%d" , & N ) ; for ( i = 0 ; i < N ; i ++ ) scanf ( "%d" , & A [ i ] ) ; trace ( A , N ) ; insertionSort ( A , N ) ; return 0 ; } 
1<CODESPLIT>Insertion Sort<CODESPLIT>#include<stdio.h> void insersion ( int * a , int n ) ; int main ( ) { int n ; scanf ( "%d" , & n ) ; int i , a [ n ] ; for ( i = 0 ; i < n ; i ++ ) { scanf ( "%d" , & a [ i ] ) ; } insersion ( a , n ) ; return 0 ; } void insersion ( int * a , int n ) { int i , j , v , k ; for ( i = 0 ; i <= n - 1 ; i ++ ) { v = a [ i ] ; j = i - 1 ; while ( j >= 0 && a [ j ] > v ) { a [ j + 1 ] = a [ j ] ; j -- ; } a [ j + 1 ] = v ; k = 0 ; while ( 1 ) { printf ( "%d" , a [ k ] ) ; k ++ ; if ( k == n ) { printf ( "\n" ) ; break ; } printf ( " " ) ; } } } 
1<CODESPLIT>Insertion Sort<CODESPLIT>#include <stdio.h> int main ( ) { int N ; int A [ 1000 ] = { 0 } ; int i , j , k ; int v = 0 ; scanf ( "%d" , & N ) ; for ( i = 0 ; i < N ; i ++ ) { scanf ( "%d" , & A [ i ] ) ; } for ( i = 0 ; i < N ; i ++ ) { if ( i == N - 1 ) { printf ( "%d" , A [ i ] ) ; } else printf ( "%d " , A [ i ] ) ; } printf ( "\n" ) ; for ( i = 1 ; i < N ; i ++ ) { v = A [ i ] ; j = i - 1 ; while ( j >= 0 && A [ j ] > v ) { A [ j + 1 ] = A [ j ] ; j -- ; } A [ j + 1 ] = v ; for ( k = 0 ; k < N ; k ++ ) { if ( k == N - 1 ) { printf ( "%d" , A [ k ] ) ; } else printf ( "%d " , A [ k ] ) ; } printf ( "\n" ) ; } return 0 ; } 
1<CODESPLIT>Insertion Sort<CODESPLIT>#define N 101 #include<stdio.h> void Print_Array ( short A [ ] , short num_of_A ) ; int main ( void ) { short i , j , num_of_A , A [ N ] , key ; scanf ( "%hd" , & num_of_A ) ; for ( i = 0 ; i < num_of_A ; i ++ ) { scanf ( "%hd" , & A [ i ] ) ; } for ( i = 1 ; i < num_of_A ; i ++ ) { Print_Array ( A , num_of_A ) ; key = A [ i ] ; j = i - 1 ; while ( j >= 0 && A [ j ] > key ) { A [ j + 1 ] = A [ j ] ; j -- ; } A [ j + 1 ] = key ; } Print_Array ( A , num_of_A ) ; return 0 ; } void Print_Array ( short A [ ] , short num_of_A ) { short i ; for ( i = 0 ; i < num_of_A ; i ++ ) { if ( i > 0 ) printf ( " " ) ; printf ( "%hd" , A [ i ] ) ; } printf ( "\n" ) ; } 
1<CODESPLIT>Insertion Sort<CODESPLIT>#include <stdio.h> #define MAX 100 int main ( ) { int key , i , j , n , c ; int arry [ MAX ] ; scanf ( "%d" , & n ) ; for ( i = 0 ; i < n ; i ++ ) scanf ( "%d" , & arry [ i ] ) ; for ( i = 0 ; i < n - 1 ; i ++ ) printf ( "%d " , arry [ i ] ) ; printf ( "%d" , arry [ n - 1 ] ) ; printf ( "\n" ) ; for ( i = 1 ; i < n ; i ++ ) { key = arry [ i ] ; j = i - 1 ; while ( j >= 0 && arry [ j ] > key ) { arry [ j + 1 ] = arry [ j ] ; j -- ; arry [ j + 1 ] = key ; } for ( c = 0 ; c < n - 1 ; c ++ ) printf ( "%d " , arry [ c ] ) ; printf ( "%d" , arry [ n - 1 ] ) ; printf ( "\n" ) ; } return 0 ; } 
1<CODESPLIT>Insertion Sort<CODESPLIT>#include<stdio.h> int main ( ) { int l , i , j , k , v ; scanf ( "%d" , & l ) ; int A [ l ] ; for ( i = 0 ; i < l ; i ++ ) { scanf ( "%d" , & A [ i ] ) ; } for ( i = 0 ; i < l ; i ++ ) { v = A [ i ] ; j = i - 1 ; while ( j >= 0 && A [ j ] > v ) { A [ j + 1 ] = A [ j ] ; j -- ; A [ j + 1 ] = v ; } for ( k = 0 ; k < l - 1 ; k ++ ) { printf ( "%d " , A [ k ] ) ; } printf ( "%d\n" , A [ k ] ) ; } return 0 ; } 
1<CODESPLIT>Insertion Sort<CODESPLIT>#include <stdio.h> #define N 100 int main ( void ) { int i , j , n , v ; int a [ N ] ; scanf ( "%d" , & n ) ; for ( i = 0 ; i < n ; i ++ ) { scanf ( "%d" , & v ) ; if ( 0 <= v && v <= 1000 ) { a [ i ] = v ; } else i -- ; } for ( i = 0 ; i < n ; i ++ ) { v = a [ i ] ; j = i - 1 ; while ( j >= 0 && a [ j ] > v ) { a [ j + 1 ] = a [ j ] ; j -- ; a [ j + 1 ] = v ; } for ( j = 0 ; j < n ; j ++ ) { if ( j < n - 1 ) printf ( "%d " , a [ j ] ) ; else printf ( "%d\n" , a [ j ] ) ; } } return 0 ; } 
1<CODESPLIT>Insertion Sort<CODESPLIT>#include<stdio.h> int main ( ) { int i , j , k = 0 , key , tmp , num ; int A [ 1000 ] ; scanf ( "%d" , & num ) ; for ( i = 0 ; i < num ; i ++ ) scanf ( "%d" , & A [ i ] ) ; for ( i = 0 ; i < num ; i ++ ) { key = A [ i ] ; j = i - 1 ; while ( j >= 0 && A [ j ] > key ) { A [ j + 1 ] = A [ j ] ; j -- ; A [ j + 1 ] = key ; } for ( k = 0 ; k < num ; k ++ ) if ( k == num - 1 ) printf ( "%d" , A [ num - 1 ] ) ; else printf ( "%d " , A [ k ] ) ; printf ( "\n" ) ; } return 0 ; } 
1<CODESPLIT>Insertion Sort<CODESPLIT>#include<stdio.h> void insertationSort ( int * sort , int n ) ; int main ( ) { int n = 0 , i = 0 ; scanf ( "%d" , & n ) ; int sort [ n ] ; for ( i = 0 ; i < n ; i ++ ) { scanf ( "%d" , & sort [ i ] ) ; } for ( int k = 0 ; k < n ; k ++ ) { printf ( "%d" , sort [ k ] ) ; if ( k < n - 1 ) { printf ( " " ) ; } else { printf ( "\n" ) ; } } insertationSort ( sort , n ) ; } void insertationSort ( int * sort , int n ) { int i = 0 , v = 0 , j = 0 ; for ( i = 1 ; i <= n - 1 ; i ++ ) { v = sort [ i ] ; j = i - 1 ; while ( j >= 0 && sort [ j ] > v ) { sort [ j + 1 ] = sort [ j ] ; j -- ; } sort [ j + 1 ] = v ; for ( int k = 0 ; k < n ; k ++ ) { printf ( "%d" , sort [ k ] ) ; if ( k < n - 1 ) { printf ( " " ) ; } else { printf ( "\n" ) ; } } } } 
1<CODESPLIT>Insertion Sort<CODESPLIT>#include <stdio.h> int A [ 100 ] ; void dump ( char * s , int len ) { int i ; for ( i = 0 ; i < len - 1 ; i ++ ) { printf ( "%d " , A [ i ] ) ; } printf ( "%d\n" , A [ len - 1 ] ) ; } int main ( ) { int num , i , j ; int key ; scanf ( "%d" , & num ) ; for ( i = 0 ; i < num ; i ++ ) { scanf ( "%d" , & A [ i ] ) ; } dump ( A , num ) ; for ( i = 1 ; i < num ; i ++ ) { key = A [ i ] ; j = i - 1 ; while ( j >= 0 && A [ j ] > key ) { A [ j + 1 ] = A [ j ] ; j -- ; } A [ j + 1 ] = key ; dump ( A , num ) ; } } 
1<CODESPLIT>Insertion Sort<CODESPLIT>#include<stdio.h> void trace ( int A [ ] , int N ) { int i ; for ( i = 0 ; i < N ; i ++ ) { if ( i > 0 ) { printf ( " " ) ; } printf ( "%d" , A [ i ] ) ; } printf ( "\n" ) ; } void insertionSort ( int A [ ] , int N ) { int i , j , v ; for ( i = 1 ; i < N ; i ++ ) { v = A [ i ] ; j = i - 1 ; while ( j >= 0 && A [ j ] > v ) { A [ j + 1 ] = A [ j ] ; j -- ; } A [ j + 1 ] = v ; trace ( A , N ) ; } } int main ( void ) { int N , i , j ; int A [ 100 ] ; scanf ( "%d" , & N ) ; for ( i = 0 ; i < N ; i ++ ) { scanf ( "%d" , & A [ i ] ) ; } trace ( A , N ) ; insertionSort ( A , N ) ; return 0 ; } 
1<CODESPLIT>Insertion Sort<CODESPLIT>#include <stdio.h> int main ( void ) { int n , k , i , j , v ; scanf ( "%d" , & n ) ; int A [ n ] ; for ( k = 0 ; k <= n - 1 ; k ++ ) { scanf ( "%d" , & A [ k ] ) ; printf ( "%d" , A [ k ] ) ; if ( k ! = n - 1 ) printf ( " " ) ; } printf ( "\n" ) ; for ( i = 1 ; i <= n - 1 ; i ++ ) { v = A [ i ] ; j = i - 1 ; while ( j >= 0 && A [ j ] > v ) { A [ j + 1 ] = A [ j ] ; j -- ; } A [ j + 1 ] = v ; for ( k = 0 ; k <= n - 1 ; k ++ ) { printf ( "%d" , A [ k ] ) ; if ( k ! = n - 1 ) printf ( " " ) ; } printf ( "\n" ) ; } } 
1<CODESPLIT>Insertion Sort<CODESPLIT>#include <stdio.h> void trace ( int A [ ] , int N ) { int i ; for ( i = 0 ; i < N ; i ++ ) { if ( i > 0 ) printf ( " " ) ; printf ( "%d" , A [ i ] ) ; } printf ( "\n" ) ; } void insertionSort ( int A [ ] , int N ) { int i , j , v ; for ( i = 1 ; i < N ; i ++ ) { v = A [ i ] ; j = i - 1 ; while ( j >= 0 && A [ j ] > v ) { A [ j + 1 ] = A [ j ] ; j -- ; } A [ j + 1 ] = v ; trace ( A , N ) ; } } int main ( void ) { int N , i ; int A [ 100 ] ; scanf ( "%d" , & N ) ; for ( i = 0 ; i < N ; i ++ ) { scanf ( "%d" , & A [ i ] ) ; } trace ( A , N ) ; insertionSort ( A , N ) ; return 0 ; } 
