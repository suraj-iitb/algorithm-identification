// BCC
#include <cstdio>
#include <algorithm>
#include <iostream>
#include <utility>
#include <vector>
#include <queue>

// GCC
// #include <bits/stdc++.h>

using namespace std;

#define rep(i, n) for (int i = 0; i < (int)(n); i++)
#define rrep(i, n) for (int i = (int)(n) - 1; i >= 0; i--)
#define each(i, c) for (__typeof((c).begin()) i = (c).begin(); i != (c).end(); ++i)
#define chmin(a, b) a = min(a, b)
#define chmax(a, b) a = max(a, b)
#define pb push_back
#define mp make_pair

typedef long long ll;

const int INF = 1 << 28;
const ll INFLL = 1ll << 56;

typedef ll Cost;

struct Edge {
	int src, dst;
	Cost cost;
	bool operator < (const Edge &e) const {
		return cost > e.cost; // ???????????£??????????????¨?????¨???
	}
};

typedef vector<Edge> Edges;
typedef vector<Edges> Graph;

/**
 * ???????§????????????? (Dijkstra ???)
 * ?????????????????¨????????????
 * dijkstra(graph, s) ?§???? s ????????????????????§????????¢?????????
 * buildPath(t) ?????? t ???????§?????????§??????????????????
 */

vector<int> prev_; // ???????????¨????????????

vector<Cost> dijkstra(const Graph &g, int s){
	vector<Cost> dist(g.size(), INFLL);
	prev_.assign(g.size(), -1);
	priority_queue<Edge> pq;
	
	dist[s] = 0;
	pq.push({-1, s, 0});
	while (pq.size()){
		Edge c = pq.top(); pq.pop();
		prev_[c.dst] = c.src;
		each(e, g[c.dst]){
			if (dist[e->dst] > c.cost + e->cost){
				dist[e->dst] = c.cost + e->cost;
				pq.push({e->src, e->dst, dist[e->dst]});
			}
		}
	}
	
	return dist;
}


/**
 * ????????????
 * dijkstra ??????????????????
 */

vector<int> buildPath(int t){
	vector<int> res;
	for (int v = t; v != -1; v = prev_[v]){
		res.pb(v);
	}
	reverse(res.begin(), res.end());
	return res;
}


int main()
{
	int n, m, s;
	scanf("%d %d %d", &n, &m, &s);
	Graph g(n);
	rep(i, m){
		int a, b, c;
		scanf("%d %d %d", &a, &b, &c);
		g[a].pb({a, b, c});
	}
	std::vector<ll> res = dijkstra(g, s);
	each(x, res){
		if (*x == INFLL) puts("INF");
		else printf("%lld\n", *x);
	}
}
