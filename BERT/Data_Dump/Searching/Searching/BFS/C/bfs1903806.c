/* include */
#include <stdio.h>

/* define */
#define MAX 1000
#define INFTY -1

/* prototype define */
void bfs(int);
// queue
void push(int);
int pop();
int isEmpty();
int isFull();

/* struct */
struct Queue{
  int vertex;
};

/* global */
int n, MATRIX[MAX][MAX], DEG[MAX];
// queue
struct Queue Q[MAX];
int head=0,tail=0;


int main(){
  int from, to, deg, i, j;

  /* input size */
  scanf("%d", &n);

  /* initialize */
  for(i=0;i<n;i++){
    for(j=0;j<n;j++){
      MATRIX[i][j] =0;
    }
  }
  
  /* create matrix */
  for(i=0;i<n;i++){
    scanf("%d %d", &from, &deg);
    from--;
    for(j=0;j<deg;j++){
      scanf("%d", &to);
      to--;
      MATRIX[from][to] = 1;
    }
  }
  bfs(0);
  return 0;
}

/* Breadth First Search */
void bfs(int root){
  int from, to, i;
  push(root); //root????????\??????????´?

  /* initialize */
  for(i=0;i<n;i++){
    DEG[i] = INFTY;
  }
  DEG[root] = 0; //root????¬???°???0
  
  /* scanning */
  while(!isEmpty()){ //?????\???????????§????????????
    from = pop();
    for(to=0;to<n;to++){
      if(MATRIX[from][to]==0) { //????????????????????????
        continue;
      }
      if(DEG[to]!=INFTY){ //????????¶???(????¨????)?????¨??????DEG[to]????¬???°????¨??????????(continue????¬????while????????£????????????)
        continue;
      }
      DEG[to] = DEG[from] + 1; //++??§????????????
      push(to);
    }
  }
  
  /* print */
  for(i=0;i<n;i++){
    printf("%d ", i+1); //1?????????????????´???
    if(DEG[i]==INFTY){ //??°??????????????????
      printf("-1");
    }else{
      printf("%d",DEG[i]);
    }
    printf("\n");
  }
}


/* QUEUE (alds1-3-C.c)*/
/* the method of enqueue */
void push(int new){ 
  //????´??????£??\
  Q[tail].vertex = new;

  if(tail + 1 == MAX){ //???????????????????????????????????°
    tail = 0;
  }else{
    tail++;
  }
}

/* the method of dequeue */
int pop(){
  struct Queue x;

  x = Q[head];
  if(head + 1 == MAX){ //?¬????????´???´????????¢????????´????????????????????????
    head = 0;
  }else{
    head++;
  }

//  printf("dequeue: %s %d\n",x.name, x.time); //@@

  return x.vertex;
}

 /**
  * Judge the queue is if Empty or not 
  * 1: is Empty
  * 0: is not Empty
  */
int isEmpty(){
  if(head==tail){
//    printf("Error: Underflow\n");
    return 1;
  }else{
    return 0;
  }
}

 /**
  * Judge the queue is if Full or not 
  * 1: is Full
  * 0: is not Full
  */
int isFull(){
  if(head == (tail+1)%MAX){ //%MAX??????????????¨???head==0, tail==MAX-1?????????head==tail+1??§Full??¨??????????????????
//    printf("Error: Overflow\n");
    return 1;
  }else{
    return 0;
  }
}
