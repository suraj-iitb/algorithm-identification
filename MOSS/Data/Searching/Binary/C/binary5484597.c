/* ファイル名：ALDS1_4_B.c	*/
/* 内容：n個の整数を含む数列Sと、q個の異なる整数を含む数列Tを読み込み、	*/
/*		 Tに含まれる整数の中でSに含まれるものの個数Cを出力する			*/
/*		 ただし、ALDS1_4_Aとは違い、今回は二分探索で要素を探索すること	*/
/* 入力：1行目にn、2行目にn個の整数を含むSが与えられる。				*/
/* 		 その後、3行目にq、4行目にq個の異なる整数を含む数列Tが与えられる。*/
/* 出力：Tに含まれる整数の中でSに含まれるものをカウントしたCを出力する。*/

/* include	*/
#include <stdio.h>

/* 定数定義	*/
#define S_MAX 100000
#define T_MAX 50000
#define ARRAY_MIN 0
#define NUM_MAX 1000000000
#define NUM_MIN 0

/* 外部変数宣言	*/

/* プロトタイプ宣言	*/

/* 関数名:main												*/
/* 処理内容:情報を受け取り、Binary_Search関数を呼び出す。	*/
/* 			その後、その結果を出力する。					*/
int main( void )
{
	/* 内部変数宣言	*/
	/* 入力	*/
	int n;			/* 数列Sの要素数	*/
	int S[S_MAX];	/* 数列S			*/
	int q;			/* 数列Tの要素数	*/
	int T[T_MAX];	/* 数列T			*/
	
	/* 処理	*/
	int i;			/* ループ用変数1	*/
	int j;			/* ループ用変数2	*/
	int left;		/* 探索範囲の一番左の添え字	*/
	int right;		/* 探索範囲の一番右の添え字	*/
	int center;		/* 探索範囲の中央の添え字	*/
	/* 出力	*/
	int C;			/* Tに含まれる整数の中でSに含まれるものの個数	*/
	
	/* 出力の初期化	*/
	C = 0;
	
	/* nの入力	*/
	while(1){
		scanf( "%d", &n );/* nを入力	*/
		/* 制約事項の値の範囲内の場合	*/
		if( n <= S_MAX ){
			break;	/* ループを抜ける	*/
		}
		else{
			printf( "もう一度入力して下さい\n" );
		}
	}
	
	/* nの数だけループ */
	for( i = 0; i < n; i++ ){
		while(1){
			scanf( "%d", &S[i] );/* Sの要素を入力	*/
			/* 制約事項の値の範囲内の場合	*/
			if(( S[i] >= NUM_MIN )
			&& ( S[i] <= NUM_MAX )){
				break;	/* ループを抜ける	*/
			}
			else{
				printf( "もう一度入力して下さい\n" );
			}
		}
	}
	
	/* qの入力	*/
	while(1){
		scanf( "%d", &q );/* qを入力	*/
		/* 制約事項の値の範囲内の場合	*/
		if( q <= T_MAX ){
			break;	/* ループを抜ける	*/
		}
		else{
			printf( "もう一度入力して下さい\n" );
		}
	}
	
	/* qの数だけループ */
	for( i = 0; i < q; i++ ){
		while(1){
			scanf( "%d", &T[i] );/* Tの要素を入力	*/
			/* 制約事項の値の範囲内の場合	*/
			if(( T[i] >= NUM_MIN )
			&& ( T[i] <= NUM_MAX )){
				break;	/* ループを抜ける	*/
			}
			else{
				printf( "もう一度入力して下さい\n" );
			}
		}
	}
	
	/* Tの要素を1つずつ読み取り、Sの中から同じ整数があるかを二分探索する */
	for( i = 0; i < q; i++ ){
		/* 探索範囲を表す添え字の初期化	*/
		left = 0;		/* 探索範囲の一番左の添え字	*/
		right = n;		/* 探索範囲の一番右の添え字	*/
		/* 二分探索(探索範囲がなくなるまで)	*/
		while( left < right ){
			center = ( left + right ) / 2 ;		/* 探索範囲の中央の添え字を設定	*/
			
			/* 探索範囲の中央の値が探索している値と等しい場合	*/
			if( S[center] == T[i] ){
				C++;	/* Tに含まれる整数の中でSに含まれるものの個数をカウントする	*/
				break;	/* ループを抜ける											*/
			}
			/* 探索範囲の中央の値が探索している値より小さい場合	*/
			else if( S[center] < T[i] ){
				left = center + 1;	/* 探索範囲の一番左の添え字を更新(centerでは小さすぎるため、そこから除外する)	*/
			}
			
			/* 探索範囲の中央の値が探索している値より大きい場合	*/
			else{
				right = center;	/* 探索範囲の一番右の添え字を更新	*/
			}
		}
	}
	
	
	/* 結果の出力 */
	printf( "%d\n", C );
	return 0;
}
